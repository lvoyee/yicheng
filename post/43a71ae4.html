<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="伊成个人站-热衷于技术分享，源码分享的个人网站">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
	<!--baidu tongji-->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "https://hm.baidu.com/hm.js?11f6f08fada932368f71e76bd659b783";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	
    <link rel="dns-prefetch" href="http://www.devcheng.net">
    <!--SEO-->

<meta name="description" content="伊成个人站 www.devcheng.net 一个致力于技术分享，源码分享及工作经历分享的个人网站">



<meta name="keywords" content="伊成个人站,技术分享,源码分享,代码分享,java代码,源代码">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->

<title>	MySQL索引-伊成个人站</title>

    <link rel="alternate" href="/atom.xml" title="伊成个人站-热衷于技术分享，源码分享的个人网站" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">





    





    


</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header">
    <div class="main-header-box">
       ◉◡◉ 您好，欢迎到访伊成个人站!
    </div>
</header>
    
<nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://www.devcheng.net">伊成个人站-热衷于技术分享，源码分享的个人网站</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">				
                    <ul class="menu">						
						<a href="/"><img border="0" src="/img/logo2020.png" alt="伊成个人站" title="伊成个人站"></a>						
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa fa-home"></i>&nbsp;首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/blogshare/"><i class="fa fa-codepen"></i>&nbsp;技术分享</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/codeshare/"><i class="fa fa-code"></i>&nbsp;源码分享</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/codelife/"><i class="fa fa-pagelines"></i>&nbsp;程序人生</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives"><i class="fa fa-history"></i>&nbsp;时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about"><i class="fa fa-connectdevelop"></i>&nbsp;关于</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="MySQL索引">
            
	            MySQL索引
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/blogshare">
            blogshare
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/MySQL索引" title="MySQL索引">
                        MySQL索引
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/11/29</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最典型的例子就是查新华字典，通过查找目录快速定位到查找的字</p>
<ul>
<li>大大减少了服务器需要扫描的数量</li>
<li>帮助服务器避免排序和临时表</li>
<li>将IO变成顺序IO<ul>
<li>尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问</li>
<li>在复制1G压缩包 和 1G小文件，前者的速度会大于后者</li>
<li>减少IO的量，例如写SQL语句的时候，不要写 select *</li>
<li>减少IO的次数，一次IO能搞定的事，不使用3次IO</li>
</ul>
</li>
</ul>
<h2 id="索引的用处"><a href="#索引的用处" class="headerlink" title="索引的用处"></a>索引的用处</h2><ul>
<li>快速查找匹配where子句的行</li>
<li>从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用栈找到最少行的索引</li>
<li>如果表具有多列索引，则优化器可以使用索引的最左匹配前缀来查找</li>
<li>当有表连接的时候，从其他表检测行数据</li>
<li>查找特定索引列min或max值</li>
<li>如果排序或分组是，在可用索引的最左前缀上完成的，则对表进行排序和分组</li>
<li>在某些清空下，可以优化查询以检索值而无需查询数据行</li>
</ul>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>如果你在创建索引的时候，使用的是主键这个值，那么就是主键索引，primary key</p>
<p>我们建表的时候，例如下面这个建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_blog_sort`</span> (</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一uid'</span>,</span><br><span class="line">  <span class="string">`sort_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类内容'</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类简介'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`status`</span> tinyint(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</span><br><span class="line">  <span class="string">`sort`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'排序字段，越大越靠前'</span>,</span><br><span class="line">  <span class="string">`click_count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'点击数'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'博客分类表'</span>;</span><br></pre></td></tr></table></figure>
<p>这里面有使用到    PRIMARY KEY (<code>uid</code>)，这就是主键索引</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引 类似于普通索引，索引列的值必须唯一</p>
<p>唯一索引和主键索引的区别就是，唯一索引允许出现空值，而主键索引不能为空</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>
<p>或者创建表时指定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique index_name column</span><br></pre></td></tr></table></figure>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>当我们需要建立索引的字段，既不是主键索引，也不是唯一索引</p>
<p>那么就可以创建一个普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>
<p>或者创建表时指定</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>(..., <span class="keyword">index</span> index_name <span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>lunce、solr和ElasticSearch就是做全文检索的，里面涉及到了倒排索引的概念，mysql很少使用全文索引。</p>
<p>要用来查找文本中的关键字，不是直接与索引中的值相比较，像是一个搜索引擎，配合 match against 使用，现在只有char，varchar，text上可以创建索引，在数据量比较大时，先将数据放在一个没有全文索引的表里，然后在利用create index创建全文索引，比先生成全文索引在插入数据快很多。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>目前，在业务不是特别复杂的时候，可能使用一个列作为索引，或者直接采用主键索引即可，但是如果业务变得复杂的时候，就需要用到组合索引，通过对多个列建立索引。</p>
<p>组合索引的用处，假设我现在表有个多个字段：id、name、age、gender，然后我经常使用以下的查询条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'xx'</span> <span class="keyword">and</span> age = xx</span><br></pre></td></tr></table></figure>
<p>这个时候，我们就可以通过组合 name 和 age 来建立一个组合索引，加快查询效率，建立成组合索引后，我的索引将包含两个key值</p>
<p>在多个字段上创建索引，遵循<strong>最左匹配</strong>原则</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> index_name(a,b,c);</span><br></pre></td></tr></table></figure>
<h2 id="索引的使用与否"><a href="#索引的使用与否" class="headerlink" title="索引的使用与否"></a>索引的使用与否</h2><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>MySQL每次只使用一个索引，与其说 数据库查询只能用一个索引，倒不如说，和全表扫描比起来，去分析两个索引 B+树更耗费时间，所以where A=a and B=b 这种查询使用（A，B）的组合索引最佳，B+树根据（A，B）来排序。</p>
<ul>
<li>主键，unique字段</li>
<li>和其他表做连接的字段需要加索引</li>
<li>在where 里使用 &gt;, &gt;=, = , &lt;, &lt;=, is null 和 between等字段。</li>
<li>使用不以通配符开始的like，where A like ‘China%’</li>
<li>聚合函数里面的 MIN()， MAX()的字段</li>
<li>order by  和 group by字段</li>
</ul>
<h3 id="何时不使用索引"><a href="#何时不使用索引" class="headerlink" title="何时不使用索引"></a>何时不使用索引</h3><ul>
<li>表记录太少</li>
<li>数据重复且分布平均的字段（只有很少数据的列）；</li>
<li>经常插入、删除、修改的表要减少索引</li>
<li>text，image 等类型不应该建立索引，这些列的数据量大（加入text的前10个字符唯一，也可以对text前10个字符建立索引）</li>
<li>MySQL能估计出全表扫描比使用索引更快的时候，不使用索引</li>
</ul>
<h3 id="索引何时失效"><a href="#索引何时失效" class="headerlink" title="索引何时失效"></a>索引何时失效</h3><ul>
<li>组合索引为使用最左前缀，例如组合索引（A，B），where B = b 不会使用索引</li>
<li>like未使用最左前缀，where A  like “%China”</li>
<li>搜索一个索引而在另一个索引上做 order by， where A = a order by B，只会使用A上的索引，因为查询只使用一个索引。</li>
<li>or会使索引失效。如果查询字段相同，也可以使用索引。例如  where A = a1 or A = a2（生效），where A=a or B = b （失效）</li>
<li>在索引列上的操作，函数upper()等，or、！ = （&lt;&gt;）,not in 等</li>
</ul>
<h2 id="面试技术名词"><a href="#面试技术名词" class="headerlink" title="面试技术名词"></a>面试技术名词</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>首先我们需要知道，我们建立几个索引，就会生成几棵B+Tree，但是带有原始数据行的B+Tree只有一棵，另外一棵树上的叶子节点带的是主键值。</p>
<p>例如，我们通过主键建立了主键索引，然后在叶子节点上存放的是我们的数据</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094621998.png" alt="image-20200629094621998"></p>
<p>当我们创建了两个索引时，一个是主键，一个是name，它还会在生成一棵B+Tree，这棵树的叶子节点存放的是主键，当我们通过name进行查找的时候，会得到一个主键，然后在通过主键再去上面的这个主键B+Tree中进行查找，我们称这个操作为 ==<strong>回表</strong>==</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p>
<p>当我们的SQL语句使用的是下面这种的时候，它会查找第一颗树，直接返回我们的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb where id = 1</span><br></pre></td></tr></table></figure>
<p>当我们使用下面这种查询的时候，它会先查找第二棵树得到我们的主键，然后拿着主键再去查询第一棵树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb  where name = &apos;gang&apos;</span><br></pre></td></tr></table></figure>
<p>回表就是通过普通列的索引进行检索，然后再去主键列进行检索，这个操作就是回表</p>
<p>==但是我们在使用检索的时候，尽量避免回表，因为这会造成两次B+Tree的查询，假设一次B+Tree查询需要三次IO操作，那么查询两次B+Tree就需要六次IO操作。==</p>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>我们看下面的两个SQL语句，看看它们的查询过程是一样的么？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">name</span> = zhou</span><br></pre></td></tr></table></figure>
<p>答案是不一样的，首先我们看第二个语句，就是要输出的列中，就是我们的主键，当我们通过name建立的B+Tree进行查询的时候</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p>
<p>我们可以直接找到我们的数据，并得到主键，但是因为我们要返回的就是name，此时说明数据存在了，那么就直接把当前的name进行返回，而不需要通过主键再去主键B+Tree中进行查询。</p>
<p>这样一个不需要进行回表操作的过程，我们称为<strong>索引覆盖</strong></p>
<h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>这里提到的 <strong>最左匹配</strong> 和 <strong>索引下推</strong> 都是针对于组合索引的。</p>
<p>例如，我们有这样一个索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  age：组合索引</span><br></pre></td></tr></table></figure>
<p>必须要先匹配name，才能匹配到age。这个我们就被称为最左匹配</p>
<p>例如下面的几条SQL语句，那些语句不会使用组合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where name = ? and age = ?</span><br><span class="line">where name = ?</span><br><span class="line">where age = ?</span><br><span class="line">where age = ? and name = ?</span><br></pre></td></tr></table></figure>
<p>根据最左匹配原则，我们的 3 不会使用组合索引的。</p>
<p>那为什么4的顺序不一样，也会使用组合索引呢？</p>
<p>其实内部的优化器会进行调整，例如下面的一个连表操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id = tb2.id</span><br></pre></td></tr></table></figure>
<p>其实在加载表的时候，并不一定是先加载tb1，在加载tb2，而是可能根据表的大小决定的，小的表优先加载进内存中。</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>在说索引下推的时候，我们首先在举两个例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">name</span> = ? <span class="keyword">and</span> age = ?</span><br></pre></td></tr></table></figure>
<p>在mysq 5.6之前，会先根据name去存储引擎中拿到所有的数据，然后在server层对age进行数据过滤</p>
<p>在mysql5.6之后，根据name 和 age两个列的值去获取数据，直到把数据返回。</p>
<p>通过对比能够发现，第一个的效率低，第二个的效率高，因为整体的IO量少了，原来是把数据查询出来，在server层进行筛选，而现在在存储引擎层面进行筛选，然后返回结果。我们把这个过程就称为  <strong>索引下推</strong></p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h4 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h4><p>基于成本的优化</p>
<h4 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h4><p>基于规则的优化</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629110258878.png" alt="image-20200629110258878"></p>
<h2 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h2><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配指的是和索引中所有的列进行匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>
<p>而我们建立了一个 包含  name、age、pos的组合索引，使用上面的SQL语句，就会进行全值匹配</p>
<h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>只匹配前面的几列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>这个时候，只使匹配了前面两个列，而没有使用第三个列</p>
<p>现在我们使用下面的SQL语句进行验证，但我们输出值只包含ID的时候</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们查看其任务计划，在某尾有 Extra字段，如果是Using index 表示是使用了覆盖索引</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629144438346.png" alt="image-20200629144438346"></p>
<p>然后我们在查看下面这条SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>通过查看任务计划，发现extra字段是NULL，说明没有使用覆盖索引</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629145948288.png" alt="image-20200629145948288"></p>
<h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>可以匹配某一列值的开头部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'J%'</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'%y'</span></span><br></pre></td></tr></table></figure>
<h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>可以查找某个范围的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span></span><br></pre></td></tr></table></figure>
<h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>可以查询某一列的全部和第二列的部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"July"</span> <span class="keyword">and</span> age &gt; <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>查询的时候值需要访问索引，不需要访问数据行，本质上就是索引覆盖</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"July"</span> <span class="keyword">and</span> age=<span class="number">25</span> <span class="keyword">and</span> pos = <span class="string">"dev"</span></span><br></pre></td></tr></table></figure>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>基于哈希的实现，只有精确匹配索引所有的列的查询才有效，在mysql中，只有memory的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，索引索引的结构十分紧凑，这让哈希索引查找的速度非常快。</p>
<h3 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h3><ul>
<li>哈希索引值包含哈希值和行指针，而不存储字段值。索引不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li>
<li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li>
<li>哈希索引支持等值比较查询，也不支持任何范围查询</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，知道找到所有符合条件的行</li>
<li>哈希冲突比较多的话，维护的代价也会很高</li>
</ul>
<h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按每张表的主键构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据也，这个特性就决定了索引组织表中的数据也是索引的一部分。</p>
<p>==一句话来说：将索引和数据放在一起的，就称为聚簇索引==</p>
<p>我们日常的工作中，根据实际情况自行添加的索引，都是辅助索引或者称为普通索引，辅助索引就是为了查找主键索引的二级索引，先找到主键索引然后再通过主键索引找数据，但是可能会存在<strong>回表</strong>的问题。</p>
<h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对主键的排序和范围查找速度非常快</li>
</ul>
<h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul>
<li>插入速度严重依赖于排序，按照主键的顺序插入是最快的方式，否者会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动，因此，对于InnoDB表，我们一般定义主键不可更新</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次 根据主键值查找行数据，一般我们需要尽量避免出现索引的二次查找，这个时候，用到的就是<strong>索引的覆盖</strong></li>
</ul>
<h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引也被称为辅助索引，辅助索引在我们访问数据的时候总是需要两次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到主键值，然后在通过主键值找到数据行的数据页，在通过数据页中的Page Directory找到数据行。</p>
<p>InnoDB辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了行数据的聚簇索引建。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在InnoDB中有时也称为辅助索引为二级索引</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629113413737.png" alt="image-20200629113413737"></p>
<h2 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p>
<p>第4个不走索引，是因为不满足最左匹配原则</p>
<p>第5个，因为跨过了b，所以只走a的索引</p>
<h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><ul>
<li><p>当使用索引列进行查询的时候，尽量不要使用表达式，把计算放到业务层而不是数据库层</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">4</span></span><br><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id+<span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>第一条语句走索引</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161629049.png" alt="image-20200629161629049"></p>
<p>而第二条语句没有走主键索引</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161641522.png" alt="image-20200629161641522"></p>
</li>
<li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表操作</p>
</li>
<li><p>使用前缀索引</p>
</li>
</ul>
<p>有时候需要索引很长的字符串，这会让索引变得大且满，通常情况下可以使用某个列开始的部分字符串，这样大大的节约了索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T 到 1 之间，索引的选择性越高，则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p>
<p>一般情况下，某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOG，TEXT，VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于选择足够长的前缀以保证较高的选择性，通过又不能太长 。</p>
<ul>
<li>使用索引扫描来进行排序</li>
<li>union、all、in、or都能使用索引，但是推荐使用in</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">union</span> all <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> actor_id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关于or到底走不走索引，必须根据实际情况进行考虑</span></span><br></pre></td></tr></table></figure>
<ul>
<li>范围列可以使用到索引</li>
</ul>
<p>例如 范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p>
<p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，所以一般如果我们使用组合索引的时候，最好不要使用范围查找</p>
<p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p>
<p>如倒数第一个所示，因为中间b使用了范围查找，所以后面的c是无法使用索引的，只能是a和b才能使用索引</p>
<ul>
<li>强制类型转换会让索引失效，进行全表查询</li>
</ul>
<p>例如下面这样一个例子所示，我们对 phone字段进行了强制类型转换</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="number">13800001234</span>  <span class="comment">-- 不会触发索引（触发了字符串到整型转换）</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="string">'13800001234'</span>  <span class="comment">-- 触发索引</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更新十分频繁，数据区分度不高的字段上不宜建立索引</li>
</ul>
<p>更新会变更B+树，更新 频繁的字段建立索引会大大降低数据库性能</p>
<p>类似于性别这列的区分度不高的字段，建立索引是没有意义的，不能有效的过滤数据</p>
<p>一般区分度在百分80以上的时候，就可以建立索引，区分度可以使用 count(distinct(列名)) / count(*) 来进行计算</p>
<ul>
<li>创建索引的列，不允许为null，可能会得到不符合预期的结果</li>
<li>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致（阿里规约）<ul>
<li>允许数据的冗余，从而加快查询的效率</li>
<li>目前是范式和反范式的混合使用</li>
</ul>
</li>
<li>能使用limit的时候，尽量使用limit</li>
<li>单表索引建议控制在5个以内</li>
<li>单索引字段不允许超过5个（组合索引）</li>
<li>创建索引的时候应该尽量避免以下错误的概念</li>
</ul>
<p>索引不是越多越好，不要在不了解系统的情况下进行优化</p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="/img/reward-alipay.png"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="/img/reward-wepay.png"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip"></p>
</div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处！
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/post/2a798f18.html" class="next-post btn btn-default" title="并发锁知识点">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">并发锁知识点</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>

    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>

    <script>
        new Valine({           
            el: '#vcomments',
            appId: 'sbQDWnkLFsRjJS2BGzfKc4rL-gzGzoHsz',
            appKey: '5u9C0UUmzRe3unr9iLzheHjk',
            placeholder: '文明社会,理性评论留言 ^_^……',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的优点"><span class="toc-text">索引的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的用处"><span class="toc-text">索引的用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的分类"><span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主键索引"><span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#唯一索引"><span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#普通索引"><span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全文索引"><span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合索引"><span class="toc-text">组合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的使用与否"><span class="toc-text">索引的使用与否</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的使用"><span class="toc-text">索引的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何时不使用索引"><span class="toc-text">何时不使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引何时失效"><span class="toc-text">索引何时失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试技术名词"><span class="toc-text">面试技术名词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#回表"><span class="toc-text">回表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引覆盖"><span class="toc-text">索引覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最左匹配"><span class="toc-text">最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引下推"><span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化器"><span class="toc-text">优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CBO"><span class="toc-text">CBO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RBO"><span class="toc-text">RBO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引匹配方式"><span class="toc-text">索引匹配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全值匹配"><span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配最左前缀"><span class="toc-text">匹配最左前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配列前缀"><span class="toc-text">匹配列前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配范围值"><span class="toc-text">匹配范围值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精确匹配某一列并范围匹配另外一列"><span class="toc-text">精确匹配某一列并范围匹配另外一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#只访问索引的查询"><span class="toc-text">只访问索引的查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希索引"><span class="toc-text">哈希索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希索引的限制"><span class="toc-text">哈希索引的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聚簇索引和非聚簇索引"><span class="toc-text">聚簇索引和非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#聚簇索引"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚簇索引的优点"><span class="toc-text">聚簇索引的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚簇索引的缺点"><span class="toc-text">聚簇索引的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非聚簇索引"><span class="toc-text">非聚簇索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合索引-1"><span class="toc-text">组合索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化细节"><span class="toc-text">优化细节</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2018 - 2020
                </span> | .<font color="#f1607d">伊</font><font color="#ffa500">成</font><font color="#e5e802">个</font><font color="#3bff23">人</font><font color="#ffa503">站</font><font color="#29c8ec"> devcheng</font><font color="#4f9cfa">.net</font>. |
                <span>
                    基于 Hexo 搭建
                </span> |
                <span>
                     <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">博客地图</a>
                </span> |
				<span>
					 <a href="/atom.xml" class="copyright-links" target="_blank" rel="nofollow">RSS订阅</a> 
				</span> |
				<span>
                    <a href="https://beian.miit.gov.cn/" class="copyright-links" target="_blank" rel="nofollow">湘ICP备20010839号</a> 
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>