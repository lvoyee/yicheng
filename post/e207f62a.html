<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="伊成个人站-热衷于技术分享，源码分享的个人网站">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
	<!--baidu tongji-->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "https://hm.baidu.com/hm.js?11f6f08fada932368f71e76bd659b783";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	
    <link rel="dns-prefetch" href="http://www.devcheng.net">
    <!--SEO-->

<meta name="description" content="伊成个人站 www.devcheng.net 一个致力于技术分享，源码分享及工作经历分享的个人网站">



<meta name="keywords" content="伊成个人站,技术分享,源码分享,代码分享,java代码,源代码">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->

<title>	Java基础笔记整合-伊成个人站</title>

    <link rel="alternate" href="/atom.xml" title="伊成个人站-热衷于技术分享，源码分享的个人网站" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">





    





    


</head></html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header">
    <div class="main-header-box">
       ◉◡◉ 您好，欢迎到访伊成个人站!
    </div>
</header>
    
<nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://www.devcheng.net">伊成个人站-热衷于技术分享，源码分享的个人网站</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">				
                    <ul class="menu">						
						<a href="/"><img border="0" src="/img/logo2020.png" alt="伊成个人站" title="伊成个人站"></a>						
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa fa-home"></i>&nbsp;首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/blogshare/"><i class="fa fa-codepen"></i>&nbsp;技术分享</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/codeshare/"><i class="fa fa-code"></i>&nbsp;源码分享</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/codelife/"><i class="fa fa-pagelines"></i>&nbsp;程序人生</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives"><i class="fa fa-history"></i>&nbsp;时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about"><i class="fa fa-connectdevelop"></i>&nbsp;关于</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Java基础笔记整合">
            
	            Java基础笔记整合
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/blogshare">
            blogshare
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/Java基础" title="Java基础">
                        Java基础
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/06/07</span>
        </span>
        
    
</div>

            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>760</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h4 id="记录最基础-最容易忘记的笔记"><a href="#记录最基础-最容易忘记的笔记" class="headerlink" title="记录最基础 最容易忘记的笔记"></a><code>记录最基础 最容易忘记的笔记</code></h4><h2 id="一-JAVA基础"><a href="#一-JAVA基础" class="headerlink" title="一.JAVA基础"></a>一.JAVA基础</h2><h2 id="1-1-JAVA异常知识点"><a href="#1-1-JAVA异常知识点" class="headerlink" title="1.1 JAVA异常知识点"></a>1.1 JAVA异常知识点</h2><p>Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。下一层分为Error和Exception;</p>
<p><img src="https://s2.ax1x.com/2019/06/07/V0OBZt.png" alt="V0OBZt.png"></p>
<h4 id="1-1-1-Error"><a href="#1-1-1-Error" class="headerlink" title="1.1.1 Error"></a>1.1.1 Error</h4><p>Error类是指java运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p>
<h4 id="1-1-2-Exception"><a href="#1-1-2-Exception" class="headerlink" title="1.1.2 Exception"></a>1.1.2 Exception</h4><p>Exception又有两个分支，一个是运行时异常RuntimeException，一个是CheckedException。</p>
<h5 id="1-1-2-1-RuntimeException"><a href="#1-1-2-1-RuntimeException" class="headerlink" title="1.1.2.1 RuntimeException"></a>1.1.2.1 RuntimeException</h5><p>如：NullPointerException、ClassCastException；一个是检查异常CheckedException，如I/O错误导致的IOException、SQLException。 RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。<br>如果出现RuntimeException，那么一定是程序员的错误。</p>
<h5 id="1-1-2-2-CheckedException"><a href="#1-1-2-2-CheckedException" class="headerlink" title="1.1.2.2 CheckedException"></a>1.1.2.2 CheckedException</h5><p>一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行try catch，该类异常一般包括几个方面： </p>
<ol>
<li>试图在文件尾部读取数据 </li>
<li>试图打开一个错误格式的URL </li>
<li>试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在</li>
</ol>
<h4 id="1-1-3-异常的处理方式"><a href="#1-1-3-异常的处理方式" class="headerlink" title="1.1.3 异常的处理方式"></a>1.1.3 异常的处理方式</h4><p>抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception</span>&#123; <span class="keyword">return</span> a/b;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-Throw和throws的区别"><a href="#1-1-4-Throw和throws的区别" class="headerlink" title="1.1.4 Throw和throws的区别"></a>1.1.4 Throw和throws的区别</h4><ul>
<li>位置不同 </li>
</ul>
<ol>
<li>throws用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后面跟的是异常对象。</li>
</ol>
<ul>
<li>功能不同： </li>
</ul>
<ol start="2">
<li><p>throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；<br>throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。<br>也就是说throw语句独立存在时，下面不要定义其他语句，因为执行不到。 </p>
</li>
<li><p>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</p>
</li>
<li><p>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>
</li>
</ol>
<h2 id="2-1-值类型-引用类型"><a href="#2-1-值类型-引用类型" class="headerlink" title="2.1 值类型,引用类型.."></a>2.1 值类型,引用类型..</h2><h3 id="2-1-1-值类型-基本数据类型"><a href="#2-1-1-值类型-基本数据类型" class="headerlink" title="2.1.1 值类型(基本数据类型)"></a>2.1.1 值类型(基本数据类型)</h3><p>就是基本数据类型 基本数据类型常被称为四类八种</p>
<p>四类：<br> 1，整型 2，浮点型 3，字符型 4，逻辑型</p>
<p>八种：   </p>
<p>1，整型3种 byte，short，int，long</p>
<p>2，浮点型2种 float，double</p>
<p>3，字符型1种 char</p>
<p>4，逻辑型1种 boolean</p>
<p><code>tips:</code><br>Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值<strong>[-128,127]的缓存数据</strong>。</p>
<p><strong>当对这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。</strong></p>
<p>Float 和Double 没有实现常量池。</p>
<h3 id="2-1-2-引用类型-引用数据类型"><a href="#2-1-2-引用类型-引用数据类型" class="headerlink" title="2.1.2 引用类型(引用数据类型)"></a>2.1.2 引用类型(引用数据类型)</h3><p>四类八种基本类型外，所有的类型都称为引用类型（数组，类，接口，字符串）</p>
<h3 id="2-1-3-值传递"><a href="#2-1-3-值传递" class="headerlink" title="2.1.3 值传递"></a>2.1.3 值传递</h3><p>基本数据类型赋值都属于值传递,值传递传递的是实实在在的变量值,是传递原参数的拷贝,<br>值传递后，实参传递给形参的值，形参发生改变而不影响实参。 </p>
<p>对应的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferencePkValue2</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        ReferencePkValue2 t = <span class="keyword">new</span> ReferencePkValue2(); </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">99</span>; </span><br><span class="line">        t.test1(a);<span class="comment">//这里传递的参数a就是按值传递 </span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">         </span><br><span class="line">        MyObj obj=<span class="keyword">new</span> MyObj(); </span><br><span class="line">        t.test2(obj);<span class="comment">//这里传递的参数obj就是引用传递</span></span><br><span class="line">        System.out.println(obj.b);</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; </span><br><span class="line">        a=a++;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(MyObj obj)</span></span>&#123; </span><br><span class="line">        obj.b=<span class="number">100</span>;</span><br><span class="line">        System.out.println(obj.b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出是：</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p><code>tips:</code>String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。(<a href="https://www.cnblogs.com/jaylon/p/5721571.html" target="_blank" rel="noopener">JAVA不可变类(immutable)机制与String的不可变性</a>)</p>
<h3 id="2-1-4-引用传递"><a href="#2-1-4-引用传递" class="headerlink" title="2.1.4 引用传递"></a>2.1.4 引用传递</h3><p>引用类型之间赋值属于引用传递。引用传递传递的是对象的引用地址,也就是它的本身(自己最通俗的理解)。<br>引用传递：传的是地址，就是将实参的地址传递给形参，形参改变了，实参当然被改变了，因为他们指向相同的地址。<br>对应的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferencePkValue1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReferencePkValue1 pk=<span class="keyword">new</span> ReferencePkValue1();</span><br><span class="line">        <span class="comment">//String类似基本类型，值传递，不会改变实际参数的值</span></span><br><span class="line">        String test1=<span class="string">"Hello"</span>;</span><br><span class="line">        pk.change(test1);</span><br><span class="line">        System.out.println(test1);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//StringBuffer和StringBuilder等是引用传递</span></span><br><span class="line">        StringBuffer test2=<span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">        pk.change(test2);</span><br><span class="line">         </span><br><span class="line">        System.out.println(test2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        str=str+<span class="string">"world"</span>; <span class="comment">// 但是在这里 System.out.println(str);的话  结果就是 Helloworld</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer str)</span></span>&#123;</span><br><span class="line">        str.append(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出是：</span><br><span class="line">Hello        </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></p>
<h2 id="3-1-Java克隆对象的三种方式"><a href="#3-1-Java克隆对象的三种方式" class="headerlink" title="3.1 Java克隆对象的三种方式"></a>3.1 Java克隆对象的三种方式</h2><p>1 直接赋值<br>2 浅克隆（浅拷贝）<br>3 深克隆（深拷贝）</p>
<h3 id="3-1-1-浅克隆（浅拷贝）"><a href="#3-1-1-浅克隆（浅拷贝）" class="headerlink" title="3.1.1 浅克隆（浅拷贝）"></a>3.1.1 浅克隆（浅拷贝）</h3><p>定义：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝</p>
<h3 id="3-1-2-深克隆（深拷贝）"><a href="#3-1-2-深克隆（深拷贝）" class="headerlink" title="3.1.2 深克隆（深拷贝）"></a>3.1.2 深克隆（深拷贝）</h3><p>定义：对基本数据类型进行值传递，<strong>对引用数据类型，创建一个新的对象，并复制其内容</strong></p>
<p><code>tips:</code> 深克隆和浅克隆的区别由定义既可知，在引用数据类型是进行了引用的传递还是创建新的对象。</p>
<h3 id="3-1-3-工具类克隆对象"><a href="#3-1-3-工具类克隆对象" class="headerlink" title="3.1.3 工具类克隆对象"></a>3.1.3 工具类克隆对象</h3><h4 id="3-1-3-1-apache的BeanUtils-工具类"><a href="#3-1-3-1-apache的BeanUtils-工具类" class="headerlink" title="3.1.3.1 apache的BeanUtils 工具类"></a>3.1.3.1 apache的BeanUtils 工具类</h4><p>使用org.apache.commons.beanutils.BeanUtils进行对象深入复制时候，主要通过向BeanUtils框架注入新的类型转换器，因为默认情况下，BeanUtils对复杂对象的复制是引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beanUtilsTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 注册转化器</span></span><br><span class="line">    BeanUtilsBean.getInstance().getConvertUtils().register(<span class="keyword">new</span> ArbitrationConvert(), ArbitrationDO.class);</span><br><span class="line">    Wrapper wrapper = <span class="keyword">new</span> Wrapper();</span><br><span class="line">    wrapper.setName(<span class="string">"copy"</span>);</span><br><span class="line">    wrapper.setNameDesc(<span class="string">"copy complex object!"</span>);</span><br><span class="line">    wrapper.setArbitration(newArbitrationDO());</span><br><span class="line">    Wrapper dest = <span class="keyword">new</span> Wrapper();</span><br><span class="line">    <span class="comment">// 对象复制</span></span><br><span class="line">    BeanUtils.copyProperties(dest, wrapper);</span><br><span class="line">    <span class="comment">// 属性验证</span></span><br><span class="line">    wrapper.getArbitration().setBizId(<span class="string">"1"</span>);</span><br><span class="line">    System.out.println(wrapper.getArbitration() == dest.getArbitration());</span><br><span class="line">    System.out.println(wrapper.getArbitration().getBizId().equals(dest.getArbitration().getBizId()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArbitrationConvert</span> <span class="keyword">implements</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Class&lt;T&gt; type, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ArbitrationDO.class.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> type.cast(BeanUtils.cloneBean(value));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实验发现，使用org.apache.commons.beanutils.BeanUtils复制引用时，主和源的引用为同一个，即改变了主的引用属性会影响到源的引用，所以这是一种<strong>浅拷贝</strong>。</p>
<p><code>tips:</code>需要注意的是，apache的BeanUtils中，以下类型如果为空，会报错（org.apache.commons.beanutils.ConversionException: No value specified for…）</p>
<h4 id="3-1-3-2-apache的PropertyUtils-工具类"><a href="#3-1-3-2-apache的PropertyUtils-工具类" class="headerlink" title="3.1.3.2 apache的PropertyUtils 工具类"></a>3.1.3.2 apache的PropertyUtils 工具类</h4><p>PropertyUtils的copyProperties()方法几乎与BeanUtils.copyProperties()相同，主要的区别在于后者提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，<br>在支持的数据类型范围内进行转换，PropertyUtils不支持这个功能，它仍然属于<strong>浅拷贝</strong>。</p>
<p><code>tips:</code> Apache提供了 SerializationUtils.clone(T)，T对象需要实现 Serializable 接口，他属于<strong>深拷贝</strong>。</p>
<h4 id="3-1-3-3-spring的BeanUtils-工具类"><a href="#3-1-3-3-spring的BeanUtils-工具类" class="headerlink" title="3.1.3.3 spring的BeanUtils 工具类"></a>3.1.3.3 spring的BeanUtils 工具类</h4><p>Spring中的BeanUtils，其中实现的方式很简单，就是对两个对象中相同名字的属性进行简单get/set，仅检查属性的可访问性。<br>源码片段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        copyProperties(source, target, (Class)<span class="keyword">null</span>, (String[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, Class&lt;?&gt; editable)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        copyProperties(source, target, editable, (String[])<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        copyProperties(source, target, (Class)<span class="keyword">null</span>, ignoreProperties);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Assert.notNull(source, <span class="string">"Source must not be null"</span>);</span><br><span class="line">        Assert.notNull(target, <span class="string">"Target must not be null"</span>);</span><br><span class="line">        Class actualEditable = target.getClass();</span><br><span class="line">        <span class="keyword">if</span>(editable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!editable.isInstance(target)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target class ["</span> + target.getClass().getName() + <span class="string">"] not assignable to Editable class ["</span> + editable.getName() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            actualEditable = editable;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable);</span><br><span class="line">        List ignoreList = ignoreProperties != <span class="keyword">null</span>?Arrays.asList(ignoreProperties):<span class="keyword">null</span>;</span><br><span class="line">        PropertyDescriptor[] var7 = targetPds;</span><br><span class="line">        <span class="keyword">int</span> var8 = targetPds.length;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">            PropertyDescriptor targetPd = var7[var9];</span><br><span class="line">            Method writeMethod = targetPd.getWriteMethod();</span><br><span class="line">            <span class="keyword">if</span>(writeMethod != <span class="keyword">null</span> &amp;&amp; (ignoreList == <span class="keyword">null</span> || !ignoreList.contains(targetPd.getName()))) &#123;</span><br><span class="line">                PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName());</span><br><span class="line">                <span class="keyword">if</span>(sourcePd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Method readMethod = sourcePd.getReadMethod();</span><br><span class="line">                    <span class="keyword">if</span>(readMethod != <span class="keyword">null</span> &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[<span class="number">0</span>], readMethod.getReturnType())) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">                                readMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"> </span><br><span class="line">                            Object ex = readMethod.invoke(source, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">                            <span class="keyword">if</span>(!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123;</span><br><span class="line">                                writeMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"> </span><br><span class="line">                            writeMethod.invoke(target, <span class="keyword">new</span> Object[]&#123;ex&#125;);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Could not copy property \'"</span> + targetPd.getName() + <span class="string">"\' from source to target"</span>, var15);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>tips：</code> 成员变量赋值是基于目标对象的成员列表, 并且会跳过ignore的以及在源对象中不存在的, 所以这个方法是安全的, 不会因为两个对象之间的结构差异导致错误, 但是必须保证同名的两个成员变量类型相同。</p>
<h4 id="3-1-3-4-dozer-Dozer（http-dozer-sourceforge-net-）"><a href="#3-1-3-4-dozer-Dozer（http-dozer-sourceforge-net-）" class="headerlink" title="3.1.3.4 dozer [Dozer（http://dozer.sourceforge.net/）]"></a>3.1.3.4 dozer [Dozer（<a href="http://dozer.sourceforge.net/）]" target="_blank" rel="noopener">http://dozer.sourceforge.net/）]</a></h4><p>能够实现<strong>深拷贝</strong>。Dozer是基于反射来实现对象拷贝，反射调用set/get 或者是直接对成员变量赋值 。 该方式通过invoke执行赋值，实现时一般会采用beanutil, Javassist等开源库。</p>
<h4 id="3-1-3-5-MapStrcut"><a href="#3-1-3-5-MapStrcut" class="headerlink" title="3.1.3.5 MapStrcut"></a>3.1.3.5 MapStrcut</h4><p>MapStrcut属于编译期的对象复制方案，它能够动态生成set/get代码的class文件 ，在运行时直接调用该class文件。该方式实际上扔会存在set/get代码，只是不需要自己写了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MonitorAppGroupIdcDTOMapper</span> </span>&#123;</span><br><span class="line">    MonitorAppGroupIdcDTOMapper MAPPER = Mappers.getMapper(MonitorAppGroupIdcDTOMapper.class);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mapping</span><span class="params">(MonitorAppGroupIdcDTO source, @MappingTarget MonitorAppGroupIdcDTO dest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-3-6-BeanCopier"><a href="#3-1-3-6-BeanCopier" class="headerlink" title="3.1.3.6 BeanCopier"></a>3.1.3.6 BeanCopier</h4><p>基于CGlib实现Bean拷贝，可以通过缓存BeanCopier的实例来提高性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BeanCopier b = getFromCache(sourceClass,targetClass); <span class="comment">//从缓存中取</span></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">List&lt;ShopCouponModel&gt; modelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (ShopCouponEntity src : entityList) &#123;</span><br><span class="line">    ShopCouponModel dest = <span class="keyword">new</span> ShopCouponModel();</span><br><span class="line">    b.copy(src, dest, <span class="keyword">null</span>);</span><br><span class="line">    modelList.add(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-3-7-fastjson和GSON"><a href="#3-1-3-7-fastjson和GSON" class="headerlink" title="3.1.3.7 fastjson和GSON"></a>3.1.3.7 fastjson和GSON</h4><p>使用fastjson和GSON主要是通过对象json序列化和反序列化来完成对象复制，这里只是提供一种不一样的对象拷贝的思路</p>
<h4 id="3-1-3-8-序列化（深clone一中实现）"><a href="#3-1-3-8-序列化（深clone一中实现）" class="headerlink" title="3.1.3.8 序列化（深clone一中实现）"></a>3.1.3.8 序列化（深clone一中实现）</h4><p>在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">NewNovelMode des = <span class="keyword">null</span> ;</span><br><span class="line">NewNovelMode ori = buildModel();</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();     </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">//org.springframework.beans.BeanUtils.copyProperties</span></span><br><span class="line"><span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    des = <span class="keyword">new</span> NewNovelMode();</span><br><span class="line">    org.springframework.beans.BeanUtils.copyProperties(ori, des);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"springframework BeanUtils cost:"</span>+(System.currentTimeMillis() - s));</span><br><span class="line"><span class="comment">//      System.out.println(new Gson().toJson(des));</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//org.apache.commons.beanutils.BeanUtils</span></span><br><span class="line">s = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    des = <span class="keyword">new</span> NewNovelMode();</span><br><span class="line">    org.apache.commons.beanutils.BeanUtils.copyProperties(des, ori);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"apache BeanUtils cost:"</span>+(System.currentTimeMillis() - s));</span><br><span class="line"><span class="comment">//      System.out.println(new Gson().toJson(des));</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//gson转换</span></span><br><span class="line">s = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    des = gson.fromJson(gson.toJson(ori), NewNovelMode.class);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"gson cost:"</span>+(System.currentTimeMillis() - s));</span><br><span class="line"><span class="comment">//      System.out.println(new Gson().toJson(des));</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Pojo转换类</span></span><br><span class="line">s = System.currentTimeMillis();</span><br><span class="line">PojoUtils&lt;NewNovelMode, NewNovelMode&gt; pojoUtils = <span class="keyword">new</span> PojoUtils&lt;NewNovelMode, NewNovelMode&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    des = <span class="keyword">new</span> NewNovelMode();</span><br><span class="line">    pojoUtils.copyPojo(ori,des);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Pojoconvert cost:"</span>+(System.currentTimeMillis() - s));</span><br><span class="line"><span class="comment">//      System.out.println(new Gson().toJson(des));</span></span><br></pre></td></tr></table></figure>
<p>性能对比： BeanCopier &gt; BeanUtils. 其中BeanCopier的性能高出另外两个100数量级。 </p>
<ul>
<li>BeanUtils（简单，易用）</li>
<li>BeanCopier（加入缓存后和手工set的性能接近）</li>
<li>Dozer（深拷贝）</li>
<li>fastjson（特定场景下使用）</li>
</ul>
<h2 id="4-1-JAVA-集合"><a href="#4-1-JAVA-集合" class="headerlink" title="4.1 JAVA 集合"></a>4.1 JAVA 集合</h2><p>Java 集合类存放在 Java.util包中，主要有3中：Set（集），list(列表包括Queue)，Map(映射)</p>
<ul>
<li>Collection： Collection是集合List，Set，Queue的最基本的接口。</li>
<li>Iterator: 迭代器，可以通过迭代器遍历集合中的数据。</li>
<li>Map： 是映射表的最基础的接口。</li>
</ul>
<p>[<img src="https://s2.ax1x.com/2019/04/30/E8RVdf.md.png" alt="E8RVdf.md.png">]</p>
<p>[<img src="https://s2.ax1x.com/2019/04/30/E8Rh6A.md.png" alt="E8Rh6A.md.png">]</p>
<h3 id="4-1-1-List"><a href="#4-1-1-List" class="headerlink" title="4.1.1 List"></a>4.1.1 List</h3><p>Java的List是非常常用的数据类型。</p>
<p>List是有序的Collection。</p>
<p>Java List一共三个实现类：分别是<strong>ArrayList</strong>、<strong>Vector</strong>和<strong>LinkedList</strong>。<br>[<img src="https://s2.ax1x.com/2019/04/30/E8W6un.md.png" alt="E8Rh6A.md.png">]</p>
<h4 id="4-1-2-ArrayList（数组）"><a href="#4-1-2-ArrayList（数组）" class="headerlink" title="4.1.2 ArrayList（数组）"></a>4.1.2 ArrayList（数组）</h4><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。</p>
<p>数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。</p>
<p>当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p>
<p>因此，它适合随机查找和遍历，不适合插入和删除。</p>
<h4 id="4-1-3-Vector（数组实现、线程同步）"><a href="#4-1-3-Vector（数组实现、线程同步）" class="headerlink" title="4.1.3 Vector（数组实现、线程同步）"></a>4.1.3 Vector（数组实现、线程同步）</h4><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，</p>
<p>避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，</p>
<p>因此，访问它比访问ArrayList慢。</p>
<h4 id="4-1-4-LinkList（链表）"><a href="#4-1-4-LinkList（链表）" class="headerlink" title="4.1.4 LinkList（链表）"></a>4.1.4 LinkList（链表）</h4><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。</p>
<p>另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，</p>
<p>可以当作堆栈、队列和双向队列使用。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>List</td>
<td>1. 需要保留存储顺序，并保留重复数据，使用 List </td>
</tr>
<tr>
<td>  ‘’</td>
<td>2.查询较多，使用ArrayList </td>
</tr>
<tr>
<td>  ‘’</td>
<td>3.存储较多，使用LinkedList  </td>
</tr>
<tr>
<td>  ‘’</td>
<td>4.线程安全，使用Vector</td>
</tr>
</tbody>
</table>
<h3 id="4-1-2-Set"><a href="#4-1-2-Set" class="headerlink" title="4.1.2 Set"></a>4.1.2 Set</h3><p>Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，<strong>值不能重复</strong>。</p>
<p>对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，</p>
<p><strong>如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。</strong></p>
<p><img src="https://s2.ax1x.com/2019/04/30/E8OAIJ.png" alt="E8OAIJ.png"></p>
<h4 id="4-1-2-1-HashSet（Hash表）"><a href="#4-1-2-1-HashSet（Hash表）" class="headerlink" title="4.1.2.1 HashSet（Hash表）"></a>4.1.2.1 HashSet（Hash表）</h4><p>哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。</p>
<p>元素的哈希值是通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 </p>
<p>如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是同一个元素。</p>
<h4 id="4-1-2-2-TreeSet（二叉树）"><a href="#4-1-2-2-TreeSet（二叉树）" class="headerlink" title="4.1.2.2 TreeSet（二叉树）"></a>4.1.2.2 TreeSet（二叉树）</h4><ol>
<li><p>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p>
</li>
<li><p>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。 </p>
</li>
<li><p>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序 </p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
</li>
</ol>
<h4 id="4-1-2-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#4-1-2-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="4.1.2.3 LinkHashSet（HashSet+LinkedHashMap）"></a>4.1.2.3 LinkHashSet（HashSet+LinkedHashMap）</h4><p>对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。</p>
<p>LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同</p>
<p>因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，</p>
<p>在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。</p>
<h3 id="4-1-3-Map"><a href="#4-1-3-Map" class="headerlink" title="4.1.3 Map"></a>4.1.3 Map</h3><p><img src="https://s2.ax1x.com/2019/04/30/E8ORyV.png" alt="E8ORyV.png"></p>
<h4 id="4-1-3-1-HashMap（数组-链表-红黑树）"><a href="#4-1-3-1-HashMap（数组-链表-红黑树）" class="headerlink" title="4.1.3.1 HashMap（数组+链表+红黑树）"></a>4.1.3.1 HashMap（数组+链表+红黑树）</h4><p>HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。</p>
<p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。</p>
<p>如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p><img src="https://s2.ax1x.com/2019/04/30/E8OvwD.png" alt="E8OvwD.png"><br>HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。</p>
<p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p>
<ol>
<li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </p>
</li>
<li><p>loadFactor：负载因子，默认为 0.75。</p>
</li>
<li><p>threshold：扩容的阈值，等于 capacity * loadFactor</p>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/04/30/E8XF6P.png" alt="E8XF6P.png"><br>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 </p>
<p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，</p>
<p>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p>
<p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，</p>
<p>在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p>
<h4 id="4-1-3-2-HashTable（线程安全）"><a href="#4-1-3-2-HashTable（线程安全）" class="headerlink" title="4.1.3.2 HashTable（线程安全）"></a>4.1.3.2 HashTable（线程安全）</h4><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，</p>
<p>并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。</p>
<p>Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h4 id="4-1-3-3-TreeMap（可排序）"><a href="#4-1-3-3-TreeMap（可排序）" class="headerlink" title="4.1.3.3 TreeMap（可排序）"></a>4.1.3.3 TreeMap（可排序）</h4><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。 </p>
<p>如果使用排序的映射，建议使用TreeMap。 </p>
<p>在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<h4 id="4-1-3-4-LinkHashMap（记录插入顺序）"><a href="#4-1-3-4-LinkHashMap（记录插入顺序）" class="headerlink" title="4.1.3.4 LinkHashMap（记录插入顺序）"></a>4.1.3.4 LinkHashMap（记录插入顺序）</h4><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<h4 id="4-1-3-5-ConcurrentHashMap"><a href="#4-1-3-5-ConcurrentHashMap" class="headerlink" title="4.1.3.5 ConcurrentHashMap"></a>4.1.3.5 ConcurrentHashMap</h4><p><strong>Segment段</strong></p>
<p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，</p>
<p>Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。</p>
<p><strong>线程安全（Segment 继承 ReentrantLock 加锁）</strong></p>
<p>ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
<p><img src="https://s2.ax1x.com/2019/04/30/E8vSxI.png" alt="E8vSxI.png"><br>并行度（默认16） concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。</p>
<p>默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment上。</p>
<p>这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p>
<p><img src="https://s2.ax1x.com/2019/04/30/E8vsFe.png" alt="E8vsFe.png"><br>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</p>
<h2 id="5-1-Java-多线程并发"><a href="#5-1-Java-多线程并发" class="headerlink" title="5.1 Java 多线程并发"></a>5.1 Java 多线程并发</h2><h5 id="5-1-0-JAVA并发知识库图"><a href="#5-1-0-JAVA并发知识库图" class="headerlink" title="5.1.0 JAVA并发知识库图"></a>5.1.0 JAVA并发知识库图</h5><p><a href="https://imgchr.com/i/EG8jRe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/04/30/EG8jRe.png" alt="EG8jRe.png"></a></p>
<h3 id="5-1-1-JAVA线程实现-创建方式"><a href="#5-1-1-JAVA线程实现-创建方式" class="headerlink" title="5.1.1 JAVA线程实现/创建方式"></a>5.1.1 JAVA线程实现/创建方式</h3><h4 id="5-1-1-1-继承Thread类"><a href="#5-1-1-1-继承Thread类" class="headerlink" title="5.1.1.1 继承Thread类"></a>5.1.1.1 继承Thread类</h4><p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。</p>
<p>启动线程的唯一方法就是通过Thread类的start()实例方法。</p>
<p>start()方法是一个native方法，它将启动一个新线程，并执行run()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread(); </span><br><span class="line">    myThread1.start();</span><br></pre></td></tr></table></figure></p>
<h4 id="5-1-1-2-实现Runnable接口"><a href="#5-1-1-2-实现Runnable接口" class="headerlink" title="5.1.1.2 实现Runnable接口"></a>5.1.1.2 实现Runnable接口</h4><p>如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例： </span></span><br><span class="line"></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread(); </span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread); </span><br><span class="line">thread.start(); </span><br><span class="line"><span class="comment">//事实上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run() </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    target.run(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-1-3-ExecutorService、Callable、Future有返回值线程"><a href="#5-1-1-3-ExecutorService、Callable、Future有返回值线程" class="headerlink" title="5.1.1.3 ExecutorService、Callable、Future有返回值线程"></a>5.1.1.3 ExecutorService、Callable<class>、Future有返回值线程</class></h4><p>有返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。</p>
<p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(taskSize); </span><br><span class="line"><span class="comment">// 创建多个有返回值的任务 </span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123; </span><br><span class="line">Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>); </span><br><span class="line"><span class="comment">// 执行任务并获取Future对象 </span></span><br><span class="line">Future f = pool.submit(c); list.add(f); &#125; </span><br><span class="line"><span class="comment">// 关闭线程池 pool.shutdown(); </span></span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果 </span></span><br><span class="line"><span class="keyword">for</span> (Future f : list) &#123; </span><br><span class="line"><span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台 </span></span><br><span class="line">System.out.println(<span class="string">"res："</span> + f.get().toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-1-1-4-基于线程池的方式"><a href="#5-1-1-4-基于线程池的方式" class="headerlink" title="5.1.1.4 基于线程池的方式"></a>5.1.1.4 基于线程池的方式</h4><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池 </span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="comment">// 提交多个线程任务，并执行 </span></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is running .."</span>); </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-1-2-四种线程池"><a href="#5-1-2-四种线程池" class="headerlink" title="5.1.2 四种线程池"></a>5.1.2 四种线程池</h3><p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>
<p><img src="https://s2.ax1x.com/2019/04/30/EGYU56.png" alt="EGYU56.png"></p>
<h4 id="5-1-2-1-newCachedThreadPool"><a href="#5-1-2-1-newCachedThreadPool" class="headerlink" title="5.1.2.1 newCachedThreadPool"></a>5.1.2.1 newCachedThreadPool</h4><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。</p>
<p>调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。</p>
<p>终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源</p>
<h4 id="5-1-2-2-newFixedThreadPool"><a href="#5-1-2-2-newFixedThreadPool" class="headerlink" title="5.1.2.2 newFixedThreadPool"></a>5.1.2.2 newFixedThreadPool</h4><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。</p>
<p>如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，</p>
<p>那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p>
<p>工作代码实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三期拆相册</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryModel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countOrderNum2(String queryModel, <span class="keyword">int</span> userId) &#123;</span><br><span class="line">	<span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	Map&lt;String, Object&gt; map = getParamMap(queryModel, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       map.put(<span class="string">"userId"</span>, userId);</span><br><span class="line">       CompletableFuture&lt;Integer&gt; integerCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           HashMap&lt;String,Object&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           map2.putAll(map);</span><br><span class="line">           map2.put(<span class="string">"queryType"</span>, <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> orderMapper.countOrderNum2(map2);</span><br><span class="line">       &#125;, pool);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       ret[<span class="number">0</span>]=integerCompletableFuture.join();</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-1-2-3-newScheduledThreadPool"><a href="#5-1-2-3-newScheduledThreadPool" class="headerlink" title="5.1.2.3 newScheduledThreadPool"></a>5.1.2.3 newScheduledThreadPool</h4><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p>
<p>工作代码实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService SCHEDULE_POOL = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算云相册使用费和委拍服务费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recalculatePhotographerOrderFee</span><span class="params">(Long orderId, Long userId)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * xxx demo...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为事务的问题 需延迟重算摄影师人数 这段代码执行之后 事务需要在1s内提交完成 所以需要保证这段代码 是在事务的最后执行</span></span><br><span class="line">	SCHEDULE_POOL.schedule(() -&gt; &#123;</span><br><span class="line">		<span class="comment">// 重新计算摄影师人数</span></span><br><span class="line">		itOrderSourceNumService.recalculatePhotographerOrderSourceNum(orderId);</span><br><span class="line">	&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-1-2-4-newSingleThreadExecutor"><a href="#5-1-2-4-newSingleThreadExecutor" class="headerlink" title="5.1.2.4 newSingleThreadExecutor"></a>5.1.2.4 newSingleThreadExecutor</h4><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p>
<h3 id="5-1-3-线程生命周期"><a href="#5-1-3-线程生命周期" class="headerlink" title="5.1.3 线程生命周期"></a>5.1.3 线程生命周期</h3><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。</p>
<p>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。</p>
<p>尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。</p>
<h4 id="5-1-3-1-新建状态（NEW）"><a href="#5-1-3-1-新建状态（NEW）" class="headerlink" title="5.1.3.1 新建状态（NEW）"></a>5.1.3.1 新建状态（NEW）</h4><p>当代码中使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。</p>
<h4 id="5-1-3-2-就绪状态（RUNNABLE）"><a href="#5-1-3-2-就绪状态（RUNNABLE）" class="headerlink" title="5.1.3.2 就绪状态（RUNNABLE）"></a>5.1.3.2 就绪状态（RUNNABLE）</h4><p>当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
<h4 id="5-1-3-3-运行状态（RUNNING）"><a href="#5-1-3-3-运行状态（RUNNING）" class="headerlink" title="5.1.3.3 运行状态（RUNNING）"></a>5.1.3.3 运行状态（RUNNING）</h4><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。</p>
<h4 id="5-1-3-4-阻塞状态（BLOCKED）"><a href="#5-1-3-4-阻塞状态（BLOCKED）" class="headerlink" title="5.1.3.4 阻塞状态（BLOCKED）"></a>5.1.3.4 阻塞状态（BLOCKED）</h4><p>阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。</p>
<p>阻塞的情况分三种： </p>
<p>等待阻塞（o.wait-&gt;等待对列）：<br>运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 </p>
<p>同步阻塞(lock-&gt;锁池) 运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 </p>
<p>其他阻塞(sleep/join) 运行(running)的线程执行Thread.sleep(longms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。</p>
<p>当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<h4 id="5-1-3-5-线程死亡（DEAD）"><a href="#5-1-3-5-线程死亡（DEAD）" class="headerlink" title="5.1.3.5 线程死亡（DEAD）"></a>5.1.3.5 线程死亡（DEAD）</h4><p>线程会以下面三种方式结束，结束后就是死亡状态。 </p>
<p>正常结束 1. run()或call()方法执行完成，线程正常结束。 </p>
<p>异常结束 2. 线程抛出一个未捕获的Exception或Error。 </p>
<p>调用stop 3. 直接调用该线程的stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p>
<p><a href="https://imgchr.com/i/EyOhZT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/08/EyOhZT.png" alt="EyOhZT.png"></a></p>
<h3 id="5-1-4-终止线程4种方式"><a href="#5-1-4-终止线程4种方式" class="headerlink" title="5.1.4 终止线程4种方式"></a>5.1.4 终止线程4种方式</h3><ul>
<li><p>正常运行结束<br>程序运行结束，线程自动结束。 </p>
</li>
<li><p>使用退出标志退出线程<br>一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。</p>
</li>
</ul>
<p>使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出，</p>
<p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">while</span> (!exit)&#123; </span><br><span class="line">            <span class="comment">//do something </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Interrupt方法结束线程<br>使用interrupt()方法来中断线程有两种情况:<br>1.线程处于阻塞状态：如使用了sleep,同步锁的wait,socket中的receiver,accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。</li>
</ul>
<p>2.线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!isInterrupted())&#123; <span class="comment">//非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);<span class="comment">//阻塞过程捕获中断异常来退出</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行break跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>stop方法终止线程（线程不安全）<br>程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，</li>
</ul>
<p>不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。</p>
<p>一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，</p>
<p>其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。</p>
<h3 id="5-1-5-线程相关的两个问题"><a href="#5-1-5-线程相关的两个问题" class="headerlink" title="5.1.5 线程相关的两个问题"></a>5.1.5 线程相关的两个问题</h3><h4 id="5-1-5-1-sleep与wait-区别"><a href="#5-1-5-1-sleep与wait-区别" class="headerlink" title="5.1.5.1 sleep与wait 区别"></a>5.1.5.1 sleep与wait 区别</h4><ul>
<li>对于sleep()方法，该方法是属于Thread类。而wait()方法，则是属于Object类。</li>
<li>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态</li>
<li>在调用sleep()方法的过程中，线程不会释放对象锁。</li>
<li>而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li>
</ul>
<h4 id="5-1-5-2-start与run区别"><a href="#5-1-5-2-start与run区别" class="headerlink" title="5.1.5.2 start与run区别"></a>5.1.5.2 start与run区别</h4><ul>
<li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码。</li>
<li>通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</li>
<li>方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</li>
</ul>
<p><code>如有你觉得也是基础的未写出来的，可以给我留言哦！我会加上来的！</code></p>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
                <span class="reward-type">
                    <img class="alipay" src="/img/reward-alipay.png"><b>支付宝打赏</b>
                </span>
            
            
                <span class="reward-type">
                    <img class="wechat" src="/img/reward-wepay.png"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip"></p>
</div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处！
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/post/651c4ef8.html" class="pre-post btn btn-default" title="spring boot中的ApplicationRunner和CommandLineRunner">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">spring boot中的ApplicationRunner和CommandLineRunner</span>
        </a>
    
    
        <a href="/post/a182a993.html" class="next-post btn btn-default" title="基于SpringBoot1.5 + MyBatis + Thymeleaf 开发的个人博客源码分享">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">基于SpringBoot1.5 + MyBatis + Thymeleaf 开发的个人博客源码分享</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>

    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>

    <script>
        new Valine({           
            el: '#vcomments',
            appId: 'sbQDWnkLFsRjJS2BGzfKc4rL-gzGzoHsz',
            appKey: '5u9C0UUmzRe3unr9iLzheHjk',
            placeholder: '文明社会,理性评论留言 ^_^……',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#记录最基础-最容易忘记的笔记"><span class="toc-text">记录最基础 最容易忘记的笔记</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#一-JAVA基础"><span class="toc-text">一.JAVA基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-JAVA异常知识点"><span class="toc-text">1.1 JAVA异常知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-Error"><span class="toc-text">1.1.1 Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-Exception"><span class="toc-text">1.1.2 Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-1-RuntimeException"><span class="toc-text">1.1.2.1 RuntimeException</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-2-CheckedException"><span class="toc-text">1.1.2.2 CheckedException</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-异常的处理方式"><span class="toc-text">1.1.3 异常的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-Throw和throws的区别"><span class="toc-text">1.1.4 Throw和throws的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-值类型-引用类型"><span class="toc-text">2.1 值类型,引用类型..</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-值类型-基本数据类型"><span class="toc-text">2.1.1 值类型(基本数据类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-引用类型-引用数据类型"><span class="toc-text">2.1.2 引用类型(引用数据类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-值传递"><span class="toc-text">2.1.3 值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-引用传递"><span class="toc-text">2.1.4 引用传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Java克隆对象的三种方式"><span class="toc-text">3.1 Java克隆对象的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-浅克隆（浅拷贝）"><span class="toc-text">3.1.1 浅克隆（浅拷贝）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-深克隆（深拷贝）"><span class="toc-text">3.1.2 深克隆（深拷贝）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-工具类克隆对象"><span class="toc-text">3.1.3 工具类克隆对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-apache的BeanUtils-工具类"><span class="toc-text">3.1.3.1 apache的BeanUtils 工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-apache的PropertyUtils-工具类"><span class="toc-text">3.1.3.2 apache的PropertyUtils 工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-3-spring的BeanUtils-工具类"><span class="toc-text">3.1.3.3 spring的BeanUtils 工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-4-dozer-Dozer（http-dozer-sourceforge-net-）"><span class="toc-text">3.1.3.4 dozer [Dozer（http://dozer.sourceforge.net/）]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-5-MapStrcut"><span class="toc-text">3.1.3.5 MapStrcut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-6-BeanCopier"><span class="toc-text">3.1.3.6 BeanCopier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-7-fastjson和GSON"><span class="toc-text">3.1.3.7 fastjson和GSON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-8-序列化（深clone一中实现）"><span class="toc-text">3.1.3.8 序列化（深clone一中实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能测试"><span class="toc-text">性能测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-JAVA-集合"><span class="toc-text">4.1 JAVA 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-List"><span class="toc-text">4.1.1 List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-ArrayList（数组）"><span class="toc-text">4.1.2 ArrayList（数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-Vector（数组实现、线程同步）"><span class="toc-text">4.1.3 Vector（数组实现、线程同步）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-LinkList（链表）"><span class="toc-text">4.1.4 LinkList（链表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Set"><span class="toc-text">4.1.2 Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-1-HashSet（Hash表）"><span class="toc-text">4.1.2.1 HashSet（Hash表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-2-TreeSet（二叉树）"><span class="toc-text">4.1.2.2 TreeSet（二叉树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-3-LinkHashSet（HashSet-LinkedHashMap）"><span class="toc-text">4.1.2.3 LinkHashSet（HashSet+LinkedHashMap）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-Map"><span class="toc-text">4.1.3 Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-1-HashMap（数组-链表-红黑树）"><span class="toc-text">4.1.3.1 HashMap（数组+链表+红黑树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-2-HashTable（线程安全）"><span class="toc-text">4.1.3.2 HashTable（线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-3-TreeMap（可排序）"><span class="toc-text">4.1.3.3 TreeMap（可排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-4-LinkHashMap（记录插入顺序）"><span class="toc-text">4.1.3.4 LinkHashMap（记录插入顺序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-5-ConcurrentHashMap"><span class="toc-text">4.1.3.5 ConcurrentHashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Java-多线程并发"><span class="toc-text">5.1 Java 多线程并发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-0-JAVA并发知识库图"><span class="toc-text">5.1.0 JAVA并发知识库图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-JAVA线程实现-创建方式"><span class="toc-text">5.1.1 JAVA线程实现/创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-1-继承Thread类"><span class="toc-text">5.1.1.1 继承Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-2-实现Runnable接口"><span class="toc-text">5.1.1.2 实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-3-ExecutorService、Callable、Future有返回值线程"><span class="toc-text">5.1.1.3 ExecutorService、Callable、Future有返回值线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-4-基于线程池的方式"><span class="toc-text">5.1.1.4 基于线程池的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-四种线程池"><span class="toc-text">5.1.2 四种线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-1-newCachedThreadPool"><span class="toc-text">5.1.2.1 newCachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-2-newFixedThreadPool"><span class="toc-text">5.1.2.2 newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-3-newScheduledThreadPool"><span class="toc-text">5.1.2.3 newScheduledThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-4-newSingleThreadExecutor"><span class="toc-text">5.1.2.4 newSingleThreadExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-线程生命周期"><span class="toc-text">5.1.3 线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-1-新建状态（NEW）"><span class="toc-text">5.1.3.1 新建状态（NEW）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-2-就绪状态（RUNNABLE）"><span class="toc-text">5.1.3.2 就绪状态（RUNNABLE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-3-运行状态（RUNNING）"><span class="toc-text">5.1.3.3 运行状态（RUNNING）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-4-阻塞状态（BLOCKED）"><span class="toc-text">5.1.3.4 阻塞状态（BLOCKED）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-5-线程死亡（DEAD）"><span class="toc-text">5.1.3.5 线程死亡（DEAD）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-终止线程4种方式"><span class="toc-text">5.1.4 终止线程4种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-线程相关的两个问题"><span class="toc-text">5.1.5 线程相关的两个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5-1-sleep与wait-区别"><span class="toc-text">5.1.5.1 sleep与wait 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5-2-start与run区别"><span class="toc-text">5.1.5.2 start与run区别</span></a></li></ol>
        
    </li></div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2018 - 2021
                </span> | .<font color="#f1607d">伊</font><font color="#ffa500">成</font><font color="#e5e802">个</font><font color="#3bff23">人</font><font color="#ffa503">站</font><font color="#29c8ec"> devcheng</font><font color="#4f9cfa">.net</font>. |
                <span>
                    网站基于Hexo搭建
                </span> |
                <span>
                     <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">本站地图</a>
                </span> |
				<span>
					 <a href="/atom.xml" class="copyright-links" target="_blank" rel="nofollow">RSS订阅</a> 
				</span> |
				<span>
                    <a href="https://beian.miit.gov.cn/" class="copyright-links" target="_blank" rel="nofollow">湘ICP备20010839号</a> 
                </span>
				<span>
                    <a href="https://beian.miit.gov.cn/" class="copyright-links" target="_blank" rel="nofollow">湘ICP备20010839号-1</a> 
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>