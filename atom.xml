<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2021-07-07T14:34:49.053Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序使用async提示regeneratorRuntime is not defined异常</title>
    <link href="http://www.devcheng.net/post/12b3c63e.html"/>
    <id>http://www.devcheng.net/post/12b3c63e.html</id>
    <published>2021-07-07T14:31:14.000Z</published>
    <updated>2021-07-07T14:34:49.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>微信小程序使用async提示regeneratorRuntime is not defined异常。</p><p><img src="/images/wxmini1.png" alt="“伊成博客”"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>新版本的小程序支持async / await。勾选下面选项后重新编译程序即可</p><p>点击 ‘详情’ – ‘本地设置’ – 勾选 ‘ES6转ES5’ 和 ‘增强编译’，然后重新编译即可。</p><p><img src="/images/wxmini2.png" alt="“伊成博客”"></p><p>完美解决问题！</p><p>更新时间：2021-7-7</p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;微信小程序使用async提示regeneratorRuntime is not defined异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="微信小程序" scheme="http://www.devcheng.net/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="regeneratorRuntime is not defined" scheme="http://www.devcheng.net/tags/regeneratorRuntime-is-not-defined/"/>
    
  </entry>
  
  <entry>
    <title>springBoot启动提示If you want an embedded database (H2, HSQL or Derby), please put</title>
    <link href="http://www.devcheng.net/post/7dd074b3.html"/>
    <id>http://www.devcheng.net/post/7dd074b3.html</id>
    <published>2021-05-26T11:47:56.000Z</published>
    <updated>2021-05-26T12:01:44.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), please put it on the classpath</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于这个异常的解决方案，网上绝大部分都是说：在启动的类中的@SpringBootApplication 改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)//排除自动配置</span><br><span class="line">public class ErukaServerMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ErukaServerMain.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样改没有解决实际的问题。</p><p>产生这个错误的原因是Spring Boot的自动配置，如果你没有配置DataSource就会导致下图这个错误。</p><p>那如果你很确定，比如你就是要Spring Boot + Mybatis + MySQL 整合的代码，此时就应该去检查你的配置文件中是否正确配置了数据库连接。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>下面我们举个栗子复现这个问题，这里我使用Spring Boot + JPA + MySQL整合一个demo。</p><p>在数据库链接配置文件中，我们故意写错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.mysql.jdbc-url=jdbc:mysql://127.0.0.1:3306/beauty_atlas_server?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true</span><br><span class="line">spring.datasource.mysql.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.mysql.username=root</span><br><span class="line">spring.datasource.mysql.password=root</span><br></pre></td></tr></table></figure></p><p>tips: Spring Boot + JPA 配置连接数据库 可不是用 spring.datasource.mysql.jdbc-url 这个哦，以上的这块配置都是错的，这个时候你启动就会提示</p><p><img src="/images/devcheng_net_zhengheyichang.png" alt="“论坛内容管理系统”"></p><p>那正确的解决方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 数据库配置 spring boot + jpa 数据库配置前缀是下面这样的</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/beauty_atlas_server?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure><p>由上可见，Spirng Boot 和不同的持久层整合这些配置都是有所区别的，在整合的过程中一定要慎重。<br>Spring Boot + JPA + MySQL 整合中还得配置DataSource，把它注入到Spring中接口，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix=&quot;spring.datasource&quot;)</span><br><span class="line">public class DbConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource getDataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新启动，项目无问题了。</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;p&gt;Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), 
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="异常" scheme="http://www.devcheng.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="SpringBoot" scheme="http://www.devcheng.net/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL关键字大全</title>
    <link href="http://www.devcheng.net/post/7024f457.html"/>
    <id>http://www.devcheng.net/post/7024f457.html</id>
    <published>2021-05-25T12:29:23.000Z</published>
    <updated>2021-05-25T12:45:48.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在创建表的时候一定使用到MYSQL的关键字，前几天我同事在对接别人的接口中就遇到了这个问题，别人的接口中返回了一个 ‘desc’,他毫不犹豫地创建表的时候也用了’desc’。</p><p>结果死活保存不了这条数据。后面排查代码才发现使用了MYSQL的关键子了。</p><p>以下都是整理出来所有的MySQL关键字，为了避免踩坑，建议收藏！！！</p><h2 id="MySQL关键字"><a href="#MySQL关键字" class="headerlink" title="MySQL关键字"></a>MySQL关键字</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>ADD</td><td>ALL</td><td>ALTER</td></tr><tr><td>ANALYZE</td><td>AND</td><td>AS</td></tr><tr><td>ASC</td><td>ASENSITIVE</td><td>BEFORE</td></tr><tr><td>BETWEEN</td><td>BIGINT</td><td>BINARY</td></tr><tr><td>BLOB</td><td>BOTH</td><td>BY</td></tr><tr><td>CALL</td><td>CASCADE</td><td>CASE</td></tr><tr><td>CHANGE</td><td>CHAR</td><td>CHARACTER</td></tr><tr><td>CHECK</td><td>COLLATE</td><td>COLUMN</td></tr><tr><td>CONDITION</td><td>CONNECTION</td><td>CONSTRAINT</td></tr><tr><td>CONTINUE</td><td>CONVERT</td><td>CREATE</td></tr><tr><td>CROSS</td><td>CURRENT_DATE</td><td>CURRENT_TIME</td></tr><tr><td>CURRENT_TIMESTAMP</td><td>CURRENT_USER</td><td>CURSOR</td></tr><tr><td>DATABASE</td><td>DATABASES</td><td>DAY_HOUR</td></tr><tr><td>DAY_MICROSECOND</td><td>DAY_MINUTE</td><td>DAY_SECOND</td></tr><tr><td>DEC</td><td>DECIMAL</td><td>DECLARE</td></tr><tr><td>DEFAULT</td><td>DELAYED</td><td>DELETE</td></tr><tr><td>DESC</td><td>DESCRIBE</td><td>DETERMINISTIC</td></tr><tr><td>DISTINCT</td><td>DISTINCTROW</td><td>DIV</td></tr><tr><td>DOUBLE</td><td>DROP</td><td>DUAL</td></tr><tr><td>EACH</td><td>ELSE</td><td>ELSEIF</td></tr><tr><td>ENCLOSED</td><td>ESCAPED</td><td>EXISTS</td></tr><tr><td>EXIT</td><td>EXPLAIN</td><td>FALSE</td></tr><tr><td>FETCH</td><td>FLOAT</td><td>FLOAT4</td></tr><tr><td>FLOAT8</td><td>FOR</td><td>FORCE</td></tr><tr><td>FOREIGN</td><td>FROM</td><td>FULLTEXT</td></tr><tr><td>GOTO</td><td>GRANT</td><td>GROUP</td></tr><tr><td>HAVING</td><td>HIGH_PRIORITY</td><td>HOUR_MICROSECOND</td></tr><tr><td>HOUR_MINUTE</td><td>HOUR_SECOND</td><td>IF</td></tr><tr><td>IGNORE</td><td>IN</td><td>INDEX</td></tr><tr><td>INFILE</td><td>INNER</td><td>INOUT</td></tr><tr><td>INSENSITIVE</td><td>INSERT</td><td>INT</td></tr><tr><td>INT1</td><td>INT2</td><td>INT3</td></tr><tr><td>INT4</td><td>INT8</td><td>INTEGER</td></tr><tr><td>INTERVAL</td><td>INTO</td><td>IS</td></tr><tr><td>ITERATE</td><td>JOIN</td><td>KEY</td></tr><tr><td>KEYS</td><td>KILL</td><td>LABEL</td></tr><tr><td>LEADING</td><td>LEAVE</td><td>LEFT</td></tr><tr><td>LIKE</td><td>LIMIT</td><td>LINEAR</td></tr><tr><td>LINES</td><td>LOAD</td><td>LOCALTIME</td></tr><tr><td>LOCALTIMESTAMP</td><td>LOCK</td><td>LONG</td></tr><tr><td>LONGBLOB</td><td>LONGTEXT</td><td>LOOP</td></tr><tr><td>LOW_PRIORITY</td><td>MATCH</td><td>MEDIUMBLOB</td></tr><tr><td>MEDIUMINT</td><td>MEDIUMTEXT</td><td>MIDDLEINT</td></tr><tr><td>MINUTE_MICROSECOND</td><td>MINUTE_SECOND</td><td>MOD</td></tr><tr><td>MODIFIES</td><td>NATURAL</td><td>NOT</td></tr><tr><td>NO_WRITE_TO_BINLOG</td><td>NULL</td><td>NUMERIC</td></tr><tr><td>ON</td><td>OPTIMIZE</td><td>OPTION</td></tr><tr><td>OPTIONALLY</td><td>OR</td><td>ORDER</td></tr><tr><td>OUT</td><td>OUTER</td><td>OUTFILE</td></tr><tr><td>PRECISION</td><td>PRIMARY</td><td>PROCEDURE</td></tr><tr><td>PURGE</td><td>RAID0</td><td>RANGE</td></tr><tr><td>READ</td><td>READS</td><td>REAL</td></tr><tr><td>REFERENCES</td><td>REGEXP</td><td>RELEASE</td></tr><tr><td>RENAME</td><td>REPEAT</td><td>REPLACE</td></tr><tr><td>REQUIRE</td><td>RESTRICT</td><td>RETURN</td></tr><tr><td>REVOKE</td><td>RIGHT</td><td>RLIKE</td></tr><tr><td>SCHEMA</td><td>SCHEMAS</td><td>SECOND_MICROSECOND</td></tr><tr><td>SELECT</td><td>SENSITIVE</td><td>SEPARATOR</td></tr><tr><td>SET</td><td>SHOW</td><td>SMALLINT</td></tr><tr><td>SPATIAL</td><td>SPECIFIC</td><td>SQL</td></tr><tr><td>SQLEXCEPTION</td><td>SQLSTATE</td><td>SQLWARNING</td></tr><tr><td>SQL_BIG_RESULT</td><td>SQL_CALC_FOUND_ROWS</td><td>SQL_SMALL_RESULT</td></tr><tr><td>SSL</td><td>STARTING</td><td>STRAIGHT_JOIN</td></tr><tr><td>TABLE</td><td>TERMINATED</td><td>THEN</td></tr><tr><td>TINYBLOB</td><td>TINYINT</td><td>TINYTEXT</td></tr><tr><td>TO</td><td>TRAILING</td><td>TRIGGER</td></tr><tr><td>TRUE</td><td>UNDO</td><td>UNION</td></tr><tr><td>UNIQUE</td><td>UNLOCK</td><td>UNSIGNED</td></tr><tr><td>UPDATE</td><td>USAGE</td><td>USE</td></tr><tr><td>USING</td><td>UTC_DATE</td><td>UTC_TIME</td></tr><tr><td>UTC_TIMESTAMP</td><td>VALUES</td><td>VARBINARY</td></tr><tr><td>VARCHAR</td><td>VARCHARACTER</td><td>VARYING</td></tr><tr><td>WHEN</td><td>WHERE</td><td>WHILE</td></tr><tr><td>WITH</td><td>WRITE</td><td>X509</td></tr><tr><td>XOR</td><td>YEAR_MONTH</td><td>ZEROFILL</td></tr></tbody></table><hr><p>记录一下备忘~</p><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在创建表的时候一定使用到MYSQL的关键字，前几天我同事在对接别人的接口中就遇到了这个问题，别人的接口中返回了一个 ‘des
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="mysql关键字" scheme="http://www.devcheng.net/tags/mysql%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="mysql" scheme="http://www.devcheng.net/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>启动nginx提示Job for nginx.service failed because the control process exited with error code</title>
    <link href="http://www.devcheng.net/post/ceba3d83.html"/>
    <id>http://www.devcheng.net/post/ceba3d83.html</id>
    <published>2021-04-20T12:51:40.000Z</published>
    <updated>2021-04-20T13:03:55.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>启动nginx的时候，提示异常信息如下：</p><p>Job for nginx.service failed because the control process exited with error code.</p><p><img src="/images/devcheng_net_nginx0001.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_nginx0002.png" alt="“伊成博客”"></p><p>查看状态信息,提示配置文件出错: </p><p>“server” directive is not allowed here in /etc/nginx/nginx.conf:39</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>发现端口被占用，centos中查看端口被占用命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 端口号</span><br></pre></td></tr></table></figure><p>杀掉进程： <strong>ps -9 进程号</strong></p><p>杀掉所有80端口的进程：<strong>lsof -i :80|grep -v “PID”|awk ‘{print “kill -9”,$2}’|sh</strong></p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;启动nginx的时候，提示异常信息如下：&lt;/p&gt;
&lt;p&gt;Job for nginx.service failed becau
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="nginx" scheme="http://www.devcheng.net/tags/nginx/"/>
    
      <category term="nginx.service failed" scheme="http://www.devcheng.net/tags/nginx-service-failed/"/>
    
  </entry>
  
  <entry>
    <title>离职的时候不能说的十句话</title>
    <link href="http://www.devcheng.net/post/462294b4.html"/>
    <id>http://www.devcheng.net/post/462294b4.html</id>
    <published>2021-04-12T13:36:46.000Z</published>
    <updated>2021-04-12T13:44:49.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又是一年一季的跳槽季，也不知道此刻的你是不是正打算离职了，如果打算离职那你应该好好看看这篇文章。</p><h2 id="10点不能说的"><a href="#10点不能说的" class="headerlink" title="10点不能说的"></a>10点不能说的</h2><h3 id="1：老板很挫"><a href="#1：老板很挫" class="headerlink" title="1：老板很挫"></a>1：老板很挫</h3><p>任何将你的离职与老板的性格或性情联系起来的评论都是无济于事的。<br>他们可能是个食人魔，但如果传回你这么说的消息，他们在与未来的雇主交谈时，更有可能贬低你的态度或表现。</p><h3 id="2：上级领导很挫"><a href="#2：上级领导很挫" class="headerlink" title="2：上级领导很挫"></a>2：上级领导很挫</h3><p>不要说你要离开是因为你的老板不称职，即使这是真的。你的经理会更容易将任何失败归咎于你，并对你的工作做出负面评价。</p><h3 id="3：你在的团队成员有问题"><a href="#3：你在的团队成员有问题" class="headerlink" title="3：你在的团队成员有问题"></a>3：你在的团队成员有问题</h3><p>不要把团队成员的表现或不良态度作为你离职的理由。雇主在调查你的背景时，往往会征求员工以及主管的意见。如果以前的下属或同事因为你的离职言论而受到侮辱，那么他们会更容易提到你作为经理或队友的缺点。</p><h3 id="4：你的能力应该拿更多的收入"><a href="#4：你的能力应该拿更多的收入" class="headerlink" title="4：你的能力应该拿更多的收入"></a>4：你的能力应该拿更多的收入</h3><p>没有必要鼓励管理层将你视为不满的员工，因为这种定性可能会传递给其他询问你在组织的任期的人。</p><h3 id="5：公司的状况很糟糕"><a href="#5：公司的状况很糟糕" class="headerlink" title="5：公司的状况很糟糕"></a>5：公司的状况很糟糕</h3><p>如果你认为公司在某些方面陷入困境或成绩不佳，不要说出来。你的雇主会知道他们组织内部的任何问题。你向管理层传达他们被困在一个糟糕的组织中，而你却在向更好的事情发展，这对你没有任何好处。</p><h3 id="6：公司的产品很糟糕"><a href="#6：公司的产品很糟糕" class="headerlink" title="6：公司的产品很糟糕"></a>6：公司的产品很糟糕</h3><p>不忠诚的员工通常是不受欢迎的。前主管更可能会断言，你成功的任何限制都是由于你的不足，而不是他们产品或服务的缺陷。未来的雇主会怀疑，当你继续前进时，你是否会说他们的坏话。</p><h3 id="7：你没有被给到足够的通知"><a href="#7：你没有被给到足够的通知" class="headerlink" title="7：你没有被给到足够的通知"></a>7：你没有被给到足够的通知</h3><p>突然离职可以用来证明你不是一个敬业或专业的员工的指控。在某些情况下，可以不经通知就辞职，但在大多数情况下，通常是提前两周通知。</p><h3 id="8：你不愿意顺利的交接工作"><a href="#8：你不愿意顺利的交接工作" class="headerlink" title="8：你不愿意顺利的交接工作"></a>8：你不愿意顺利的交接工作</h3><p>这是一个很好的主意，证明你是一个有责任感的员工，直到你的工作结束。为老板缓解过渡期的合作会被记住，并经常得到积极的推荐奖励。</p><h3 id="9：新的工作机会实在是太6了"><a href="#9：新的工作机会实在是太6了" class="headerlink" title="9：新的工作机会实在是太6了"></a>9：新的工作机会实在是太6了</h3><p>不要向其他员工吹嘘你的新工作，因为这可能会引起他们的不满，特别是如果你暗示你比他们更好。感谢他人的支持，并提及你将如何想念与他们一起工作。</p><h3 id="10：你对前公司有意见，而且还要写在邮件里"><a href="#10：你对前公司有意见，而且还要写在邮件里" class="headerlink" title="10：你对前公司有意见，而且还要写在邮件里"></a>10：你对前公司有意见，而且还要写在邮件里</h3><p>不要把任何负面的东西写进去。保持你的辞职信是积极的，这样所有相关人员都会记住你是一个积极的人。学习如何写一封礼貌地说明你要离开的辞职信。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>保持积极的态度。<br>现在不是贬低你的老板，队友，或者即将到来的前雇主的时候。</p><p>以正确的方式辞职。<br>提供至少两周的书面通知 并感谢公司提供的机会。</p><p>从长计议。<br>记住，大多数行业都比他们看起来要小。当你离开时要专业一点，以后你就可以要求推荐人推荐你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;又是一年一季的跳槽季，也不知道此刻的你是不是正打算离职了，如果打算离职那你应该好好看看这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1
      
    
    </summary>
    
      <category term="codelife" scheme="http://www.devcheng.net/categories/codelife/"/>
    
    
      <category term="职场" scheme="http://www.devcheng.net/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="离职" scheme="http://www.devcheng.net/tags/%E7%A6%BB%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？</title>
    <link href="http://www.devcheng.net/post/d7b63f4f.html"/>
    <id>http://www.devcheng.net/post/d7b63f4f.html</id>
    <published>2021-04-10T01:43:25.000Z</published>
    <updated>2021-04-10T01:52:41.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你在工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>后台有个老铁就跟我说了这么一件事。</p><p>他是产品经理，上周刚加班搞定一个老板很重视的需求，熬了几个夜终于上线了。</p><p>这周陆续收到用户反馈，说其中一个功能的历史数据没有了，各种投诉就直接过来了。</p><p>在后台一查，原来是新版本完全覆盖了老版本的数据，没有做数据上新老版本兼容，导致更新了新版本的用户看不到之前的老数据。且后台上线后，老版本的用户也看不到之前的数据了。</p><p>这个问题最先被反馈到产品经理这，产品去问测试，测试说已经都测过没问题才发包的。产品去问研发，研发说新版代码里已经做了数据兼容的调整。</p><p>没办法，让研发老大带着下面的人去检查线上代码，发现提交上去的代码中果然没有完成数据兼容。可去发布前的测试代码中一看，这部分代码却存在。</p><p>原来，最后提交代码的程序员没有把这部分代码合并到主分支里面去。</p><p>因为表现层的功能测试都没问题了，且数据代码也写好了，所有人都以为万事俱备，没想到被一个代码提交给搞砸了。</p><p>幸亏数据有备份，经过恢复处理后这才回归了正常。</p><p>原本大家等着靠这个项目拿个季度奖，没想到被队友给坑了，而且是一个本该完全避免的失误。</p><p>所以，产品测试完没问题真不是最后一步。在有条件的团队，一定要做灰度上线，把出问题的概率控制在最低。</p><p>据我了解，微信团队每次更新产品都是逐步灰度放量，一旦遇到问题就立马回滚，非常灵活。</p><p>这些都属于产品技术的基本功，在快速跑需求的同时，也得时刻降低技术负债，多给自己留一些后路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;如果你在工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot;
      
    
    </summary>
    
      <category term="codelife" scheme="http://www.devcheng.net/categories/codelife/"/>
    
    
      <category term="职场" scheme="http://www.devcheng.net/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="猪队友" scheme="http://www.devcheng.net/tags/%E7%8C%AA%E9%98%9F%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列 03</title>
    <link href="http://www.devcheng.net/post/bb6a7fde.html"/>
    <id>http://www.devcheng.net/post/bb6a7fde.html</id>
    <published>2021-03-15T13:33:32.000Z</published>
    <updated>2021-03-16T12:52:46.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>结合前面两篇博文，这篇博文进行一次实战案例，用于介绍如何使用Ckettle做数据集成。</p><p><strong>实战需求</strong>：<br>某公司新人试用期为3个月，现在需要对职称为P3的为转正的员工实施转正考核，需要从现有的一张员工信息表格中提取并筛选未转正的员工数据，然后转存到考核系统的数据库中，每个月的1号执行一次。</p><p><strong>技术需求</strong></p><ul><li>源数据：Excel   目标数据：MySql</li></ul><p><img src="/images/ETL_20210315093800.png" alt="“伊成博客”"></p><p><strong>业务分析</strong></p><ul><li>试用期：3个月    职称：P3    转正状态:未转正</li></ul><p><strong>技术概要分析</strong></p><p>识别源和目标数据库，数据存储表</p><p><strong>操作概要分析</strong></p><ul><li>数据处理类型：定时调用</li><li>调度频率：每个一次</li></ul><p><img src="/images/ETL_20210315101321.png" alt="“伊成博客”"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><strong>操作步骤</strong></h2><h3 id="数据抽取"><a href="#数据抽取" class="headerlink" title="数据抽取"></a><strong>数据抽取</strong></h3><p>1.找到CKettle安装完成目录中的 ‘Spoon.bat’ 双击打开即可。</p><p>2.点击 ‘新建’，选择 ‘转换’ 选项。</p><p><img src="/images/ETL_20210315101939.png" alt="“伊成博客”"></p><p>3.点击 ‘输入’插件中，拖拽 ‘Excel输入’ 插件到右边。</p><p><img src="/images/ETL_20210315102217.png" alt="“伊成博客”"></p><p>4.选择存于你本地的excel文件，点击 ‘添加’按钮。</p><p><img src="/images/ETL_20210315102608.png" alt="“伊成博客”"></p><p>5.切换到 ‘工作表’选项，点击 ‘获选工作表名称’选择数据对应的sheet，完成后点击确定按钮。</p><p><img src="/images/ETL_20210315103026.png" alt="“伊成博客”"></p><p>6.继续切换到 ‘字段’选项，点击 ‘选择来自头部数据的字段’，如无需修改各个字段的类型点击确定按钮。</p><p><img src="/images/ETL_20210315103130.png" alt="“伊成博客”"></p><p>tips:到此第一步的数据抽取的工作就完成了。</p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a><strong>数据转换</strong></h3><p>1.接着需要筛选出职称为P3的员工，需要’过滤记录’插件。</p><p><img src="/images/ETL_20210315103509.png" alt="“伊成博客”"></p><p>2.按住shift键把两个插件用数据线连接在一块，然后进行数据过来的配置。</p><p><img src="/images/ETL_20210315103725.png" alt="“伊成博客”"></p><p>3.接着筛选出未转正的数据，在步骤2中同理操作一次即可。</p><p><img src="/images/ETL_20210315104250.png" alt="“伊成博客”"></p><p>tips：做好以上的步骤，我们可以试着点击’运行’按钮，查看一下流程是否有问题，如果配置都没问题的情况下我们可以查看到数据过滤后的结果。</p><p><img src="/images/ETL_20210315111418.png" alt="“伊成博客”"></p><p>4.添加一个常量用于比较出是否已经满了入职三个月的需求，这里需要一个 ‘增加常量’插件。</p><p><img src="/images/ETL_20210315204407.png" alt="“伊成博客”"></p><p>5.添加一个’计算器’ 插件，把入职时间加上刚刚设置的常量得到一个应该转正日期。</p><p><img src="/images/ETL_20210315204920.png" alt="“伊成博客”"></p><p>6.添加一个 ‘获取系统信息’ 插件，选择系统时间固定值。</p><p><img src="/images/ETL_20210315205318.png" alt="“伊成博客”"></p><p>7.由以上步骤，可以用当前时间和应该转正日期做比较从而筛选出符合条件的数据。</p><p><img src="/images/ETL_20210315205627.png" alt="“伊成博客”"></p><p>做到这一步，点击运行查看一下被筛选后的数据。</p><p><img src="/images/ETL_20210315205917.png" alt="“伊成博客”"></p><p>8.由上一步得知有重复数据，需要借助 ‘去除重复记录’ 插件。</p><p><img src="/images/ETL_20210315210420.png" alt="“伊成博客”"></p><h3 id="数据转载"><a href="#数据转载" class="headerlink" title="数据转载"></a><strong>数据转载</strong></h3><p>1.添加 ‘插入/更新’ 插件，配置数据库连接信息。</p><p><img src="/images/ETL_20210315210849.png" alt="“伊成博客”"></p><p>设置好用来查询的关键字字段，这一步是用来当成数据查询的条件。<br>更新字段这一项是获取数据之后需要更新哪一些字段。</p><p><img src="/images/ETL_20210315211529.png" alt="“伊成博客”"></p><p>配置完成之后可以点击运行按钮，接着查看数据库对应的表是否存放了符合条件的数据。</p><p><img src="/images/ETL_20210315211802.png" alt="“伊成博客”"></p><p>数据成功存入到对应数据库表中，到此数据抽取，转换，装载都完成了。<br>但每个月1号需要执行一次这个涉及到定时调度，我们后续再出对应博文讲解！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a><strong>其它说明</strong></h2><p><a href="http://www.devcheng.net/post/53978f67.html">《ETL入门系列01》</a></p><p><a href="http://www.devcheng.net/post/cc6d4f48.html">《ETL入门系列02》</a></p><p><a href="http://www.devcheng.net/post/bb6a7fde.html">《ETL入门系列03》</a></p><p>ETL入门系列到此结束！</p><p>本案例中涉及的execl文档和ktr文件有需要的可以加QQ群：816175200<br>备注: ckettle</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;结合前面两篇博文，这篇博文进行一次实战案例，用于介绍如何使用Ckettle做数据集成。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
      <category term="实战案例" scheme="http://www.devcheng.net/tags/%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列 02</title>
    <link href="http://www.devcheng.net/post/cc6d4f48.html"/>
    <id>http://www.devcheng.net/post/cc6d4f48.html</id>
    <published>2021-02-24T13:44:07.000Z</published>
    <updated>2021-02-24T13:48:31.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>上一篇我们提到了有几款开源的ETL工具，接下来将学习CKettle。CKettle源于Kettle，在CKettle官网自我介绍中是这样描述自己的 “源于开源，强于开源”。主要提供专职、专业的技术支持和帮助，快速响应国内用户，他们致力于打造专业的ETL技术交流社区。</p><h2 id="下载CKettle"><a href="#下载CKettle" class="headerlink" title="下载CKettle"></a><strong>下载CKettle</strong></h2><p>下载地址： <a href="https://ckettle.ccsaii.com.cn/" target="_blank" rel="noopener">https://ckettle.ccsaii.com.cn/</a></p><p><img src="/images/ETL_202102241.png" alt="“伊成博客”"></p><p>下载稳定版即可！</p><p><strong>必要准备</strong><br>CKettle是基于Java开发的，所以确保你本地电脑配置了Java环境变量。</p><p>下载得到一个zip压缩包，解压缩出来之后，结构目录如下：</p><p><img src="/images/ETL_202102242.png" alt="“伊成博客”"></p><p>windows下双击 Spoon.bat 启动。</p><p><img src="/images/ETL_202102243.png" alt="“伊成博客”"></p><p>在结构目录中我们经常使用到的有： Spoon.bat , Kitchen.bat , Pan.bat , Carte.bat</p><p>下面分别介绍</p><h3 id="Spoon-设计器"><a href="#Spoon-设计器" class="headerlink" title="Spoon(设计器)"></a><strong>Spoon(设计器)</strong></h3><p>提供了一个图形用户界面，用户创建(编辑)作业或转换；也可以用户执行(调试)作业或转换，它还提供了性能监控的功能。</p><h3 id="Kitchen"><a href="#Kitchen" class="headerlink" title="Kitchen"></a><strong>Kitchen</strong></h3><p>用于作业的命令行运行，可以通过Shell脚本来调用，常用于Linux环境中。</p><h3 id="Pan"><a href="#Pan" class="headerlink" title="Pan"></a><strong>Pan</strong></h3><p>用户转换的命令行运行，和Kitchen一样可以通过Shell脚本来调用。</p><h3 id="Carte"><a href="#Carte" class="headerlink" title="Carte"></a><strong>Carte</strong></h3><p>是一个轻量级的HTTP服务器，后台运行，监听HTTP请求来运行一个作业或转换,也可以用于分布式执行作业或转换，也就是CKettle的集群。</p><p>关于以上几个命令如何使用，后续我们结合例子再做详细说明。</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;上一篇我们提到了有几款开源的ETL工具，接下来将学习CKettle。CKettle源于Kettle，在CK
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="ELT" scheme="http://www.devcheng.net/tags/ELT/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列01</title>
    <link href="http://www.devcheng.net/post/53978f67.html"/>
    <id>http://www.devcheng.net/post/53978f67.html</id>
    <published>2021-02-21T07:12:47.000Z</published>
    <updated>2021-02-21T07:31:31.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>DT时代，把数据转换为信息、知识，已成为企业提高核心竞争力的关键。目前，大多数企业和政府采用传统的数据库脚本方式来处理数据，但是脚本方式可读性差，过分依赖人，无论是程序的迁移还是系统维护，都极为不便，而ETL则成为主要的一个技术手段。</p><h3 id="什么是ETL"><a href="#什么是ETL" class="headerlink" title="什么是ETL"></a><strong>什么是ETL</strong></h3><p>字面含义：ETL（Extact-Transform-Load，数据的抽取、转换、加载）是抽取、转换、加载的缩写。</p><p>简单定义：把数据从OLTP系统中转移到数据仓库中的一系列操作的集合。</p><h4 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a><strong>抽取</strong></h4><p> 一般抽取过程需要连接到不同的数据源，以便为随后的步骤提供数据。这一部分看上去简单而琐碎，实际上它是ETL解决方案成功实施的一个主要障碍。</p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a><strong>转换</strong></h4><p> 在抽取和加载之间，任何对数据的处理过程都是转换。这些处理过程通常包括（但不限于）下面一些操作。</p><ul><li>移动数据</li><li>根据规则验证数据</li><li>数据内容和数据结构的修改</li><li>集成多个数据源的数据</li><li>根据处理后的数据计算派生值和聚集值</li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><p> 将数据加载到目标系统的所有操作。</p><h3 id="ETL解决方案演化过程"><a href="#ETL解决方案演化过程" class="headerlink" title="ETL解决方案演化过程"></a><strong>ETL解决方案演化过程</strong></h3><p>第一代，使用手工编程、脚本的方式来完成。</p><p>第二代，依据设计好的ETL工作流来自动生成所需代码。</p><p>第三代，采用基于引擎的架构，可以执行所有的数据处理进程，还可以将所有的数据库连接和转换规则作为元数据存储起来。</p><p>第四代，基于MDA智能化ETL。</p><h3 id="ETL工具"><a href="#ETL工具" class="headerlink" title="ETL工具"></a><strong>ETL工具</strong></h3><p><img src="/images/ETL_202101.png" alt="“伊成博客”"></p><p><img src="/images/ETL_202102.png" alt="“伊成博客”"></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><p>一，数据迁移。</p><p>二，数据同步。</p><h3 id="数据集成的几种方式"><a href="#数据集成的几种方式" class="headerlink" title="数据集成的几种方式"></a><strong>数据集成的几种方式</strong></h3><p><img src="/images/ETL_202103.png" alt="“伊成博客”"></p><h4 id="ELT"><a href="#ELT" class="headerlink" title="ELT"></a><strong>ELT</strong></h4><p>抽取、加载和转换的简称，同ETL在数据整合的方法上略微不同。在ELT的情况下，数据首先从源数据进行抽取、加载到目标数据库中，再转换为所需要的格式。所有大数据量处理全部放在目标数据库中进行。这种做法的好处在于，一般情况下，数据库系统更适合处理负荷在百万级以上的数据储存民。数据库系统也通常会对I/O(吞吐量)进行优化，用来提高数据处理速度。</p><h4 id="EII"><a href="#EII" class="headerlink" title="EII"></a><strong>EII</strong></h4><p>除了物理数据集成方式，还有虚拟数据集成方式也可以满足用户访问数据的要求。这种虚拟数据集成试就是企业信息集成，也就是EII。如数据联邦和数据虚拟化，也都是描述同样的事情。</p><p>这种方法的主要优点就是数据永远都是最新的，不需要额外的存储层，没有冗余数据。缺点就是使用虚拟方法来管理大量的、清洗后的、时效性强的数据是一个非常具有挑战性的工作。</p><h3 id="虚拟数据集成和物理数据集成的比较"><a href="#虚拟数据集成和物理数据集成的比较" class="headerlink" title="虚拟数据集成和物理数据集成的比较"></a><strong>虚拟数据集成和物理数据集成的比较</strong></h3><p><img src="/images/ETL_202104.png" alt="“伊成博客”"></p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;DT时代，把数据转换为信息、知识，已成为企业提高核心竞争力的关键。目前，大多数企业和政府采用传统的数据库脚
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="ELT" scheme="http://www.devcheng.net/tags/ELT/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringBoot开发的招聘网站源码分享</title>
    <link href="http://www.devcheng.net/post/2093beaf.html"/>
    <id>http://www.devcheng.net/post/2093beaf.html</id>
    <published>2021-01-19T02:16:31.000Z</published>
    <updated>2021-01-19T03:36:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于SpringBoot开发招聘网站，可以当作毕业设计、期末课程作业等，也使用刚刚入门SpringBoot的同学们！</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a><strong>功能描述</strong></h2><p>项目分为应聘方和招聘方两种角色，招聘方可以发布职位，应聘方创建简历通过投递简历应聘。</p><p>在项目中主要拥有的功能有：登录（密码登录，验证码登录），注册，创建简历，投递，查看职位详情，申请职位等。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><ul><li>系统环境：Windows 10</li><li>开发工具：IntelliJ IDEA</li><li>Java版本：JDK 1.8</li></ul><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven 3.X</li><li>Bootstarp</li><li>Druid</li><li>Mysql</li><li>Jsp</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8081/" target="_blank" rel="noopener">http://localhost:8081/</a></p><p>账户和密码(密码登陆)： 18612345678 / 1234567</p><h2 id="系统展示图"><a href="#系统展示图" class="headerlink" title="系统展示图"></a><strong>系统展示图</strong></h2><p><img src="/images/devcheng_net_zhaopin3.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin2.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin1.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin4.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin5.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！ 备注：招聘网站源码</p><h2 id="项目演示视频"><a href="#项目演示视频" class="headerlink" title="项目演示视频"></a><strong>项目演示视频</strong></h2><p>链接: <a href="https://pan.baidu.com/s/1pIwQ3s8casozF02VzRVtxQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1pIwQ3s8casozF02VzRVtxQ</a> </p><p>提取码: dxnr </p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖怪请绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于SpringBoot开发招聘网站，可以当作毕业设计、期末课程作业等，也使用刚刚入门Spring
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="SpringBoot" scheme="http://www.devcheng.net/tags/SpringBoot/"/>
    
      <category term="招聘网站" scheme="http://www.devcheng.net/tags/%E6%8B%9B%E8%81%98%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>分享几个实用的Git技巧</title>
    <link href="http://www.devcheng.net/post/ddae8940.html"/>
    <id>http://www.devcheng.net/post/ddae8940.html</id>
    <published>2021-01-12T13:59:13.000Z</published>
    <updated>2021-01-12T14:08:38.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>可以这么说,Git在一定程度上拯救了很多开发者的饭碗。只要你经常使用Git保存自己的工作，你就一直有机会可以将代码退回到之前的状态，因此就可以挽回那些你深夜里迷迷糊糊犯下的错误。</p><p>但是Git的命令行界面可是出了名的难掌握。接下来，就给大家介绍7个比较实用的小技巧，最大限度发挥Git的作用。</p><p>通常，大部分时间我们都只会用到add、commit、branch和push/pull这些命令。大部分人熟悉这套只往一个方向运转的工作流。你们有没有想过，如果自己往仓库中添加了错误的文件，或是将代码提交到了错误的分支，而且提交信息还写错了的话，自己怎样才能取消之前的操作？如果你也是按照上面漫画中所描绘的一样操作的，那么你就有必要了解下面这些Git使用技巧了。</p><h2 id="Git技巧"><a href="#Git技巧" class="headerlink" title="Git技巧"></a>Git技巧</h2><h3 id="1-修改错误的提交信息（commit-message）"><a href="#1-修改错误的提交信息（commit-message）" class="headerlink" title="1.修改错误的提交信息（commit message）"></a>1.修改错误的提交信息（commit message）</h3><p>提交的信息在很长时间内会一直保留在你的代码库（code base）中，所以你肯定希望通过这个信息正确地了解代码修改情况。 下面这个命令可以让你编辑最近一次的提交信息，但是你必须确保没有对当前的代码库（working copy）做修改，否则这些修改也会随之一起提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”</span><br></pre></td></tr></table></figure><p>假如你已经将代码提交（git commit）推送（git push）到了远程分支，那么你需要通过下面的命令强制推送这次的代码提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote&gt; &lt;branch&gt; --force</span><br></pre></td></tr></table></figure><h3 id="2-提交之前撤销-git-add"><a href="#2-提交之前撤销-git-add" class="headerlink" title="2.提交之前撤销 git add"></a>2.提交之前撤销 git add</h3><p>如果你往暂存区（staging area）中加入了一些错误的文件，但是还没有提交代码。你可以使用一条简单的命令就可以撤销。如果只需要移除一个文件，那么请输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>或者如果你想从暂存区移除所有没有提交的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset</span><br></pre></td></tr></table></figure><h3 id="3-撤销最近一次代码提交"><a href="#3-撤销最近一次代码提交" class="headerlink" title="3.撤销最近一次代码提交"></a>3.撤销最近一次代码提交</h3><p>有时候你可能会不小心提交了错误的文件或一开始就遗漏了某些东西。<br>下面这三步操作可以帮助你解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p><strong>对工作文件进行必要的更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A .</span><br><span class="line">$ git commit -c ORIG_HEAD</span><br></pre></td></tr></table></figure><p>你执行第一个命令时，Git会将HEAD指针后移到此前的一次提交，之后你才能移动文件或作必要的修改。</p><p>然后你就可以添加所有的修改，而且当你执行最后的命令时，Git会打开你的默认文本编辑器，其中会包含上一次提交时的信息。<br>如果愿意的话，你可以修改提交信息，或者你也可以在最后的命令中使用-C而不是-c，来跳过这一步。</p><h3 id="4-Git仓库撤销至前一次提交时的状态"><a href="#4-Git仓库撤销至前一次提交时的状态" class="headerlink" title="4.Git仓库撤销至前一次提交时的状态"></a>4.Git仓库撤销至前一次提交时的状态</h3><p>“撤销”（revert）在许多情况下是非常有必要的——尤其是你把代码搞的一团糟的情况下。最常见的情况是，你想回到之前代码版本，检查下那个时候的代码库，然后再回到现在状态。这可以通过下面的命令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;SHA&gt;</span><br></pre></td></tr></table></figure><p>“”是你想查看的提交拥有的哈希值（Hash Code）中前8至10个字符。 这个命令会使<head><meta name="generator" content="Hexo 3.8.0">指针脱离（detach），可以让你在不检出（check out）任何分支的情况下查看代码——脱离HEAD并不像听上去那么可怕。如果你想在这种情况下提交修改，你可以通过创建新的分支来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;SHA&gt;</span><br></pre></td></tr></table></figure></head></p><p>要想回到当前的工作进度，只需要检出（check out）你之前所在的分支即可。</p><h3 id="5-撤销合并（Merge）"><a href="#5-撤销合并（Merge）" class="headerlink" title="5.撤销合并（Merge）"></a>5.撤销合并（Merge）</h3><p>要想撤销合并，你可能必须要使用恢复命令（HARD RESET）回到上一次提交的状态。“合并”所做的工作基本上就是重置索引，更新working tree（工作树）中的不同文件，即当前提交（）代码中与HEAD游标所指向代码之间的不同文件；但是合并会保留索引与working tree之间的差异部分（例如那些没有被追踪的修改）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;SHA&gt;</span><br></pre></td></tr></table></figure></p><p>当然，Git中总是有其他的实现办法，你可以查看看这篇文章继续了解。</p><h3 id="6-从当前Git分支移除未追踪的本地文件"><a href="#6-从当前Git分支移除未追踪的本地文件" class="headerlink" title="6.从当前Git分支移除未追踪的本地文件"></a>6.从当前Git分支移除未追踪的本地文件</h3><p>假设你凑巧有一些未被追踪的文件（因为不再需要它们），不想每次使用git status命令时让它们显示出来。下面是解决这个问题的一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f -n         # 1</span><br><span class="line">$ git clean -f            # 2</span><br><span class="line">$ git clean -fd           # 3</span><br><span class="line">$ git clean -fX           # 4</span><br><span class="line">$ git clean -fx           # 5</span><br></pre></td></tr></table></figure></p><p>(1): 选项-n将显示执行（2）时将会移除哪些文件。<br>(2): 该命令会移除所有命令（1）中显示的文件。<br>(3): 如果你还想移除文件件，请使用选项-d。<br>(4): 如果你只想移除已被忽略的文件，请使用选项-X。<br>(5): 如果你想移除已被忽略和未被忽略的文件，请使用选项-x。<br>请注意最后两个命令中X的区别。</p><h3 id="7-删除本地和远程Git分支"><a href="#7-删除本地和远程Git分支" class="headerlink" title="7.删除本地和远程Git分支"></a>7.删除本地和远程Git分支</h3><p>删除本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --delete --force &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p><p>或者使用选项-D作为简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D</span><br></pre></td></tr></table></figure></p><p>删除远程分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p><p>建议：要想更好地掌握Git的用法，还得仔细阅读Git官方文档！</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;可以这么说,Git在一定程度上拯救了很多开发者的饭碗。只要你经常使用Git保存自己的工作，你就一直有机会可以将代码退回到之前
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Git" scheme="http://www.devcheng.net/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化干货总结</title>
    <link href="http://www.devcheng.net/post/991a821e.html"/>
    <id>http://www.devcheng.net/post/991a821e.html</id>
    <published>2021-01-03T06:45:54.000Z</published>
    <updated>2021-01-03T07:12:02.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？”。<br>SQL优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，如果是你，在这个问题上能吊打面试官还是会被吊打呢？</p><h2 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h2><h3 id="SELECT语句-语法顺序"><a href="#SELECT语句-语法顺序" class="headerlink" title="SELECT语句 - 语法顺序"></a>SELECT语句 - 语法顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. SELECT </span><br><span class="line">2. DISTINCT &lt;select_list&gt;</span><br><span class="line">3. FROM &lt;left_table&gt;</span><br><span class="line">4. &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">5. ON &lt;join_condition&gt;</span><br><span class="line">6. WHERE &lt;where_condition&gt;</span><br><span class="line">7. GROUP BY &lt;group_by_list&gt;</span><br><span class="line">8. HAVING &lt;having_condition&gt;</span><br><span class="line">9. ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">10.LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>Tips:以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准。</p><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h2><h3 id="避免不走索引的场景"><a href="#避免不走索引的场景" class="headerlink" title="避免不走索引的场景"></a>避免不走索引的场景</h3><ol><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;%陈%&apos;</span><br></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;陈%&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量避免使用in 和not in，会导致引擎走全表扫描</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id IN (2,3)</span><br></pre></td></tr></table></figure><p>优化方式：如果是连续数值，可以用between代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id BETWEEN 2 AND 3</span><br></pre></td></tr></table></figure><p>如果是子查询，可以用exists代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 不走索引</span><br><span class="line">select * from A where A.id in (select id from B);</span><br><span class="line">-- 走索引</span><br><span class="line">select * from A where exists (select * from B where B.id = A.id);</span><br></pre></td></tr></table></figure><ol start="3"><li>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1 OR id = 3</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：可以用union代替or。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM student WHERE id = 3</span><br></pre></td></tr></table></figure><p>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score IS NUL</span><br></pre></td></tr></table></figure></p><p>优化方式：可以给字段添加默认值0，对0值进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score = 0</span><br></pre></td></tr></table></figure><p>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。<br>可以将表达式、函数操作移动到等号右侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">SELECT * FROM T WHERE score/10 = 9</span><br><span class="line">-- 走索引</span><br><span class="line">SELECT * FROM T WHERE score = 10*9</span><br></pre></td></tr></table></figure></p><ol start="6"><li>当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username, age, sex FROM T WHERE 1=1</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。</p><ol start="7"><li>查询条件不能用 &lt;&gt; 或者 != 使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</li></ol><ol start="8"><li><p>where条件仅包含复合索引非前置列<br>复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where key_part2=1 and key_part3=2</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换造成不使用索引<br>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where col_varchar=123;</span><br></pre></td></tr></table></figure></li><li><p>order by 条件要与where中条件一致，否则order by不会利用索引进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 不走age索引</span><br><span class="line">SELECT * FROM student order by age;</span><br><span class="line"> </span><br><span class="line">-- 走age索引</span><br><span class="line">SELECT * FROM student where age &gt; 0 order by age;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SELECT语句其他优化"><a href="#SELECT语句其他优化" class="headerlink" title="SELECT语句其他优化"></a>SELECT语句其他优化</h2><ol><li>避免出现select *</li><li>避免出现不确定结果的函数</li><li>多表关联查询时，小表在前，大表在后。</li><li>使用表的别名</li><li>用where字句替换HAVING字句</li><li>调整Where字句中的连接顺序</li></ol><h2 id="查询条件优化"><a href="#查询条件优化" class="headerlink" title="查询条件优化"></a>查询条件优化</h2><ol><li>对于复杂的查询，可以使用中间临时表 暂存数据</li></ol><ol start="2"><li><p>优化group by语句<br>默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。<br>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：<br>SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;</p></li><li><p>优化join语句<br>MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。<br>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：<br>SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )<br>如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM customerinfo </span><br><span class="line">   LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID </span><br><span class="line">      WHERE salesinfo.CustomerID IS NULL</span><br></pre></td></tr></table></figure><p>连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><ol start="4"><li>优化union查询<br>MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。<br>高效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION ALL </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>低效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></p><p>5.拆分复杂SQL为多个小SQL，避免大事务<br>简单的SQL容易使用到MySQL的QUERY CACHE；<br>减少锁表时间特别是使用MyISAM存储引擎的表；可以使用多核CPU。</p><p>6.使用truncate代替delete<br>当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。<br>使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。</p><h2 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h2><p>1.在表中建立索引，优先考虑where、order by使用到的字段。</p><ol start="2"><li>尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</li></ol><p>3.查询数据量大的表 会造成查询缓慢。</p><p>4.用varchar/nvarchar 代替 char/nchar<br>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id="The-end"><a href="#The-end" class="headerlink" title="The end ."></a>The end .</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL优化" scheme="http://www.devcheng.net/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker踩坑学习笔记</title>
    <link href="http://www.devcheng.net/post/53539811.html"/>
    <id>http://www.devcheng.net/post/53539811.html</id>
    <published>2020-12-25T15:13:25.000Z</published>
    <updated>2020-12-25T15:24:19.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>安装完成功docker后，如何在容器中安装JDK、TOMCAT。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search jdk </span><br><span class="line"></span><br><span class="line">docker install jdk_open...</span><br></pre></td></tr></table></figure><h2 id="docker中如何挂载文件"><a href="#docker中如何挂载文件" class="headerlink" title="docker中如何挂载文件"></a>docker中如何挂载文件</h2><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>上传压缩文件到服务器，这种方式需要将服务器上的文件挂载到docker 容器中。<br>docker可以支持把一个宿主机上的目录挂载在docker容器中（镜像）。</p><p>tips:要把宿主机文件挂载在容器中，此时，身份是 宿主机中<br>找到要被挂载文件的目录</p><p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径</p><p>执行</p><p><img src="/images/devcheng_net_docker_1clipboard.png" alt="image-20200629094621998"></p><p>挂载成功</p><p><img src="/images/devcheng_net_docker_2clipboard.png" alt="image-20200629094621998"></p><p>解压jdk </p><p>此时会遇到权限不够的问题</p><p>操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.退出容器</span><br><span class="line">2. 执行 su -c &quot;setenforce 0&quot;</span><br><span class="line">3.dorcker run -i -t centos /bin/bash</span><br></pre></td></tr></table></figure></p><p>重新解压即可！<br>相关解决链接：<a href="http://www.cnblogs.com/adamas21/p/6280297.html" target="_blank" rel="noopener">http://www.cnblogs.com/adamas21/p/6280297.html</a></p><p>启动docker web服务时,虚拟机端口转发外部无法访问?可参考以下链接：<br><a href="http://blog.csdn.net/u014062332/article/details/52911405" target="_blank" rel="noopener">http://blog.csdn.net/u014062332/article/details/52911405</a></p><h3 id="jdk的配置"><a href="#jdk的配置" class="headerlink" title="jdk的配置"></a>jdk的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下配置</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_121</span><br><span class="line">export JRE_HOME=/usr/java/jdk1.8.0_121/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br></pre></td></tr></table></figure><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end."></a>The end.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;安装完成功docker后，如何在容器中安装JDK、TOMCAT。&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="docker" scheme="http://www.devcheng.net/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://www.devcheng.net/post/43a71ae4.html"/>
    <id>http://www.devcheng.net/post/43a71ae4.html</id>
    <published>2020-11-29T10:53:46.000Z</published>
    <updated>2020-11-29T11:02:03.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最典型的例子就是查新华字典，通过查找目录快速定位到查找的字</p><ul><li>大大减少了服务器需要扫描的数量</li><li>帮助服务器避免排序和临时表</li><li>将IO变成顺序IO<ul><li>尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问</li><li>在复制1G压缩包 和 1G小文件，前者的速度会大于后者</li><li>减少IO的量，例如写SQL语句的时候，不要写 select *</li><li>减少IO的次数，一次IO能搞定的事，不使用3次IO</li></ul></li></ul><h2 id="索引的用处"><a href="#索引的用处" class="headerlink" title="索引的用处"></a>索引的用处</h2><ul><li>快速查找匹配where子句的行</li><li>从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用栈找到最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的最左匹配前缀来查找</li><li>当有表连接的时候，从其他表检测行数据</li><li>查找特定索引列min或max值</li><li>如果排序或分组是，在可用索引的最左前缀上完成的，则对表进行排序和分组</li><li>在某些清空下，可以优化查询以检索值而无需查询数据行</li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>如果你在创建索引的时候，使用的是主键这个值，那么就是主键索引，primary key</p><p>我们建表的时候，例如下面这个建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_blog_sort`</span> (</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一uid'</span>,</span><br><span class="line">  <span class="string">`sort_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类内容'</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类简介'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`status`</span> tinyint(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</span><br><span class="line">  <span class="string">`sort`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'排序字段，越大越靠前'</span>,</span><br><span class="line">  <span class="string">`click_count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'点击数'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'博客分类表'</span>;</span><br></pre></td></tr></table></figure><p>这里面有使用到    PRIMARY KEY (<code>uid</code>)，这就是主键索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引 类似于普通索引，索引列的值必须唯一</p><p>唯一索引和主键索引的区别就是，唯一索引允许出现空值，而主键索引不能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique index_name column</span><br></pre></td></tr></table></figure><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>当我们需要建立索引的字段，既不是主键索引，也不是唯一索引</p><p>那么就可以创建一个普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>(..., <span class="keyword">index</span> index_name <span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>lunce、solr和ElasticSearch就是做全文检索的，里面涉及到了倒排索引的概念，mysql很少使用全文索引。</p><p>要用来查找文本中的关键字，不是直接与索引中的值相比较，像是一个搜索引擎，配合 match against 使用，现在只有char，varchar，text上可以创建索引，在数据量比较大时，先将数据放在一个没有全文索引的表里，然后在利用create index创建全文索引，比先生成全文索引在插入数据快很多。</p><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>目前，在业务不是特别复杂的时候，可能使用一个列作为索引，或者直接采用主键索引即可，但是如果业务变得复杂的时候，就需要用到组合索引，通过对多个列建立索引。</p><p>组合索引的用处，假设我现在表有个多个字段：id、name、age、gender，然后我经常使用以下的查询条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'xx'</span> <span class="keyword">and</span> age = xx</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以通过组合 name 和 age 来建立一个组合索引，加快查询效率，建立成组合索引后，我的索引将包含两个key值</p><p>在多个字段上创建索引，遵循<strong>最左匹配</strong>原则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> index_name(a,b,c);</span><br></pre></td></tr></table></figure><h2 id="索引的使用与否"><a href="#索引的使用与否" class="headerlink" title="索引的使用与否"></a>索引的使用与否</h2><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>MySQL每次只使用一个索引，与其说 数据库查询只能用一个索引，倒不如说，和全表扫描比起来，去分析两个索引 B+树更耗费时间，所以where A=a and B=b 这种查询使用（A，B）的组合索引最佳，B+树根据（A，B）来排序。</p><ul><li>主键，unique字段</li><li>和其他表做连接的字段需要加索引</li><li>在where 里使用 &gt;, &gt;=, = , &lt;, &lt;=, is null 和 between等字段。</li><li>使用不以通配符开始的like，where A like ‘China%’</li><li>聚合函数里面的 MIN()， MAX()的字段</li><li>order by  和 group by字段</li></ul><h3 id="何时不使用索引"><a href="#何时不使用索引" class="headerlink" title="何时不使用索引"></a>何时不使用索引</h3><ul><li>表记录太少</li><li>数据重复且分布平均的字段（只有很少数据的列）；</li><li>经常插入、删除、修改的表要减少索引</li><li>text，image 等类型不应该建立索引，这些列的数据量大（加入text的前10个字符唯一，也可以对text前10个字符建立索引）</li><li>MySQL能估计出全表扫描比使用索引更快的时候，不使用索引</li></ul><h3 id="索引何时失效"><a href="#索引何时失效" class="headerlink" title="索引何时失效"></a>索引何时失效</h3><ul><li>组合索引为使用最左前缀，例如组合索引（A，B），where B = b 不会使用索引</li><li>like未使用最左前缀，where A  like “%China”</li><li>搜索一个索引而在另一个索引上做 order by， where A = a order by B，只会使用A上的索引，因为查询只使用一个索引。</li><li>or会使索引失效。如果查询字段相同，也可以使用索引。例如  where A = a1 or A = a2（生效），where A=a or B = b （失效）</li><li>在索引列上的操作，函数upper()等，or、！ = （&lt;&gt;）,not in 等</li></ul><h2 id="面试技术名词"><a href="#面试技术名词" class="headerlink" title="面试技术名词"></a>面试技术名词</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>首先我们需要知道，我们建立几个索引，就会生成几棵B+Tree，但是带有原始数据行的B+Tree只有一棵，另外一棵树上的叶子节点带的是主键值。</p><p>例如，我们通过主键建立了主键索引，然后在叶子节点上存放的是我们的数据</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094621998.png" alt="image-20200629094621998"></p><p>当我们创建了两个索引时，一个是主键，一个是name，它还会在生成一棵B+Tree，这棵树的叶子节点存放的是主键，当我们通过name进行查找的时候，会得到一个主键，然后在通过主键再去上面的这个主键B+Tree中进行查找，我们称这个操作为 ==<strong>回表</strong>==</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p><p>当我们的SQL语句使用的是下面这种的时候，它会查找第一颗树，直接返回我们的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb where id = 1</span><br></pre></td></tr></table></figure><p>当我们使用下面这种查询的时候，它会先查找第二棵树得到我们的主键，然后拿着主键再去查询第一棵树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb  where name = &apos;gang&apos;</span><br></pre></td></tr></table></figure><p>回表就是通过普通列的索引进行检索，然后再去主键列进行检索，这个操作就是回表</p><p>==但是我们在使用检索的时候，尽量避免回表，因为这会造成两次B+Tree的查询，假设一次B+Tree查询需要三次IO操作，那么查询两次B+Tree就需要六次IO操作。==</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>我们看下面的两个SQL语句，看看它们的查询过程是一样的么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">name</span> = zhou</span><br></pre></td></tr></table></figure><p>答案是不一样的，首先我们看第二个语句，就是要输出的列中，就是我们的主键，当我们通过name建立的B+Tree进行查询的时候</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p><p>我们可以直接找到我们的数据，并得到主键，但是因为我们要返回的就是name，此时说明数据存在了，那么就直接把当前的name进行返回，而不需要通过主键再去主键B+Tree中进行查询。</p><p>这样一个不需要进行回表操作的过程，我们称为<strong>索引覆盖</strong></p><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>这里提到的 <strong>最左匹配</strong> 和 <strong>索引下推</strong> 都是针对于组合索引的。</p><p>例如，我们有这样一个索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  age：组合索引</span><br></pre></td></tr></table></figure><p>必须要先匹配name，才能匹配到age。这个我们就被称为最左匹配</p><p>例如下面的几条SQL语句，那些语句不会使用组合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where name = ? and age = ?</span><br><span class="line">where name = ?</span><br><span class="line">where age = ?</span><br><span class="line">where age = ? and name = ?</span><br></pre></td></tr></table></figure><p>根据最左匹配原则，我们的 3 不会使用组合索引的。</p><p>那为什么4的顺序不一样，也会使用组合索引呢？</p><p>其实内部的优化器会进行调整，例如下面的一个连表操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id = tb2.id</span><br></pre></td></tr></table></figure><p>其实在加载表的时候，并不一定是先加载tb1，在加载tb2，而是可能根据表的大小决定的，小的表优先加载进内存中。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>在说索引下推的时候，我们首先在举两个例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">name</span> = ? <span class="keyword">and</span> age = ?</span><br></pre></td></tr></table></figure><p>在mysq 5.6之前，会先根据name去存储引擎中拿到所有的数据，然后在server层对age进行数据过滤</p><p>在mysql5.6之后，根据name 和 age两个列的值去获取数据，直到把数据返回。</p><p>通过对比能够发现，第一个的效率低，第二个的效率高，因为整体的IO量少了，原来是把数据查询出来，在server层进行筛选，而现在在存储引擎层面进行筛选，然后返回结果。我们把这个过程就称为  <strong>索引下推</strong></p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h4 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h4><p>基于成本的优化</p><h4 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h4><p>基于规则的优化</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629110258878.png" alt="image-20200629110258878"></p><h2 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h2><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配指的是和索引中所有的列进行匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><p>而我们建立了一个 包含  name、age、pos的组合索引，使用上面的SQL语句，就会进行全值匹配</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>只匹配前面的几列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span></span><br></pre></td></tr></table></figure><p>这个时候，只使匹配了前面两个列，而没有使用第三个列</p><p>现在我们使用下面的SQL语句进行验证，但我们输出值只包含ID的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们查看其任务计划，在某尾有 Extra字段，如果是Using index 表示是使用了覆盖索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629144438346.png" alt="image-20200629144438346"></p><p>然后我们在查看下面这条SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过查看任务计划，发现extra字段是NULL，说明没有使用覆盖索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629145948288.png" alt="image-20200629145948288"></p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>可以匹配某一列值的开头部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'J%'</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'%y'</span></span><br></pre></td></tr></table></figure><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>可以查找某个范围的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span></span><br></pre></td></tr></table></figure><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>可以查询某一列的全部和第二列的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"July"</span> <span class="keyword">and</span> age &gt; <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>查询的时候值需要访问索引，不需要访问数据行，本质上就是索引覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"July"</span> <span class="keyword">and</span> age=<span class="number">25</span> <span class="keyword">and</span> pos = <span class="string">"dev"</span></span><br></pre></td></tr></table></figure><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>基于哈希的实现，只有精确匹配索引所有的列的查询才有效，在mysql中，只有memory的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，索引索引的结构十分紧凑，这让哈希索引查找的速度非常快。</p><h3 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h3><ul><li>哈希索引值包含哈希值和行指针，而不存储字段值。索引不能使用索引中的值来避免读取行</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li><li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li><li>哈希索引支持等值比较查询，也不支持任何范围查询</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，知道找到所有符合条件的行</li><li>哈希冲突比较多的话，维护的代价也会很高</li></ul><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按每张表的主键构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据也，这个特性就决定了索引组织表中的数据也是索引的一部分。</p><p>==一句话来说：将索引和数据放在一起的，就称为聚簇索引==</p><p>我们日常的工作中，根据实际情况自行添加的索引，都是辅助索引或者称为普通索引，辅助索引就是为了查找主键索引的二级索引，先找到主键索引然后再通过主键索引找数据，但是可能会存在<strong>回表</strong>的问题。</p><h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对主键的排序和范围查找速度非常快</li></ul><h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul><li>插入速度严重依赖于排序，按照主键的顺序插入是最快的方式，否者会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键</li><li>更新主键的代价很高，因为将会导致被更新的行移动，因此，对于InnoDB表，我们一般定义主键不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次 根据主键值查找行数据，一般我们需要尽量避免出现索引的二次查找，这个时候，用到的就是<strong>索引的覆盖</strong></li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引也被称为辅助索引，辅助索引在我们访问数据的时候总是需要两次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到主键值，然后在通过主键值找到数据行的数据页，在通过数据页中的Page Directory找到数据行。</p><p>InnoDB辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了行数据的聚簇索引建。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在InnoDB中有时也称为辅助索引为二级索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629113413737.png" alt="image-20200629113413737"></p><h2 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p><p>第4个不走索引，是因为不满足最左匹配原则</p><p>第5个，因为跨过了b，所以只走a的索引</p><h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><ul><li><p>当使用索引列进行查询的时候，尽量不要使用表达式，把计算放到业务层而不是数据库层</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">4</span></span><br><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id+<span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>第一条语句走索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161629049.png" alt="image-20200629161629049"></p><p>而第二条语句没有走主键索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161641522.png" alt="image-20200629161641522"></p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表操作</p></li><li><p>使用前缀索引</p></li></ul><p>有时候需要索引很长的字符串，这会让索引变得大且满，通常情况下可以使用某个列开始的部分字符串，这样大大的节约了索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T 到 1 之间，索引的选择性越高，则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p><p>一般情况下，某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOG，TEXT，VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于选择足够长的前缀以保证较高的选择性，通过又不能太长 。</p><ul><li>使用索引扫描来进行排序</li><li>union、all、in、or都能使用索引，但是推荐使用in</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">union</span> all <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> actor_id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关于or到底走不走索引，必须根据实际情况进行考虑</span></span><br></pre></td></tr></table></figure><ul><li>范围列可以使用到索引</li></ul><p>例如 范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，所以一般如果我们使用组合索引的时候，最好不要使用范围查找</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p><p>如倒数第一个所示，因为中间b使用了范围查找，所以后面的c是无法使用索引的，只能是a和b才能使用索引</p><ul><li>强制类型转换会让索引失效，进行全表查询</li></ul><p>例如下面这样一个例子所示，我们对 phone字段进行了强制类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="number">13800001234</span>  <span class="comment">-- 不会触发索引（触发了字符串到整型转换）</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="string">'13800001234'</span>  <span class="comment">-- 触发索引</span></span><br></pre></td></tr></table></figure><ul><li>更新十分频繁，数据区分度不高的字段上不宜建立索引</li></ul><p>更新会变更B+树，更新 频繁的字段建立索引会大大降低数据库性能</p><p>类似于性别这列的区分度不高的字段，建立索引是没有意义的，不能有效的过滤数据</p><p>一般区分度在百分80以上的时候，就可以建立索引，区分度可以使用 count(distinct(列名)) / count(*) 来进行计算</p><ul><li>创建索引的列，不允许为null，可能会得到不符合预期的结果</li><li>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致（阿里规约）<ul><li>允许数据的冗余，从而加快查询的效率</li><li>目前是范式和反范式的混合使用</li></ul></li><li>能使用limit的时候，尽量使用limit</li><li>单表索引建议控制在5个以内</li><li>单索引字段不允许超过5个（组合索引）</li><li>创建索引的时候应该尽量避免以下错误的概念</li></ul><p>索引不是越多越好，不要在不了解系统的情况下进行优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引的优点&quot;&gt;&lt;a href=&quot;#索引的优点&quot; class=&quot;headerlink&quot; title=&quot;索引的优点&quot;&gt;&lt;/a&gt;索引的优点&lt;/h2&gt;&lt;p&gt;最典型的例子就是查新华字典，通过查找目录快速定位到查找的字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大大减少了服务器需要扫描的数量
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL索引" scheme="http://www.devcheng.net/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>并发锁知识点</title>
    <link href="http://www.devcheng.net/post/2a798f18.html"/>
    <id>http://www.devcheng.net/post/2a798f18.html</id>
    <published>2020-10-23T13:31:56.000Z</published>
    <updated>2020-10-23T13:41:01.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="悲观锁：synchronized"><a href="#悲观锁：synchronized" class="headerlink" title="悲观锁：synchronized"></a>悲观锁：synchronized</h2><p>Synchronized互斥锁属于悲观锁，它有一个明显的缺点，它不管数据存不存在竞争都加锁，随着并发量增加，且如果锁的时间比较长，其性能开销将会变得很大。</p><p>每个对象头中分为两部分：一部分是自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。一部分是类型指针，即是对象指向它的类的元数据的指针。</p><p>而对象的锁(monitor)就在对象头中，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p><p>而其他想要获取该锁只能阻塞，一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，需要消耗很多处理器时间</p><h3 id="特性：互斥锁、非公平锁、可重入、不可中断"><a href="#特性：互斥锁、非公平锁、可重入、不可中断" class="headerlink" title="特性：互斥锁、非公平锁、可重入、不可中断"></a>特性：互斥锁、非公平锁、可重入、不可中断</h3><h3 id="优点：实现简单"><a href="#优点：实现简单" class="headerlink" title="优点：实现简单"></a>优点：实现简单</h3><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>不管数据存不存在竞争都加锁，随着并发量增加，且如果锁的时间比较长，其性能开销将会变得很大</li><li>不可中断，在所有等待的线程中，synchronized无法帮你中断此任务</li><li>互斥锁在获取锁失败后将进入睡眠或阻塞状态</li></ul><h2 id="乐观锁：CAS-compare-and-swap-比较并交换"><a href="#乐观锁：CAS-compare-and-swap-比较并交换" class="headerlink" title="乐观锁：CAS( compare and swap,比较并交换)"></a>乐观锁：CAS( compare and swap,比较并交换)</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据。</p><p>乐观锁的核心算法是CAS（Compare and Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。</p><p>这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。</p><p><strong>优点：</strong> 高并发性能，jdk中的并发包也大量使用基于CAS的乐观锁。</p><p><strong>缺点：</strong></p><ul><li>乐观锁只能保证一个共享变量的原子操作</li><li>长时间自旋可能导致开销大</li><li>ABA问题。</li></ul><p>CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</p><h2 id="同步器：AQS-AbstractQueuedSynchronizer"><a href="#同步器：AQS-AbstractQueuedSynchronizer" class="headerlink" title="同步器：AQS(AbstractQueuedSynchronizer)"></a>同步器：AQS(AbstractQueuedSynchronizer)</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>它为不同场景提供了实现锁及同步机制的基本框架，为同步状态的原子性管理、线程的阻塞、线程的解除阻塞及排队管理提供了一种通用的机制。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>ASQ将线程封装到一个Node里面，并维护一个CHL Node FIFO队列，它是一个非阻塞的FIFO队列，也就是说在并发条件下往此队列做插入或移除操作不会阻塞，是通过自旋锁和CAS保证节点插入和移除的原子性，实现无锁快速插入。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul><li>独占模式state的值只能为0或1</li><li>共享模式的state是可以被出事换成任意整数，一般初始值表示提供一个同时n条线程通过的管道宽度，这样一来，多条线程通过tryAcquireShared尝试将state的值减去1，成功修改state后就返回新值，只有当新值大于等于0才表示获取锁成功，拥有往下执行的权利，进入管道。在执行完毕时线程将调用tryReleaseShared尝试修改state值使之增加1。</li><li>表示我已经执行完了并让出管道的通道供后面线程使用，需要说明的是与独占模式不同，由于可能存在多条线程并发释放锁，所以此处必须使用基于CAS算法的修改方法，修改成功后其他线程便可继续竞争锁。</li><li>独占式：只容许一个线程通过的管道，在这种模式下线程只能逐一通过管道，任意时刻管内只能存在一条线程，这便形成了互斥效果。</li><li>共享式：共享模式就是管道宽度大于1的管道，可以同时让n条管道通过，吞吐量增加但可能存在共享数据一致性问题。</li></ul><h2 id="阻塞唤醒三种方式："><a href="#阻塞唤醒三种方式：" class="headerlink" title="阻塞唤醒三种方式："></a>阻塞唤醒三种方式：</h2><ul><li>suspend与resume：存在无法解决的竟态问题而被Java废弃</li><li>wait与notify：这两个方法必须存在于synchronized中，存在竟态条件，wait必须在notify之前执行，假如一个线程先执行notify再执行wait将可能导致一个线程永远阻塞</li><li>await与singal: Condition类提供，而Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使用Lock锁后无法使用wait方法<h3 id="wait与await区别："><a href="#wait与await区别：" class="headerlink" title="wait与await区别："></a>wait与await区别：</h3></li><li>wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放</li><li>因为Lock没有使用synchronized机制，故无法使用wait方法区操作多线程，所以使用了Condition的await来操作</li><li>park与unpark：由LockSupport类提供，底层调用的是Unsafe类的方法，由于park与unpark使用的是许可机制，许可最大为1，所以unpark与park操作不会累加，而且unpark可以在park之前执行，如unpark先执行，后面park将不阻塞。</li><li>Lock实现主要是基于AQS，而AQS实现则是基于LockSupport，所以说LockSupport更底层，所以不建议使用park和unpark去阻塞和唤醒线程</li></ul><h2 id="Java内部有两种锁机制"><a href="#Java内部有两种锁机制" class="headerlink" title="Java内部有两种锁机制:"></a>Java内部有两种锁机制:</h2><h3 id="1-synchonized"><a href="#1-synchonized" class="headerlink" title="1.synchonized"></a>1.synchonized</h3><h3 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2.Lock"></a>2.Lock</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><h4 id="实现机制不同"><a href="#实现机制不同" class="headerlink" title="实现机制不同"></a>实现机制不同</h4><ul><li>synchonrized 分为两种 程序段的synchonized是通过monitor.enter monitor.exit来实现的，方法和类级别的则是通过设置实例或者类的锁字段来实现</li><li>Lock的实现方式则是通过AQS。AQS是一个线程的链表，负责维护线程的状态，以及线程的调度，AQS也是一个锁 保证同一时间获取AQS锁的线程只有一个，也就是下面的Nodestatus为runnning的只有一个(为什么不是同一时间运行的线程只有一个呢?线程在申请锁的时候先加入队列然后挂起，并且在公平竞争时所有的线程都会别唤醒 )</li></ul><h3 id="synchronized-同步锁"><a href="#synchronized-同步锁" class="headerlink" title="synchronized    同步锁"></a>synchronized    同步锁</h3><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>任何一个对象都一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p>MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p><p>这时如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，需要消耗很多处理器时间。如果可能，应该减少这样的切换，jvm一般会采取一些措施进行优化，例如在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。</p><h4 id="Java中每一个对象都可以作为锁，这是synchronized实现同步的基础："><a href="#Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：" class="headerlink" title="Java中每一个对象都可以作为锁，这是synchronized实现同步的基础："></a>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</h4><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li><li>javap工具查看生成的class文件信息来分析Synchronize的实现</li><li>同步代码块：</li></ul><p>monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p><p>同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。</p><h4 id="Java对象头和monitor是实现synchronized的基础"><a href="#Java对象头和monitor是实现synchronized的基础" class="headerlink" title="Java对象头和monitor是实现synchronized的基础"></a>Java对象头和monitor是实现synchronized的基础</h4><h3 id="特性：互斥锁、非公平锁、可重入、不可中断、使用简单"><a href="#特性：互斥锁、非公平锁、可重入、不可中断、使用简单" class="headerlink" title="特性：互斥锁、非公平锁、可重入、不可中断、使用简单"></a>特性：互斥锁、非公平锁、可重入、不可中断、使用简单</h3><h3 id="性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。"><a href="#性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。" class="headerlink" title="性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。"></a>性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。</h3><p><strong>Lock锁实现：</strong></p><h3 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock    重入锁"></a>ReentrantLock    重入锁</h3><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>ReentrantLock是Lock接口的实现类。Lock接口的核心方法是lock()，unlock()，tryLock()。可用Condition来操作线程，await()和object.wait()类似，singal()和object.notify()类似，singalAll()和object.notifyAll()类似。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>核心类AbstractQueuedSynchronizer，通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</p><h4 id="特性：公平锁-定时锁-有条件锁-可轮询锁-可中断锁-可以有效避免死锁的问题"><a href="#特性：公平锁-定时锁-有条件锁-可轮询锁-可中断锁-可以有效避免死锁的问题" class="headerlink" title="特性：公平锁, 定时锁, 有条件锁, 可轮询锁, 可中断锁. 可以有效避免死锁的问题"></a>特性：公平锁, 定时锁, 有条件锁, 可轮询锁, 可中断锁. 可以有效避免死锁的问题</h4><h4 id="性能和建议：性能中等，建议需要手动操作线程时使用。"><a href="#性能和建议：性能中等，建议需要手动操作线程时使用。" class="headerlink" title="性能和建议：性能中等，建议需要手动操作线程时使用。"></a>性能和建议：性能中等，建议需要手动操作线程时使用。</h4><h3 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock    读写锁"></a>ReentrantReadWriteLock    读写锁</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>它允许多个线程读某个资源，但每次只允许一个线程来写。ReadWriteLock接口的核心方法是readLock()，writeLock()。实现了并发读、互斥写。但读锁会阻塞写锁，是悲观锁的策略。</p><p>当多个线程读取有个变量时可以使用读锁rwl.readLock().lock();，如果需要去修改某个变量时则可以上写锁rwl.writeLock().lock();//上写锁，不允许其他线程读也不允许写</p><p>与重入锁比较，其实现原理一致，但是读写锁更适合读多写少的场景，因为读读共享，而重入锁全互斥</p><p><strong>StampedLock</strong></p><p>时间戳锁(jdk1.8改进的读写锁)</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>写锁的改进，它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写，在读的时候如果发生了写，则应当重读而不是在读的时候直接阻塞写！</p><h4 id="时间戳锁与读写锁比较"><a href="#时间戳锁与读写锁比较" class="headerlink" title="时间戳锁与读写锁比较"></a>时间戳锁与读写锁比较</h4><p>读锁不阻塞写锁，如果时间戳无效，则重新读取变量值。无ABA问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;悲观锁：synchronized&quot;&gt;&lt;a href=&quot;#悲观锁：synchronized&quot; class=&quot;headerlink&quot; title=&quot;悲观锁：synchronized&quot;&gt;&lt;/a&gt;悲观锁：synchronized&lt;/h2&gt;&lt;p&gt;Synchronized互斥
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="并发锁" scheme="http://www.devcheng.net/tags/%E5%B9%B6%E5%8F%91%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringBoot开发图书管理系统源码分享</title>
    <link href="http://www.devcheng.net/post/931cd25c.html"/>
    <id>http://www.devcheng.net/post/931cd25c.html</id>
    <published>2020-10-06T13:32:33.000Z</published>
    <updated>2020-12-26T05:56:52.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚入门SpringBoot的朋友！</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a><strong>功能描述</strong></h2><p>项目分为管理员和非管理员两种角色，其中非管理员包含：教师和学生。</p><p>在项目中管理员主要拥有的功能有：书籍管理（图书管理、借书审核、查看已借出书籍、查看换书），用户管理（学生管理、教师管理），部门管理（班级管理、学院管理），设置（修改密码、查看个人信息、操作日志、退出）。</p><p>在项目非管理员拥有的功能：借阅图书管理（借书、已借书及还书、正审核的图书），设置（修改密码、查看个人信息、退出）。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><ul><li>系统环境：Windows 10</li><li>开发工具：IntelliJ IDEA</li><li>Java版本：JDK 1.8</li></ul><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot 2.0.6.RELEASE</li><li>SpringDataJpa</li><li>Maven 3.X</li><li>Bootstarp</li><li>EasyUI</li><li>Mysql</li><li>thymeleaf</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>管理员账户和密码： admin6 / admin6</p><p>学生账户和密码：  guliduo / guliduo</p><h2 id="系统展示图"><a href="#系统展示图" class="headerlink" title="系统展示图"></a><strong>系统展示图</strong></h2><p><img src="/images/book01.png" alt="“伊成博客”"></p><p><img src="/images/book02.png" alt="“伊成博客”"></p><p><img src="/images/book03.png" alt="“伊成博客”"></p><p><img src="/images/book04.png" alt="“伊成博客”"></p><p><img src="/images/book05.png" alt="“伊成博客”"></p><p><img src="/images/book06.png" alt="“伊成博客”"></p><p><img src="/images/book07.png" alt="“伊成博客”"></p><p><img src="/images/book08.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！ 备注：图书管理系统</p><h2 id="项目演示视频"><a href="#项目演示视频" class="headerlink" title="项目演示视频"></a><strong>项目演示视频</strong></h2><p>链接: <a href="https://pan.baidu.com/s/1UDY8uH167xUUttXKrDMF3A" target="_blank" rel="noopener">https://pan.baidu.com/s/1UDY8uH167xUUttXKrDMF3A</a> </p><p>提取码: hjhi</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖怪请绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="在线图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Class org.springframework.util.ReflectionUtils can not access a member of class异常</title>
    <link href="http://www.devcheng.net/post/50c55201.html"/>
    <id>http://www.devcheng.net/post/50c55201.html</id>
    <published>2020-09-28T09:34:25.000Z</published>
    <updated>2020-09-28T09:57:08.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-09-25 14:02:03.393 ERROR 13920 --- [nio-8400-exec-3] c.s.b.d.support.utils.ExceptionUtils :</span><br><span class="line"> Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of class com.xxx.model.entity.XxxEntity with modifiers &quot;private&quot;; </span><br><span class="line"> nested exception is java.lang.IllegalStateException: Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of </span><br><span class="line"> class com.xxx.Entity with modifiers &quot;private&quot;</span><br></pre></td></tr></table></figure><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>为了完整的说明这个异常，简单的看一下代码：</p><p><strong>Entity 类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.reflect;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private void add()&#123;</span><br><span class="line">        System.out.println(&quot;add method...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接运行 main 方法则会报这个异常 Class . can not access a member of class . with modifiers “private” 。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置Field对象的Accessible的访问标志位为Ture，就可以通过反射获取私有变量的值，在访问时会忽略访问修饰符的检查。</p><p>所以只需要加上这行代码即可！</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">method.setAccessible(true); // 加上这句即可解决问题！</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="异常" scheme="http://www.devcheng.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.devcheng.net/post/c72647c7.html"/>
    <id>http://www.devcheng.net/post/c72647c7.html</id>
    <published>2020-09-25T12:53:55.000Z</published>
    <updated>2020-09-25T13:03:42.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大白话之乐观锁和悲观锁"><a href="#大白话之乐观锁和悲观锁" class="headerlink" title="大白话之乐观锁和悲观锁"></a>大白话之乐观锁和悲观锁</h2><p>用大白话解释什么是乐观锁好悲观锁如下：</p><p>乐观锁对应于生活中乐观的人总是想着事情会往好的方向发展。</p><p>悲观锁对应于生活中悲观的人总是想着事情会往坏的方向发展。</p><h3 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁 (Optimistic Locking)"></a>乐观锁 (Optimistic Locking)</h3><p>假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><h3 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁 (Pessimistic Lock)"></a>悲观锁 (Pessimistic Lock)</h3><p>悲观其实是我们人类一种消极的情绪，对应到锁的悲观情绪，悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后（可以理解为一个用户），其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁以及 Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>悲观锁一般多写的场景下</strong>用就比较合适。</p><h2 id="乐观的两种实现方式"><a href="#乐观的两种实现方式" class="headerlink" title="乐观的两种实现方式"></a>乐观的两种实现方式</h2><ul><li>版本号机制<br>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ul><p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>1.操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（100-$50 ）。</p><p>2.在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（100-$20 ）。</p><p>3.操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</p><p>4.操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</p><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><ul><li>CAS算法<br>即<strong>compare and swap</strong>（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</li></ul><p>CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li><li>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。</li></ul><p>一般情况下是一个自旋操作，即不断的重试。</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><p>ABA 问题是乐观锁一个常见的问题。</p><p><strong>1 ABA 问题</strong></p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p><p>这个问题被称为CAS操作的 <strong>“ABA”问题</strong>。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少）<br>synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；<br>而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由上文的介绍，相信大家都有一定的认识了，在实际工作中如何选择得需要看对应的业务场景，但随着互联网三高架构(高并发、高性能、高可用)的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#大白话之乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;/a&gt;大白话之乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;用大白话解释什么是乐观锁好悲观锁如下：&lt;/p&gt;
&lt;p&gt;乐观锁对应于生
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="乐观锁" scheme="http://www.devcheng.net/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://www.devcheng.net/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如果面试官问你“你有什么问题问我吗？”时，你该如何回答</title>
    <link href="http://www.devcheng.net/post/185dcb3e.html"/>
    <id>http://www.devcheng.net/post/185dcb3e.html</id>
    <published>2020-09-22T13:35:33.000Z</published>
    <updated>2020-09-22T14:05:06.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。</p><p>这个时候很多人内心就会陷入短暂的纠结中：我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？</p><h2 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h2><p>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。</p><p>我说这些并不代表你就可以直接对面试官说：“我没问题了。”，个人当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。</p><p>面试本身就是一个双向选择的过程，你对这个问题的回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</p><p>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化。</p><p>我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</p><p>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</p><p>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</p><h2 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h2><p>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。</p><p>面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。</p><p>总的来说，还是要真诚。</p><p>除此之外，不要问太 Low 的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不上心，既然你不上心，为什么要要你呢）。</p><p>举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：</p><ul><li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li><li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li><li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li><li>……</li></ul><h2 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h2><p>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</p><p><strong>面对HR或者其他Level比较低的面试官时</strong></p><p><strong>1.能不能谈谈你作为一个公司老员工对公司的感受?</strong> (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</p><p><strong>2.能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？有什么地方你觉得还不太好或者可以继续完善吗？</strong> （类似第一个问题，都是问面试官个人对于公司的看法。）</p><p><strong>3.我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</p><p><strong>4.接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</strong> （体现出你对工作比较上心，自助学习意识比较强。）</p><p><strong>5.这个岗位为什么还在招人？</strong> (岗位真实性和价值咨询)</p><p><strong>6.大概什么时候能给我回复呢？</strong>(终面的时候，如果面试官没有说的话，可以问一下)</p><p><strong>7…….</strong></p><p><strong>面对部门领导</strong></p><p><strong>1.部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong></p><p><strong>2.未来如果我要加入这个团队，你对我的期望是什么？</strong> （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</p><p><strong>3.公司对新入职的员工的培养机制是什么样的呢？</strong>（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</p><p><strong>4.以您来看，这个岗位未来在公司内部的发展如何？</strong> (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</p><p><strong>5.团队现在面临的最大挑战是什么？</strong> (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</p><p><strong>面对Level比较高的(比如总裁,老板)</strong></p><p><strong>1.贵公司的发展目标和方向是什么？</strong> （看下公司的发展是否满足自己的期望）</p><p><strong>2.与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong> （充分了解自己的优势和劣势）</p><p><strong>3.公司现在面临的最大挑战是什么？</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯定是觉得你就是他们要招的人。</p><p>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。</p><p>上面提到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！</p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="面试" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试经验" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>你是否因为命名被diss过？</title>
    <link href="http://www.devcheng.net/post/18c03ab9.html"/>
    <id>http://www.devcheng.net/post/18c03ab9.html</id>
    <published>2020-09-18T10:56:03.000Z</published>
    <updated>2020-09-18T11:27:16.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。<br>就连世界级软件大师 Martin Fowler 大神都说过 CS 领域有两大最难的事情，一是缓存失效，一是程序命名。</p><p><img src="/images/marting-naming-1.png" alt="&quot;伊成博客&quot;"></p><h2 id="为什么需要重视命名"><a href="#为什么需要重视命名" class="headerlink" title="为什么需要重视命名"></a>为什么需要重视命名</h2><p><strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！</strong></p><p>好的命名对于其他人（包括你自己）理解你的代码有着很大的帮助！</p><p>简单举个例子说明一下命名的重要性。</p><p>《Clean Code》这本书明确指出：</p><p>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p><p>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</p><p>举个栗子：</p><p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// check to see if the employee is eligible for full benefits</span><br><span class="line">if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))</span><br></pre></td></tr></table></figure><p>应替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure><h2 id="常见命名规则以及适用场景"><a href="#常见命名规则以及适用场景" class="headerlink" title="常见命名规则以及适用场景"></a>常见命名规则以及适用场景</h2><p>这里只介绍 3 种最常见的命名规范。</p><h3 id="驼峰命名法（CamelCase）"><a href="#驼峰命名法（CamelCase）" class="headerlink" title="驼峰命名法（CamelCase）"></a>驼峰命名法（CamelCase）</h3><p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p><h4 id="大驼峰命名法（CamelCase）"><a href="#大驼峰命名法（CamelCase）" class="headerlink" title="大驼峰命名法（CamelCase）"></a>大驼峰命名法（CamelCase）</h4><ul><li>类名需要使用大驼峰命名法（UpperCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceDiscovery、ServiceInstance、LruCacheFactory</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceDiscovery、Serviceinstance、LRUCacheFactory</span><br></pre></td></tr></table></figure><h4 id="小驼峰命名法（lowerCamelCase）"><a href="#小驼峰命名法（lowerCamelCase）" class="headerlink" title="小驼峰命名法（lowerCamelCase）"></a>小驼峰命名法（lowerCamelCase）</h4><ul><li>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getUserInfo()、createCustomThreadPool()、setNameFormat(String nameFormat)</span><br><span class="line">Uservice userService;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat)</span><br><span class="line">Uservice user_service</span><br></pre></td></tr></table></figure></p><h3 id="蛇形命名法（snake-case）"><a href="#蛇形命名法（snake-case）" class="headerlink" title="蛇形命名法（snake_case）"></a>蛇形命名法（snake_case）</h3><ul><li>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</li></ul><p>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。</p><p>蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下： “shouldGet200StatusCodoWhenRequestIsValid”。</p><p>感觉如何？ </p><p><strong>相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</strong></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void should_get_200_status_code_when_request_is_valid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void shouldGet200StatusCodoWhenRequestIsValid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串式命名法（kebab-case）"><a href="#串式命名法（kebab-case）" class="headerlink" title="串式命名法（kebab-case）"></a>串式命名法（kebab-case）</h3><ul><li>在串式命名法中，各个单词之间通过下划线“-”连接，比如dubbo-registry。</li></ul><p>建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。<br><img src="/images/dubbo-naming-2.png" alt="&quot;伊成博客&quot;"></p><h2 id="常见命名规范"><a href="#常见命名规范" class="headerlink" title="常见命名规范"></a>常见命名规范</h2><h3 id="Java-语言基本命名规范"><a href="#Java-语言基本命名规范" class="headerlink" title="Java 语言基本命名规范"></a>Java 语言基本命名规范</h3><p><strong>1.类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p><p><strong>2.测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong>，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。并且，<strong>测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</strong></p><p><strong>3.项目文件夹名称使用串式命名法（kebab-case）</strong>，比如dubbo-registry。</p><p><strong>4.包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连接，并且各个单词必须为单数。</strong></p><p>正例： org.apache.dubbo.common.threadlocal</p><p>反例： <del>org.apache.dubbo.common.threadLocal</del></p><p><strong>5.抽象类命名使用 Abstract 开头。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）</span><br><span class="line">public abstract class AbstractClient extends AbstractEndpoint implements Client &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>6.异常类命名使用 Exception 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义的 NoSuchMethodException（出处：Dubbo源码）</span><br><span class="line">public class NoSuchMethodException extends RuntimeException &#123;</span><br><span class="line">    private static final long serialVersionUID = -2725364246023268766L;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7.测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）</span><br><span class="line">public class AnnotationUtilsTest &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><h3 id="命名易读性规范"><a href="#命名易读性规范" class="headerlink" title="命名易读性规范"></a>命名易读性规范</h3><p><strong>1.为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。</strong><br>比如 CustomThreadFactory 不可以被写成 <del>CustomTF</del> 。</p><p><strong>2.命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。</strong> 这个对应我们上面说的第 1 点。</p><p><strong>3.避免无意义的命名</strong>，你起的每一个名字都要能表明意思。</p><p>正例：UserService userService; int userCount;</p><p>反例: <del>UserService service int count</del></p><p><strong>4.避免命名过长（50 个字符以内最好）</strong>，过长的命名难以阅读并且丑陋。</p><p><strong>5.不要使用拼音，更不要使用中文。</strong> 注意：像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。</p><p>正例：discount</p><p>反例：<del>dazhe</del></p><h2 id="Codelf-变量命名神器"><a href="#Codelf-变量命名神器" class="headerlink" title="Codelf:变量命名神器?"></a>Codelf:变量命名神器?</h2><p>这是一个由国人开发的网站，网上有很多人称其为变量命名神器，大家可以自行体验一下，然后再给出自己的判断。</p><p>Codelf 提供了在线网站版本，网址：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">https://unbug.github.io/codelf/</a></p><p>具体使用情况如下：</p><p>我选择了 Java 编程语言，然后搜索了“序列化”这个关键词，然后它就返回了很多关于序列化的命名。</p><p><img src="/images/dubbo-naming-3.png" alt="&quot;伊成博客&quot;"></p><p>并且，Codelf 还提供了 VS code 插件，看这个评价，看来大家还是很喜欢这款命名工具的。</p><p><img src="/images/dubbo-naming-4.png" alt="&quot;伊成博客&quot;"></p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。&lt;br&gt;就连世界级软件大师 M
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="变量命名" scheme="http://www.devcheng.net/tags/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
</feed>
