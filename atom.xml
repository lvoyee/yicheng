<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2021-01-03T07:12:02.349Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL优化干货总结</title>
    <link href="http://www.devcheng.net/post/991a821e.html"/>
    <id>http://www.devcheng.net/post/991a821e.html</id>
    <published>2021-01-03T06:45:54.000Z</published>
    <updated>2021-01-03T07:12:02.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？”。<br>SQL优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，如果是你，在这个问题上能吊打面试官还是会被吊打呢？</p><h2 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h2><h3 id="SELECT语句-语法顺序"><a href="#SELECT语句-语法顺序" class="headerlink" title="SELECT语句 - 语法顺序"></a>SELECT语句 - 语法顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. SELECT </span><br><span class="line">2. DISTINCT &lt;select_list&gt;</span><br><span class="line">3. FROM &lt;left_table&gt;</span><br><span class="line">4. &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">5. ON &lt;join_condition&gt;</span><br><span class="line">6. WHERE &lt;where_condition&gt;</span><br><span class="line">7. GROUP BY &lt;group_by_list&gt;</span><br><span class="line">8. HAVING &lt;having_condition&gt;</span><br><span class="line">9. ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">10.LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>Tips:以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准。</p><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h2><h3 id="避免不走索引的场景"><a href="#避免不走索引的场景" class="headerlink" title="避免不走索引的场景"></a>避免不走索引的场景</h3><ol><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;%陈%&apos;</span><br></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;陈%&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量避免使用in 和not in，会导致引擎走全表扫描</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id IN (2,3)</span><br></pre></td></tr></table></figure><p>优化方式：如果是连续数值，可以用between代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id BETWEEN 2 AND 3</span><br></pre></td></tr></table></figure><p>如果是子查询，可以用exists代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 不走索引</span><br><span class="line">select * from A where A.id in (select id from B);</span><br><span class="line">-- 走索引</span><br><span class="line">select * from A where exists (select * from B where B.id = A.id);</span><br></pre></td></tr></table></figure><ol start="3"><li>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1 OR id = 3</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：可以用union代替or。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM student WHERE id = 3</span><br></pre></td></tr></table></figure><p>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score IS NUL</span><br></pre></td></tr></table></figure></p><p>优化方式：可以给字段添加默认值0，对0值进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score = 0</span><br></pre></td></tr></table></figure><p>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。<br>可以将表达式、函数操作移动到等号右侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">SELECT * FROM T WHERE score/10 = 9</span><br><span class="line">-- 走索引</span><br><span class="line">SELECT * FROM T WHERE score = 10*9</span><br></pre></td></tr></table></figure></p><ol start="6"><li>当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username, age, sex FROM T WHERE 1=1</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。</p><ol start="7"><li>查询条件不能用 &lt;&gt; 或者 != 使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</li></ol><ol start="8"><li><p>where条件仅包含复合索引非前置列<br>复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where key_part2=1 and key_part3=2</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换造成不使用索引<br>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where col_varchar=123;</span><br></pre></td></tr></table></figure></li><li><p>order by 条件要与where中条件一致，否则order by不会利用索引进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 不走age索引</span><br><span class="line">SELECT * FROM student order by age;</span><br><span class="line"> </span><br><span class="line">-- 走age索引</span><br><span class="line">SELECT * FROM student where age &gt; 0 order by age;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SELECT语句其他优化"><a href="#SELECT语句其他优化" class="headerlink" title="SELECT语句其他优化"></a>SELECT语句其他优化</h2><ol><li>避免出现select *</li><li>避免出现不确定结果的函数</li><li>多表关联查询时，小表在前，大表在后。</li><li>使用表的别名</li><li>用where字句替换HAVING字句</li><li>调整Where字句中的连接顺序</li></ol><h2 id="查询条件优化"><a href="#查询条件优化" class="headerlink" title="查询条件优化"></a>查询条件优化</h2><ol><li>对于复杂的查询，可以使用中间临时表 暂存数据</li></ol><ol start="2"><li><p>优化group by语句<br>默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。<br>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：<br>SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;</p></li><li><p>优化join语句<br>MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。<br>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：<br>SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )<br>如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM customerinfo </span><br><span class="line">   LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID </span><br><span class="line">      WHERE salesinfo.CustomerID IS NULL</span><br></pre></td></tr></table></figure><p>连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><ol start="4"><li>优化union查询<br>MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。<br>高效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION ALL </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>低效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></p><p>5.拆分复杂SQL为多个小SQL，避免大事务<br>简单的SQL容易使用到MySQL的QUERY CACHE；<br>减少锁表时间特别是使用MyISAM存储引擎的表；可以使用多核CPU。</p><p>6.使用truncate代替delete<br>当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。<br>使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。</p><h2 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h2><p>1.在表中建立索引，优先考虑where、order by使用到的字段。</p><ol start="2"><li>尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</li></ol><p>3.查询数据量大的表 会造成查询缓慢。</p><p>4.用varchar/nvarchar 代替 char/nchar<br>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id="The-end"><a href="#The-end" class="headerlink" title="The end ."></a>The end .</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL优化" scheme="http://www.devcheng.net/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker踩坑学习笔记</title>
    <link href="http://www.devcheng.net/post/53539811.html"/>
    <id>http://www.devcheng.net/post/53539811.html</id>
    <published>2020-12-25T15:13:25.000Z</published>
    <updated>2020-12-25T15:24:19.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>安装完成功docker后，如何在容器中安装JDK、TOMCAT。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search jdk </span><br><span class="line"></span><br><span class="line">docker install jdk_open...</span><br></pre></td></tr></table></figure><h2 id="docker中如何挂载文件"><a href="#docker中如何挂载文件" class="headerlink" title="docker中如何挂载文件"></a>docker中如何挂载文件</h2><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>上传压缩文件到服务器，这种方式需要将服务器上的文件挂载到docker 容器中。<br>docker可以支持把一个宿主机上的目录挂载在docker容器中（镜像）。</p><p>tips:要把宿主机文件挂载在容器中，此时，身份是 宿主机中<br>找到要被挂载文件的目录</p><p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径</p><p>执行</p><p><img src="/images/devcheng_net_docker_1clipboard.png" alt="image-20200629094621998"></p><p>挂载成功</p><p><img src="/images/devcheng_net_docker_2clipboard.png" alt="image-20200629094621998"></p><p>解压jdk </p><p>此时会遇到权限不够的问题</p><p>操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.退出容器</span><br><span class="line">2. 执行 su -c &quot;setenforce 0&quot;</span><br><span class="line">3.dorcker run -i -t centos /bin/bash</span><br></pre></td></tr></table></figure></p><p>重新解压即可！<br>相关解决链接：<a href="http://www.cnblogs.com/adamas21/p/6280297.html" target="_blank" rel="noopener">http://www.cnblogs.com/adamas21/p/6280297.html</a></p><p>启动docker web服务时,虚拟机端口转发外部无法访问?可参考以下链接：<br><a href="http://blog.csdn.net/u014062332/article/details/52911405" target="_blank" rel="noopener">http://blog.csdn.net/u014062332/article/details/52911405</a></p><h3 id="jdk的配置"><a href="#jdk的配置" class="headerlink" title="jdk的配置"></a>jdk的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下配置</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_121</span><br><span class="line">export JRE_HOME=/usr/java/jdk1.8.0_121/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br></pre></td></tr></table></figure><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end."></a>The end.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;安装完成功docker后，如何在容器中安装JDK、TOMCAT。&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="docker" scheme="http://www.devcheng.net/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://www.devcheng.net/post/43a71ae4.html"/>
    <id>http://www.devcheng.net/post/43a71ae4.html</id>
    <published>2020-11-29T10:53:46.000Z</published>
    <updated>2020-11-29T11:02:03.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>最典型的例子就是查新华字典，通过查找目录快速定位到查找的字</p><ul><li>大大减少了服务器需要扫描的数量</li><li>帮助服务器避免排序和临时表</li><li>将IO变成顺序IO<ul><li>尽可能的降低磁盘的寻址时间，也就是局部性原理，就是很大一部分数据在未来的一段时间被连续访问</li><li>在复制1G压缩包 和 1G小文件，前者的速度会大于后者</li><li>减少IO的量，例如写SQL语句的时候，不要写 select *</li><li>减少IO的次数，一次IO能搞定的事，不使用3次IO</li></ul></li></ul><h2 id="索引的用处"><a href="#索引的用处" class="headerlink" title="索引的用处"></a>索引的用处</h2><ul><li>快速查找匹配where子句的行</li><li>从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用栈找到最少行的索引</li><li>如果表具有多列索引，则优化器可以使用索引的最左匹配前缀来查找</li><li>当有表连接的时候，从其他表检测行数据</li><li>查找特定索引列min或max值</li><li>如果排序或分组是，在可用索引的最左前缀上完成的，则对表进行排序和分组</li><li>在某些清空下，可以优化查询以检索值而无需查询数据行</li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>如果你在创建索引的时候，使用的是主键这个值，那么就是主键索引，primary key</p><p>我们建表的时候，例如下面这个建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_blog_sort`</span> (</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'唯一uid'</span>,</span><br><span class="line">  <span class="string">`sort_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类内容'</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类简介'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0000-00-00 00:00:00'</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  <span class="string">`status`</span> tinyint(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态'</span>,</span><br><span class="line">  <span class="string">`sort`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'排序字段，越大越靠前'</span>,</span><br><span class="line">  <span class="string">`click_count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'点击数'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'博客分类表'</span>;</span><br></pre></td></tr></table></figure><p>这里面有使用到    PRIMARY KEY (<code>uid</code>)，这就是主键索引</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引 类似于普通索引，索引列的值必须唯一</p><p>唯一索引和主键索引的区别就是，唯一索引允许出现空值，而主键索引不能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique index_name column</span><br></pre></td></tr></table></figure><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>当我们需要建立索引的字段，既不是主键索引，也不是唯一索引</p><p>那么就可以创建一个普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  index_name <span class="keyword">on</span> <span class="keyword">table</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>或者创建表时指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>(..., <span class="keyword">index</span> index_name <span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>lunce、solr和ElasticSearch就是做全文检索的，里面涉及到了倒排索引的概念，mysql很少使用全文索引。</p><p>要用来查找文本中的关键字，不是直接与索引中的值相比较，像是一个搜索引擎，配合 match against 使用，现在只有char，varchar，text上可以创建索引，在数据量比较大时，先将数据放在一个没有全文索引的表里，然后在利用create index创建全文索引，比先生成全文索引在插入数据快很多。</p><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>目前，在业务不是特别复杂的时候，可能使用一个列作为索引，或者直接采用主键索引即可，但是如果业务变得复杂的时候，就需要用到组合索引，通过对多个列建立索引。</p><p>组合索引的用处，假设我现在表有个多个字段：id、name、age、gender，然后我经常使用以下的查询条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'xx'</span> <span class="keyword">and</span> age = xx</span><br></pre></td></tr></table></figure><p>这个时候，我们就可以通过组合 name 和 age 来建立一个组合索引，加快查询效率，建立成组合索引后，我的索引将包含两个key值</p><p>在多个字段上创建索引，遵循<strong>最左匹配</strong>原则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> index_name(a,b,c);</span><br></pre></td></tr></table></figure><h2 id="索引的使用与否"><a href="#索引的使用与否" class="headerlink" title="索引的使用与否"></a>索引的使用与否</h2><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>MySQL每次只使用一个索引，与其说 数据库查询只能用一个索引，倒不如说，和全表扫描比起来，去分析两个索引 B+树更耗费时间，所以where A=a and B=b 这种查询使用（A，B）的组合索引最佳，B+树根据（A，B）来排序。</p><ul><li>主键，unique字段</li><li>和其他表做连接的字段需要加索引</li><li>在where 里使用 &gt;, &gt;=, = , &lt;, &lt;=, is null 和 between等字段。</li><li>使用不以通配符开始的like，where A like ‘China%’</li><li>聚合函数里面的 MIN()， MAX()的字段</li><li>order by  和 group by字段</li></ul><h3 id="何时不使用索引"><a href="#何时不使用索引" class="headerlink" title="何时不使用索引"></a>何时不使用索引</h3><ul><li>表记录太少</li><li>数据重复且分布平均的字段（只有很少数据的列）；</li><li>经常插入、删除、修改的表要减少索引</li><li>text，image 等类型不应该建立索引，这些列的数据量大（加入text的前10个字符唯一，也可以对text前10个字符建立索引）</li><li>MySQL能估计出全表扫描比使用索引更快的时候，不使用索引</li></ul><h3 id="索引何时失效"><a href="#索引何时失效" class="headerlink" title="索引何时失效"></a>索引何时失效</h3><ul><li>组合索引为使用最左前缀，例如组合索引（A，B），where B = b 不会使用索引</li><li>like未使用最左前缀，where A  like “%China”</li><li>搜索一个索引而在另一个索引上做 order by， where A = a order by B，只会使用A上的索引，因为查询只使用一个索引。</li><li>or会使索引失效。如果查询字段相同，也可以使用索引。例如  where A = a1 or A = a2（生效），where A=a or B = b （失效）</li><li>在索引列上的操作，函数upper()等，or、！ = （&lt;&gt;）,not in 等</li></ul><h2 id="面试技术名词"><a href="#面试技术名词" class="headerlink" title="面试技术名词"></a>面试技术名词</h2><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>首先我们需要知道，我们建立几个索引，就会生成几棵B+Tree，但是带有原始数据行的B+Tree只有一棵，另外一棵树上的叶子节点带的是主键值。</p><p>例如，我们通过主键建立了主键索引，然后在叶子节点上存放的是我们的数据</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094621998.png" alt="image-20200629094621998"></p><p>当我们创建了两个索引时，一个是主键，一个是name，它还会在生成一棵B+Tree，这棵树的叶子节点存放的是主键，当我们通过name进行查找的时候，会得到一个主键，然后在通过主键再去上面的这个主键B+Tree中进行查找，我们称这个操作为 ==<strong>回表</strong>==</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p><p>当我们的SQL语句使用的是下面这种的时候，它会查找第一颗树，直接返回我们的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb where id = 1</span><br></pre></td></tr></table></figure><p>当我们使用下面这种查询的时候，它会先查找第二棵树得到我们的主键，然后拿着主键再去查询第一棵树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb  where name = &apos;gang&apos;</span><br></pre></td></tr></table></figure><p>回表就是通过普通列的索引进行检索，然后再去主键列进行检索，这个操作就是回表</p><p>==但是我们在使用检索的时候，尽量避免回表，因为这会造成两次B+Tree的查询，假设一次B+Tree查询需要三次IO操作，那么查询两次B+Tree就需要六次IO操作。==</p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>我们看下面的两个SQL语句，看看它们的查询过程是一样的么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tb <span class="keyword">where</span> <span class="keyword">name</span> = zhou</span><br></pre></td></tr></table></figure><p>答案是不一样的，首先我们看第二个语句，就是要输出的列中，就是我们的主键，当我们通过name建立的B+Tree进行查询的时候</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629094800800.png" alt="image-20200629094800800"></p><p>我们可以直接找到我们的数据，并得到主键，但是因为我们要返回的就是name，此时说明数据存在了，那么就直接把当前的name进行返回，而不需要通过主键再去主键B+Tree中进行查询。</p><p>这样一个不需要进行回表操作的过程，我们称为<strong>索引覆盖</strong></p><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p>这里提到的 <strong>最左匹配</strong> 和 <strong>索引下推</strong> 都是针对于组合索引的。</p><p>例如，我们有这样一个索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  age：组合索引</span><br></pre></td></tr></table></figure><p>必须要先匹配name，才能匹配到age。这个我们就被称为最左匹配</p><p>例如下面的几条SQL语句，那些语句不会使用组合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where name = ? and age = ?</span><br><span class="line">where name = ?</span><br><span class="line">where age = ?</span><br><span class="line">where age = ? and name = ?</span><br></pre></td></tr></table></figure><p>根据最左匹配原则，我们的 3 不会使用组合索引的。</p><p>那为什么4的顺序不一样，也会使用组合索引呢？</p><p>其实内部的优化器会进行调整，例如下面的一个连表操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">join</span> tb2 <span class="keyword">on</span> tb1.id = tb2.id</span><br></pre></td></tr></table></figure><p>其实在加载表的时候，并不一定是先加载tb1，在加载tb2，而是可能根据表的大小决定的，小的表优先加载进内存中。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>在说索引下推的时候，我们首先在举两个例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb1 <span class="keyword">where</span> <span class="keyword">name</span> = ? <span class="keyword">and</span> age = ?</span><br></pre></td></tr></table></figure><p>在mysq 5.6之前，会先根据name去存储引擎中拿到所有的数据，然后在server层对age进行数据过滤</p><p>在mysql5.6之后，根据name 和 age两个列的值去获取数据，直到把数据返回。</p><p>通过对比能够发现，第一个的效率低，第二个的效率高，因为整体的IO量少了，原来是把数据查询出来，在server层进行筛选，而现在在存储引擎层面进行筛选，然后返回结果。我们把这个过程就称为  <strong>索引下推</strong></p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><h4 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h4><p>基于成本的优化</p><h4 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h4><p>基于规则的优化</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629110258878.png" alt="image-20200629110258878"></p><h2 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h2><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配指的是和索引中所有的列进行匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span> <span class="keyword">and</span> pos = <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><p>而我们建立了一个 包含  name、age、pos的组合索引，使用上面的SQL语句，就会进行全值匹配</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>只匹配前面的几列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'July'</span> <span class="keyword">and</span> age = <span class="number">23</span></span><br></pre></td></tr></table></figure><p>这个时候，只使匹配了前面两个列，而没有使用第三个列</p><p>现在我们使用下面的SQL语句进行验证，但我们输出值只包含ID的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们查看其任务计划，在某尾有 Extra字段，如果是Using index 表示是使用了覆盖索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629144438346.png" alt="image-20200629144438346"></p><p>然后我们在查看下面这条SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过查看任务计划，发现extra字段是NULL，说明没有使用覆盖索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629145948288.png" alt="image-20200629145948288"></p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>可以匹配某一列值的开头部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'J%'</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'%y'</span></span><br></pre></td></tr></table></figure><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>可以查找某个范围的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> &gt; <span class="string">'Mary'</span></span><br></pre></td></tr></table></figure><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>可以查询某一列的全部和第二列的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"July"</span> <span class="keyword">and</span> age &gt; <span class="number">25</span></span><br></pre></td></tr></table></figure><h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>查询的时候值需要访问索引，不需要访问数据行，本质上就是索引覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,pos <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"July"</span> <span class="keyword">and</span> age=<span class="number">25</span> <span class="keyword">and</span> pos = <span class="string">"dev"</span></span><br></pre></td></tr></table></figure><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>基于哈希的实现，只有精确匹配索引所有的列的查询才有效，在mysql中，只有memory的存储引擎显式支持哈希索引，哈希索引自身只需存储对应的hash值，索引索引的结构十分紧凑，这让哈希索引查找的速度非常快。</p><h3 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h3><ul><li>哈希索引值包含哈希值和行指针，而不存储字段值。索引不能使用索引中的值来避免读取行</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li><li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li><li>哈希索引支持等值比较查询，也不支持任何范围查询</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，知道找到所有符合条件的行</li><li>哈希冲突比较多的话，维护的代价也会很高</li></ul><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按每张表的主键构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚簇索引的叶子节点称为数据也，这个特性就决定了索引组织表中的数据也是索引的一部分。</p><p>==一句话来说：将索引和数据放在一起的，就称为聚簇索引==</p><p>我们日常的工作中，根据实际情况自行添加的索引，都是辅助索引或者称为普通索引，辅助索引就是为了查找主键索引的二级索引，先找到主键索引然后再通过主键索引找数据，但是可能会存在<strong>回表</strong>的问题。</p><h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对主键的排序和范围查找速度非常快</li></ul><h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul><li>插入速度严重依赖于排序，按照主键的顺序插入是最快的方式，否者会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列作为主键</li><li>更新主键的代价很高，因为将会导致被更新的行移动，因此，对于InnoDB表，我们一般定义主键不可更新</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次 根据主键值查找行数据，一般我们需要尽量避免出现索引的二次查找，这个时候，用到的就是<strong>索引的覆盖</strong></li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引也被称为辅助索引，辅助索引在我们访问数据的时候总是需要两次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到主键值，然后在通过主键值找到数据行的数据页，在通过数据页中的Page Directory找到数据行。</p><p>InnoDB辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了行数据的聚簇索引建。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在InnoDB中有时也称为辅助索引为二级索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629113413737.png" alt="image-20200629113413737"></p><h2 id="组合索引-1"><a href="#组合索引-1" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p><p>第4个不走索引，是因为不满足最左匹配原则</p><p>第5个，因为跨过了b，所以只走a的索引</p><h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><ul><li><p>当使用索引列进行查询的时候，尽量不要使用表达式，把计算放到业务层而不是数据库层</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">4</span></span><br><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id+<span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>第一条语句走索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161629049.png" alt="image-20200629161629049"></p><p>而第二条语句没有走主键索引</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629161641522.png" alt="image-20200629161641522"></p></li><li><p>尽量使用主键查询，而不是其它索引，因为主键查询不会触发回表操作</p></li><li><p>使用前缀索引</p></li></ul><p>有时候需要索引很长的字符串，这会让索引变得大且满，通常情况下可以使用某个列开始的部分字符串，这样大大的节约了索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T 到 1 之间，索引的选择性越高，则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p><p>一般情况下，某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOG，TEXT，VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于选择足够长的前缀以保证较高的选择性，通过又不能太长 。</p><ul><li>使用索引扫描来进行排序</li><li>union、all、in、or都能使用索引，但是推荐使用in</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">union</span> all <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> actor_id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关于or到底走不走索引，必须根据实际情况进行考虑</span></span><br></pre></td></tr></table></figure><ul><li>范围列可以使用到索引</li></ul><p>例如 范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</p><p>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列，所以一般如果我们使用组合索引的时候，最好不要使用范围查找</p><p><img src="https://gitee.com/moxi159753/LearningNotes/raw/master/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/images/image-20200629160704401.png" alt="image-20200629160704401"></p><p>如倒数第一个所示，因为中间b使用了范围查找，所以后面的c是无法使用索引的，只能是a和b才能使用索引</p><ul><li>强制类型转换会让索引失效，进行全表查询</li></ul><p>例如下面这样一个例子所示，我们对 phone字段进行了强制类型转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="number">13800001234</span>  <span class="comment">-- 不会触发索引（触发了字符串到整型转换）</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> phone = <span class="string">'13800001234'</span>  <span class="comment">-- 触发索引</span></span><br></pre></td></tr></table></figure><ul><li>更新十分频繁，数据区分度不高的字段上不宜建立索引</li></ul><p>更新会变更B+树，更新 频繁的字段建立索引会大大降低数据库性能</p><p>类似于性别这列的区分度不高的字段，建立索引是没有意义的，不能有效的过滤数据</p><p>一般区分度在百分80以上的时候，就可以建立索引，区分度可以使用 count(distinct(列名)) / count(*) 来进行计算</p><ul><li>创建索引的列，不允许为null，可能会得到不符合预期的结果</li><li>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致（阿里规约）<ul><li>允许数据的冗余，从而加快查询的效率</li><li>目前是范式和反范式的混合使用</li></ul></li><li>能使用limit的时候，尽量使用limit</li><li>单表索引建议控制在5个以内</li><li>单索引字段不允许超过5个（组合索引）</li><li>创建索引的时候应该尽量避免以下错误的概念</li></ul><p>索引不是越多越好，不要在不了解系统的情况下进行优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引的优点&quot;&gt;&lt;a href=&quot;#索引的优点&quot; class=&quot;headerlink&quot; title=&quot;索引的优点&quot;&gt;&lt;/a&gt;索引的优点&lt;/h2&gt;&lt;p&gt;最典型的例子就是查新华字典，通过查找目录快速定位到查找的字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大大减少了服务器需要扫描的数量
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL索引" scheme="http://www.devcheng.net/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>并发锁知识点</title>
    <link href="http://www.devcheng.net/post/2a798f18.html"/>
    <id>http://www.devcheng.net/post/2a798f18.html</id>
    <published>2020-10-23T13:31:56.000Z</published>
    <updated>2020-10-23T13:41:01.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="悲观锁：synchronized"><a href="#悲观锁：synchronized" class="headerlink" title="悲观锁：synchronized"></a>悲观锁：synchronized</h2><p>Synchronized互斥锁属于悲观锁，它有一个明显的缺点，它不管数据存不存在竞争都加锁，随着并发量增加，且如果锁的时间比较长，其性能开销将会变得很大。</p><p>每个对象头中分为两部分：一部分是自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。一部分是类型指针，即是对象指向它的类的元数据的指针。</p><p>而对象的锁(monitor)就在对象头中，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p><p>而其他想要获取该锁只能阻塞，一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，需要消耗很多处理器时间</p><h3 id="特性：互斥锁、非公平锁、可重入、不可中断"><a href="#特性：互斥锁、非公平锁、可重入、不可中断" class="headerlink" title="特性：互斥锁、非公平锁、可重入、不可中断"></a>特性：互斥锁、非公平锁、可重入、不可中断</h3><h3 id="优点：实现简单"><a href="#优点：实现简单" class="headerlink" title="优点：实现简单"></a>优点：实现简单</h3><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>不管数据存不存在竞争都加锁，随着并发量增加，且如果锁的时间比较长，其性能开销将会变得很大</li><li>不可中断，在所有等待的线程中，synchronized无法帮你中断此任务</li><li>互斥锁在获取锁失败后将进入睡眠或阻塞状态</li></ul><h2 id="乐观锁：CAS-compare-and-swap-比较并交换"><a href="#乐观锁：CAS-compare-and-swap-比较并交换" class="headerlink" title="乐观锁：CAS( compare and swap,比较并交换)"></a>乐观锁：CAS( compare and swap,比较并交换)</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>悲观锁会把整个对象加锁占为自有后才去做操作，乐观锁不获取锁直接做操作，然后通过一定检测手段决定是否更新数据。</p><p>乐观锁的核心算法是CAS（Compare and Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。</p><p>这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。</p><p><strong>优点：</strong> 高并发性能，jdk中的并发包也大量使用基于CAS的乐观锁。</p><p><strong>缺点：</strong></p><ul><li>乐观锁只能保证一个共享变量的原子操作</li><li>长时间自旋可能导致开销大</li><li>ABA问题。</li></ul><p>CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</p><h2 id="同步器：AQS-AbstractQueuedSynchronizer"><a href="#同步器：AQS-AbstractQueuedSynchronizer" class="headerlink" title="同步器：AQS(AbstractQueuedSynchronizer)"></a>同步器：AQS(AbstractQueuedSynchronizer)</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>它为不同场景提供了实现锁及同步机制的基本框架，为同步状态的原子性管理、线程的阻塞、线程的解除阻塞及排队管理提供了一种通用的机制。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>ASQ将线程封装到一个Node里面，并维护一个CHL Node FIFO队列，它是一个非阻塞的FIFO队列，也就是说在并发条件下往此队列做插入或移除操作不会阻塞，是通过自旋锁和CAS保证节点插入和移除的原子性，实现无锁快速插入。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ul><li>独占模式state的值只能为0或1</li><li>共享模式的state是可以被出事换成任意整数，一般初始值表示提供一个同时n条线程通过的管道宽度，这样一来，多条线程通过tryAcquireShared尝试将state的值减去1，成功修改state后就返回新值，只有当新值大于等于0才表示获取锁成功，拥有往下执行的权利，进入管道。在执行完毕时线程将调用tryReleaseShared尝试修改state值使之增加1。</li><li>表示我已经执行完了并让出管道的通道供后面线程使用，需要说明的是与独占模式不同，由于可能存在多条线程并发释放锁，所以此处必须使用基于CAS算法的修改方法，修改成功后其他线程便可继续竞争锁。</li><li>独占式：只容许一个线程通过的管道，在这种模式下线程只能逐一通过管道，任意时刻管内只能存在一条线程，这便形成了互斥效果。</li><li>共享式：共享模式就是管道宽度大于1的管道，可以同时让n条管道通过，吞吐量增加但可能存在共享数据一致性问题。</li></ul><h2 id="阻塞唤醒三种方式："><a href="#阻塞唤醒三种方式：" class="headerlink" title="阻塞唤醒三种方式："></a>阻塞唤醒三种方式：</h2><ul><li>suspend与resume：存在无法解决的竟态问题而被Java废弃</li><li>wait与notify：这两个方法必须存在于synchronized中，存在竟态条件，wait必须在notify之前执行，假如一个线程先执行notify再执行wait将可能导致一个线程永远阻塞</li><li>await与singal: Condition类提供，而Condition对象由new ReentLock().newCondition()获得，与wait和notify相同，因为使用Lock锁后无法使用wait方法<h3 id="wait与await区别："><a href="#wait与await区别：" class="headerlink" title="wait与await区别："></a>wait与await区别：</h3></li><li>wait与notify必须配合synchronized使用，因为调用之前必须持有锁，wait会立即释放锁，notify则是同步块执行完了才释放</li><li>因为Lock没有使用synchronized机制，故无法使用wait方法区操作多线程，所以使用了Condition的await来操作</li><li>park与unpark：由LockSupport类提供，底层调用的是Unsafe类的方法，由于park与unpark使用的是许可机制，许可最大为1，所以unpark与park操作不会累加，而且unpark可以在park之前执行，如unpark先执行，后面park将不阻塞。</li><li>Lock实现主要是基于AQS，而AQS实现则是基于LockSupport，所以说LockSupport更底层，所以不建议使用park和unpark去阻塞和唤醒线程</li></ul><h2 id="Java内部有两种锁机制"><a href="#Java内部有两种锁机制" class="headerlink" title="Java内部有两种锁机制:"></a>Java内部有两种锁机制:</h2><h3 id="1-synchonized"><a href="#1-synchonized" class="headerlink" title="1.synchonized"></a>1.synchonized</h3><h3 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2.Lock"></a>2.Lock</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><h4 id="实现机制不同"><a href="#实现机制不同" class="headerlink" title="实现机制不同"></a>实现机制不同</h4><ul><li>synchonrized 分为两种 程序段的synchonized是通过monitor.enter monitor.exit来实现的，方法和类级别的则是通过设置实例或者类的锁字段来实现</li><li>Lock的实现方式则是通过AQS。AQS是一个线程的链表，负责维护线程的状态，以及线程的调度，AQS也是一个锁 保证同一时间获取AQS锁的线程只有一个，也就是下面的Nodestatus为runnning的只有一个(为什么不是同一时间运行的线程只有一个呢?线程在申请锁的时候先加入队列然后挂起，并且在公平竞争时所有的线程都会别唤醒 )</li></ul><h3 id="synchronized-同步锁"><a href="#synchronized-同步锁" class="headerlink" title="synchronized    同步锁"></a>synchronized    同步锁</h3><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>任何一个对象都一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p>MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。</p><p>这时如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，需要消耗很多处理器时间。如果可能，应该减少这样的切换，jvm一般会采取一些措施进行优化，例如在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。</p><h4 id="Java中每一个对象都可以作为锁，这是synchronized实现同步的基础："><a href="#Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：" class="headerlink" title="Java中每一个对象都可以作为锁，这是synchronized实现同步的基础："></a>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</h4><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li><li>javap工具查看生成的class文件信息来分析Synchronize的实现</li><li>同步代码块：</li></ul><p>monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p><p>同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。</p><h4 id="Java对象头和monitor是实现synchronized的基础"><a href="#Java对象头和monitor是实现synchronized的基础" class="headerlink" title="Java对象头和monitor是实现synchronized的基础"></a>Java对象头和monitor是实现synchronized的基础</h4><h3 id="特性：互斥锁、非公平锁、可重入、不可中断、使用简单"><a href="#特性：互斥锁、非公平锁、可重入、不可中断、使用简单" class="headerlink" title="特性：互斥锁、非公平锁、可重入、不可中断、使用简单"></a>特性：互斥锁、非公平锁、可重入、不可中断、使用简单</h3><h3 id="性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。"><a href="#性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。" class="headerlink" title="性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。"></a>性能和建议：JDK6之后，在并发量不是特别大的情况下，性能中等且稳定。建议新手使用。</h3><p><strong>Lock锁实现：</strong></p><h3 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock    重入锁"></a>ReentrantLock    重入锁</h3><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>ReentrantLock是Lock接口的实现类。Lock接口的核心方法是lock()，unlock()，tryLock()。可用Condition来操作线程，await()和object.wait()类似，singal()和object.notify()类似，singalAll()和object.notifyAll()类似。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>核心类AbstractQueuedSynchronizer，通过构造一个基于阻塞的CLH队列容纳所有的阻塞线程，而对该队列的操作均通过Lock-Free（CAS）操作，但对已经获得锁的线程而言，ReentrantLock实现了偏向锁的功能。</p><h4 id="特性：公平锁-定时锁-有条件锁-可轮询锁-可中断锁-可以有效避免死锁的问题"><a href="#特性：公平锁-定时锁-有条件锁-可轮询锁-可中断锁-可以有效避免死锁的问题" class="headerlink" title="特性：公平锁, 定时锁, 有条件锁, 可轮询锁, 可中断锁. 可以有效避免死锁的问题"></a>特性：公平锁, 定时锁, 有条件锁, 可轮询锁, 可中断锁. 可以有效避免死锁的问题</h4><h4 id="性能和建议：性能中等，建议需要手动操作线程时使用。"><a href="#性能和建议：性能中等，建议需要手动操作线程时使用。" class="headerlink" title="性能和建议：性能中等，建议需要手动操作线程时使用。"></a>性能和建议：性能中等，建议需要手动操作线程时使用。</h4><h3 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock    读写锁"></a>ReentrantReadWriteLock    读写锁</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>它允许多个线程读某个资源，但每次只允许一个线程来写。ReadWriteLock接口的核心方法是readLock()，writeLock()。实现了并发读、互斥写。但读锁会阻塞写锁，是悲观锁的策略。</p><p>当多个线程读取有个变量时可以使用读锁rwl.readLock().lock();，如果需要去修改某个变量时则可以上写锁rwl.writeLock().lock();//上写锁，不允许其他线程读也不允许写</p><p>与重入锁比较，其实现原理一致，但是读写锁更适合读多写少的场景，因为读读共享，而重入锁全互斥</p><p><strong>StampedLock</strong></p><p>时间戳锁(jdk1.8改进的读写锁)</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>写锁的改进，它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写，在读的时候如果发生了写，则应当重读而不是在读的时候直接阻塞写！</p><h4 id="时间戳锁与读写锁比较"><a href="#时间戳锁与读写锁比较" class="headerlink" title="时间戳锁与读写锁比较"></a>时间戳锁与读写锁比较</h4><p>读锁不阻塞写锁，如果时间戳无效，则重新读取变量值。无ABA问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;悲观锁：synchronized&quot;&gt;&lt;a href=&quot;#悲观锁：synchronized&quot; class=&quot;headerlink&quot; title=&quot;悲观锁：synchronized&quot;&gt;&lt;/a&gt;悲观锁：synchronized&lt;/h2&gt;&lt;p&gt;Synchronized互斥
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="并发锁" scheme="http://www.devcheng.net/tags/%E5%B9%B6%E5%8F%91%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringBoot开发图书管理系统源码分享</title>
    <link href="http://www.devcheng.net/post/931cd25c.html"/>
    <id>http://www.devcheng.net/post/931cd25c.html</id>
    <published>2020-10-06T13:32:33.000Z</published>
    <updated>2020-12-26T05:56:52.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚入门SpringBoot的朋友！</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a><strong>功能描述</strong></h2><p>项目分为管理员和非管理员两种角色，其中非管理员包含：教师和学生。</p><p>在项目中管理员主要拥有的功能有：书籍管理（图书管理、借书审核、查看已借出书籍、查看换书），用户管理（学生管理、教师管理），部门管理（班级管理、学院管理），设置（修改密码、查看个人信息、操作日志、退出）。</p><p>在项目非管理员拥有的功能：借阅图书管理（借书、已借书及还书、正审核的图书），设置（修改密码、查看个人信息、退出）。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><ul><li>系统环境：Windows 10</li><li>开发工具：IntelliJ IDEA</li><li>Java版本：JDK 1.8</li></ul><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot 2.0.6.RELEASE</li><li>SpringDataJpa</li><li>Maven 3.X</li><li>Bootstarp</li><li>EasyUI</li><li>Mysql</li><li>thymeleaf</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>管理员账户和密码： admin6 / admin6</p><p>学生账户和密码：  guliduo / guliduo</p><h2 id="系统展示图"><a href="#系统展示图" class="headerlink" title="系统展示图"></a><strong>系统展示图</strong></h2><p><img src="/images/book01.png" alt="“伊成博客”"></p><p><img src="/images/book02.png" alt="“伊成博客”"></p><p><img src="/images/book03.png" alt="“伊成博客”"></p><p><img src="/images/book04.png" alt="“伊成博客”"></p><p><img src="/images/book05.png" alt="“伊成博客”"></p><p><img src="/images/book06.png" alt="“伊成博客”"></p><p><img src="/images/book07.png" alt="“伊成博客”"></p><p><img src="/images/book08.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！ 备注：图书管理系统</p><h2 id="项目演示视频"><a href="#项目演示视频" class="headerlink" title="项目演示视频"></a><strong>项目演示视频</strong></h2><p>链接: <a href="https://pan.baidu.com/s/1UDY8uH167xUUttXKrDMF3A" target="_blank" rel="noopener">https://pan.baidu.com/s/1UDY8uH167xUUttXKrDMF3A</a> </p><p>提取码: hjhi</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖怪请绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="在线图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Class org.springframework.util.ReflectionUtils can not access a member of class异常</title>
    <link href="http://www.devcheng.net/post/50c55201.html"/>
    <id>http://www.devcheng.net/post/50c55201.html</id>
    <published>2020-09-28T09:34:25.000Z</published>
    <updated>2020-09-28T09:57:08.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-09-25 14:02:03.393 ERROR 13920 --- [nio-8400-exec-3] c.s.b.d.support.utils.ExceptionUtils :</span><br><span class="line"> Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of class com.xxx.model.entity.XxxEntity with modifiers &quot;private&quot;; </span><br><span class="line"> nested exception is java.lang.IllegalStateException: Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of </span><br><span class="line"> class com.xxx.Entity with modifiers &quot;private&quot;</span><br></pre></td></tr></table></figure><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>为了完整的说明这个异常，简单的看一下代码：</p><p><strong>Entity 类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.reflect;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private void add()&#123;</span><br><span class="line">        System.out.println(&quot;add method...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接运行 main 方法则会报这个异常 Class . can not access a member of class . with modifiers “private” 。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置Field对象的Accessible的访问标志位为Ture，就可以通过反射获取私有变量的值，在访问时会忽略访问修饰符的检查。</p><p>所以只需要加上这行代码即可！</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">method.setAccessible(true); // 加上这句即可解决问题！</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="异常" scheme="http://www.devcheng.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.devcheng.net/post/c72647c7.html"/>
    <id>http://www.devcheng.net/post/c72647c7.html</id>
    <published>2020-09-25T12:53:55.000Z</published>
    <updated>2020-09-25T13:03:42.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大白话之乐观锁和悲观锁"><a href="#大白话之乐观锁和悲观锁" class="headerlink" title="大白话之乐观锁和悲观锁"></a>大白话之乐观锁和悲观锁</h2><p>用大白话解释什么是乐观锁好悲观锁如下：</p><p>乐观锁对应于生活中乐观的人总是想着事情会往好的方向发展。</p><p>悲观锁对应于生活中悲观的人总是想着事情会往坏的方向发展。</p><h3 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁 (Optimistic Locking)"></a>乐观锁 (Optimistic Locking)</h3><p>假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><h3 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁 (Pessimistic Lock)"></a>悲观锁 (Pessimistic Lock)</h3><p>悲观其实是我们人类一种消极的情绪，对应到锁的悲观情绪，悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后（可以理解为一个用户），其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁以及 Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>悲观锁一般多写的场景下</strong>用就比较合适。</p><h2 id="乐观的两种实现方式"><a href="#乐观的两种实现方式" class="headerlink" title="乐观的两种实现方式"></a>乐观的两种实现方式</h2><ul><li>版本号机制<br>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ul><p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>1.操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（100-$50 ）。</p><p>2.在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（100-$20 ）。</p><p>3.操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</p><p>4.操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</p><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><ul><li>CAS算法<br>即<strong>compare and swap</strong>（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</li></ul><p>CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li><li>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。</li></ul><p>一般情况下是一个自旋操作，即不断的重试。</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><p>ABA 问题是乐观锁一个常见的问题。</p><p><strong>1 ABA 问题</strong></p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p><p>这个问题被称为CAS操作的 <strong>“ABA”问题</strong>。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少）<br>synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；<br>而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由上文的介绍，相信大家都有一定的认识了，在实际工作中如何选择得需要看对应的业务场景，但随着互联网三高架构(高并发、高性能、高可用)的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#大白话之乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;/a&gt;大白话之乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;用大白话解释什么是乐观锁好悲观锁如下：&lt;/p&gt;
&lt;p&gt;乐观锁对应于生
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="乐观锁" scheme="http://www.devcheng.net/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://www.devcheng.net/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如果面试官问你“你有什么问题问我吗？”时，你该如何回答</title>
    <link href="http://www.devcheng.net/post/185dcb3e.html"/>
    <id>http://www.devcheng.net/post/185dcb3e.html</id>
    <published>2020-09-22T13:35:33.000Z</published>
    <updated>2020-09-22T14:05:06.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。</p><p>这个时候很多人内心就会陷入短暂的纠结中：我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？</p><h2 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h2><p>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。</p><p>我说这些并不代表你就可以直接对面试官说：“我没问题了。”，个人当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。</p><p>面试本身就是一个双向选择的过程，你对这个问题的回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</p><p>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化。</p><p>我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</p><p>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</p><p>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</p><h2 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h2><p>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。</p><p>面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。</p><p>总的来说，还是要真诚。</p><p>除此之外，不要问太 Low 的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不上心，既然你不上心，为什么要要你呢）。</p><p>举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：</p><ul><li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li><li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li><li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li><li>……</li></ul><h2 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h2><p>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</p><p><strong>面对HR或者其他Level比较低的面试官时</strong></p><p><strong>1.能不能谈谈你作为一个公司老员工对公司的感受?</strong> (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</p><p><strong>2.能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？有什么地方你觉得还不太好或者可以继续完善吗？</strong> （类似第一个问题，都是问面试官个人对于公司的看法。）</p><p><strong>3.我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</p><p><strong>4.接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</strong> （体现出你对工作比较上心，自助学习意识比较强。）</p><p><strong>5.这个岗位为什么还在招人？</strong> (岗位真实性和价值咨询)</p><p><strong>6.大概什么时候能给我回复呢？</strong>(终面的时候，如果面试官没有说的话，可以问一下)</p><p><strong>7…….</strong></p><p><strong>面对部门领导</strong></p><p><strong>1.部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong></p><p><strong>2.未来如果我要加入这个团队，你对我的期望是什么？</strong> （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</p><p><strong>3.公司对新入职的员工的培养机制是什么样的呢？</strong>（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</p><p><strong>4.以您来看，这个岗位未来在公司内部的发展如何？</strong> (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</p><p><strong>5.团队现在面临的最大挑战是什么？</strong> (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</p><p><strong>面对Level比较高的(比如总裁,老板)</strong></p><p><strong>1.贵公司的发展目标和方向是什么？</strong> （看下公司的发展是否满足自己的期望）</p><p><strong>2.与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong> （充分了解自己的优势和劣势）</p><p><strong>3.公司现在面临的最大挑战是什么？</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯定是觉得你就是他们要招的人。</p><p>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。</p><p>上面提到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！</p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="面试" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试经验" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>你是否因为命名被diss过？</title>
    <link href="http://www.devcheng.net/post/18c03ab9.html"/>
    <id>http://www.devcheng.net/post/18c03ab9.html</id>
    <published>2020-09-18T10:56:03.000Z</published>
    <updated>2020-09-18T11:27:16.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。<br>就连世界级软件大师 Martin Fowler 大神都说过 CS 领域有两大最难的事情，一是缓存失效，一是程序命名。</p><p><img src="/images/marting-naming-1.png" alt="&quot;伊成博客&quot;"></p><h2 id="为什么需要重视命名"><a href="#为什么需要重视命名" class="headerlink" title="为什么需要重视命名"></a>为什么需要重视命名</h2><p><strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！</strong></p><p>好的命名对于其他人（包括你自己）理解你的代码有着很大的帮助！</p><p>简单举个例子说明一下命名的重要性。</p><p>《Clean Code》这本书明确指出：</p><p>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p><p>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</p><p>举个栗子：</p><p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// check to see if the employee is eligible for full benefits</span><br><span class="line">if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))</span><br></pre></td></tr></table></figure><p>应替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure><h2 id="常见命名规则以及适用场景"><a href="#常见命名规则以及适用场景" class="headerlink" title="常见命名规则以及适用场景"></a>常见命名规则以及适用场景</h2><p>这里只介绍 3 种最常见的命名规范。</p><h3 id="驼峰命名法（CamelCase）"><a href="#驼峰命名法（CamelCase）" class="headerlink" title="驼峰命名法（CamelCase）"></a>驼峰命名法（CamelCase）</h3><p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p><h4 id="大驼峰命名法（CamelCase）"><a href="#大驼峰命名法（CamelCase）" class="headerlink" title="大驼峰命名法（CamelCase）"></a>大驼峰命名法（CamelCase）</h4><ul><li>类名需要使用大驼峰命名法（UpperCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceDiscovery、ServiceInstance、LruCacheFactory</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceDiscovery、Serviceinstance、LRUCacheFactory</span><br></pre></td></tr></table></figure><h4 id="小驼峰命名法（lowerCamelCase）"><a href="#小驼峰命名法（lowerCamelCase）" class="headerlink" title="小驼峰命名法（lowerCamelCase）"></a>小驼峰命名法（lowerCamelCase）</h4><ul><li>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getUserInfo()、createCustomThreadPool()、setNameFormat(String nameFormat)</span><br><span class="line">Uservice userService;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat)</span><br><span class="line">Uservice user_service</span><br></pre></td></tr></table></figure></p><h3 id="蛇形命名法（snake-case）"><a href="#蛇形命名法（snake-case）" class="headerlink" title="蛇形命名法（snake_case）"></a>蛇形命名法（snake_case）</h3><ul><li>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</li></ul><p>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。</p><p>蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下： “shouldGet200StatusCodoWhenRequestIsValid”。</p><p>感觉如何？ </p><p><strong>相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</strong></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void should_get_200_status_code_when_request_is_valid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void shouldGet200StatusCodoWhenRequestIsValid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串式命名法（kebab-case）"><a href="#串式命名法（kebab-case）" class="headerlink" title="串式命名法（kebab-case）"></a>串式命名法（kebab-case）</h3><ul><li>在串式命名法中，各个单词之间通过下划线“-”连接，比如dubbo-registry。</li></ul><p>建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。<br><img src="/images/dubbo-naming-2.png" alt="&quot;伊成博客&quot;"></p><h2 id="常见命名规范"><a href="#常见命名规范" class="headerlink" title="常见命名规范"></a>常见命名规范</h2><h3 id="Java-语言基本命名规范"><a href="#Java-语言基本命名规范" class="headerlink" title="Java 语言基本命名规范"></a>Java 语言基本命名规范</h3><p><strong>1.类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p><p><strong>2.测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong>，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。并且，<strong>测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</strong></p><p><strong>3.项目文件夹名称使用串式命名法（kebab-case）</strong>，比如dubbo-registry。</p><p><strong>4.包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连接，并且各个单词必须为单数。</strong></p><p>正例： org.apache.dubbo.common.threadlocal</p><p>反例： <del>org.apache.dubbo.common.threadLocal</del></p><p><strong>5.抽象类命名使用 Abstract 开头。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）</span><br><span class="line">public abstract class AbstractClient extends AbstractEndpoint implements Client &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>6.异常类命名使用 Exception 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义的 NoSuchMethodException（出处：Dubbo源码）</span><br><span class="line">public class NoSuchMethodException extends RuntimeException &#123;</span><br><span class="line">    private static final long serialVersionUID = -2725364246023268766L;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7.测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）</span><br><span class="line">public class AnnotationUtilsTest &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><h3 id="命名易读性规范"><a href="#命名易读性规范" class="headerlink" title="命名易读性规范"></a>命名易读性规范</h3><p><strong>1.为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。</strong><br>比如 CustomThreadFactory 不可以被写成 <del>CustomTF</del> 。</p><p><strong>2.命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。</strong> 这个对应我们上面说的第 1 点。</p><p><strong>3.避免无意义的命名</strong>，你起的每一个名字都要能表明意思。</p><p>正例：UserService userService; int userCount;</p><p>反例: <del>UserService service int count</del></p><p><strong>4.避免命名过长（50 个字符以内最好）</strong>，过长的命名难以阅读并且丑陋。</p><p><strong>5.不要使用拼音，更不要使用中文。</strong> 注意：像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。</p><p>正例：discount</p><p>反例：<del>dazhe</del></p><h2 id="Codelf-变量命名神器"><a href="#Codelf-变量命名神器" class="headerlink" title="Codelf:变量命名神器?"></a>Codelf:变量命名神器?</h2><p>这是一个由国人开发的网站，网上有很多人称其为变量命名神器，大家可以自行体验一下，然后再给出自己的判断。</p><p>Codelf 提供了在线网站版本，网址：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">https://unbug.github.io/codelf/</a></p><p>具体使用情况如下：</p><p>我选择了 Java 编程语言，然后搜索了“序列化”这个关键词，然后它就返回了很多关于序列化的命名。</p><p><img src="/images/dubbo-naming-3.png" alt="&quot;伊成博客&quot;"></p><p>并且，Codelf 还提供了 VS code 插件，看这个评价，看来大家还是很喜欢这款命名工具的。</p><p><img src="/images/dubbo-naming-4.png" alt="&quot;伊成博客&quot;"></p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。&lt;br&gt;就连世界级软件大师 M
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="变量命名" scheme="http://www.devcheng.net/tags/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 注解大全，建议收藏</title>
    <link href="http://www.devcheng.net/post/2ad95350.html"/>
    <id>http://www.devcheng.net/post/2ad95350.html</id>
    <published>2020-09-09T13:15:54.000Z</published>
    <updated>2020-09-09T13:39:53.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中，用到了各种各样的注解，一直没抽时间整理过，正好今天抽时间稍微整理了一波。整理的注解都是工作中常见的，如有纰漏请留言指出！</p><h2 id="一、注解-annotations-列表"><a href="#一、注解-annotations-列表" class="headerlink" title="一、注解 (annotations) 列表"></a>一、注解 (annotations) 列表</h2><p><strong>@SpringBootApplication：</strong></p><p>包含了 @ComponentScan、@Configuration 和 @EnableAutoConfiguration 注解。</p><p>其中 @ComponentScan 让 spring Boot 扫描到 Configuration 类并把它加入到程序上下文。</p><p><strong>@Configuration</strong> 等同于 spring 的 XML 配置文件；使用 Java 代码可以检查类型安全。</p><p><strong>@EnableAutoConfiguration</strong>  自动配置。</p><p><strong>@ComponentScan</strong>  组件扫描，可自动发现和装配一些 Bean。</p><p><strong>@Component</strong> 可配合 CommandLineRunner 使用，在程序启动后执行一些基础任务。</p><p><strong>@RestController</strong> 注解是 @Controller 和 @ResponseBody 的合集, 表示这是个控制器 bean, 并且是将函数的返回值直 接填入 HTTP 响应体中, 是 REST 风格的控制器。</p><p><strong>@Autowired</strong> 自动导入。</p><p><strong>@PathVariable</strong> 获取参数。</p><p><strong>@JsonBackReference</strong> 解决嵌套外链问题。</p><p><strong>@RepositoryRestResourcepublic</strong> 配合 spring-boot-starter-data-rest 使用。</p><h2 id="二、注解-annotations-详解"><a href="#二、注解-annotations-详解" class="headerlink" title="二、注解 (annotations) 详解"></a>二、注解 (annotations) 详解</h2><p><strong>@SpringBootApplication</strong>：申明让 spring boot 自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myproject;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseBody</strong>：表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用，用于构建 RESTful 的 api。</p><p>在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。</p><p>比如异步获取 json 数据，加上 @responsebody 后，会直接返回 json 数据。</p><p>该注解一般会配合 @RequestMapping 一起使用。示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(“/test”)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String test()&#123;</span><br><span class="line">    return”ok”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@Controller</strong>：用于定义控制器类，在 spring 项目中由控制器负责将用户发来的 URL 请求转发到对应的服务接口（service 层）</p><p>关注顶级架构师公众号回复“架构整洁”，送你一份惊喜礼包。</p><p>一般这个注解在类中，通常方法需要配合注解 @RequestMapping。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(“/demoInfo”)</span><br><span class="line">publicclass DemoController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DemoInfoService demoInfoService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello(Map map)&#123;</span><br><span class="line">        System.out.println(&quot;DemoController.hello()&quot;);</span><br><span class="line">        map.put(&quot;hello&quot;,&quot;from TemplateController.helloHtml&quot;);</span><br><span class="line">        //会使用hello.html或者hello.ftl模板进行渲染显示.</span><br><span class="line">        return&quot;/hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@RestController</strong>：用于标注控制层组件 (如 struts 中的 action)，@ResponseBody 和 @Controller 的合集。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.kfit.demo.web;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(“/demoInfo2”)</span><br><span class="line">publicclass DemoController2 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return&quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@RequestMapping</strong>：提供路由信息，负责 URL 到 Controller 中的具体函数的映射。</p><p><strong>@EnableAutoConfiguration</strong>：Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的 Spring 应用。</p><p>例如，如果你的 classpath 下存在 HSQLDB，并且你没有手动配置任何数据库连接 beans，那么我们将自动配置一个内存型（in-memory）数据库”。</p><p>你可以将 @EnableAutoConfiguration 或者 @SpringBootApplication 注解添加到一个 @Configuration 类上来选择自动配置。</p><p>如果发现应用了你不想要的特定自动配置类，你可以使用 @EnableAutoConfiguration 注解的排除属性来禁用它们。</p><p><strong>@ComponentScan</strong>：表示将该类自动发现扫描组件。</p><p>个人理解相当于，如果扫描到有 @Component、@Controller、@Service 等这些注解的类，并注册为 Bean，可以自动收集所有的 Spring 组件，包括 @Configuration 类。</p><p>我们经常使用 @ComponentScan 注解搜索 beans，并结合 @Autowired 注解导入。可以自动收集所有的 Spring 组件，包括 @Configuration 类。</p><p>如果没有配置的话，Spring Boot 会扫描启动类所在包下以及子包下的使用了 @Service,@Repository 等注解的类。</p><p><strong>@Configuration</strong>：相当于传统的 xml 配置文件，如果有些第三方库需要用到 xml 文件，建议仍然通过 @Configuration 类作为项目的配置主类——可以使用 @ImportResource 注解加载 xml 配置文件。</p><p><strong>@Import</strong>：用来导入其他配置类。</p><p><strong>@ImportResource</strong>：用来加载 xml 配置文件。</p><p><strong>@Autowired</strong>：自动导入依赖的 bean</p><p><strong>@Service</strong>：一般用于修饰 service 层的组件</p><p><strong>@Repository</strong>：使用 @Repository 注解可以确保 DAO 或者 repositories 提供异常转译，这个注解修饰的 DAO 或者 repositories 类会被 ComponetScan 发现并配置，同时也不需要为它们提供 XML 配置项。</p><p><strong>@Bean</strong>：用 @Bean 标注方法等价于 XML 中配置的 bean。</p><p><strong>@Value</strong>：注入 Spring boot application.properties 配置的属性的值。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(value = “#&#123;message&#125;”)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure><p><strong>@Inject</strong>：等价于默认的 @Autowired，只是没有 required 属性；</p><p><strong>@Component</strong>：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p><strong>@Bean</strong>：相当于 XML 中的, 放在方法的上面，而不是类，意思是产生一个 bean, 并交给 spring 管理。</p><p><strong>@AutoWired</strong>：自动导入依赖的 bean。byType 方式。把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到 bean 也不报错。</p><p><strong>@Qualifier</strong>：当有多个同一类型的 Bean 时，可以用 @Qualifier(“name”) 来指定。与 @Autowired 配合使用。@Qualifier 限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = “demoInfoService”)</span><br><span class="line"><span class="keyword">private</span> DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure><p><strong>@Resource(name=”name”,type=”type”)</strong>：没有括号内内容的话，默认 byName。与 @Autowired 干类似的事。</p><h2 id="三、JPA-注解"><a href="#三、JPA-注解" class="headerlink" title="三、JPA 注解"></a>三、JPA 注解</h2><p><strong>@Entity</strong>：@Table(name=”“)：表明这是一个实体类。一般用于 jpa 这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table 可以省略</p><p><strong>@MappedSuperClass</strong>: 用在确定是父类的 entity 上。父类的属性子类可以继承。</p><p><strong>@NoRepositoryBean</strong>: 一般用作父类的 repository，有这个注解，spring 不会去实例化该 repository。</p><p><strong>@Column</strong>：如果字段名与列名相同，则可以省略。</p><p><strong>@Id</strong>：表示该属性为主键。</p><p><strong>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator= “repair_seq”)</strong>：表示主键生成策略是 sequence（可以为 Auto、IDENTITY、native 等，Auto 表示可在多个数据库间切换），指定 sequence 的名字是 repair_seq。</p><p><strong>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)</strong>：name 为 sequence 的名称，以便使用，sequenceName 为数据库的 sequence 名称，两个名称可以一致。</p><p><strong>@Transient</strong>：表示该属性并非一个到数据库表的字段的映射, ORM 框架将忽略该属性。</p><p>如果一个属性并非数据库表的字段映射, 就务必将其标示为 @Transient, 否则, ORM 框架默认其注解为 @Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p><strong>@JsonIgnore</strong>：作用是 json 序列化时将 Java bean 中的一些属性忽略掉, 序列化和反序列化都受影响。</p><p><strong>@JoinColumn（name=”loginId”）</strong>: 一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p><strong>@OneToOne、@OneToMany、@ManyToOne</strong>：对应 hibernate 配置文件中的一对一，一对多，多对一。</p><h2 id="四、springMVC-相关注解"><a href="#四、springMVC-相关注解" class="headerlink" title="四、springMVC 相关注解"></a>四、springMVC 相关注解</h2><p><strong>@RequestMapping</strong>：@RequestMapping(“/path”)表示该控制器处理所有 “/path” 的 UR L 请求。</p><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params: 指定 request 中必须包含某些参数值是，才让该方法处理。</p><p>headers: 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</p><p>value: 指定请求的实际地址，指定的地址可以是 URI Template 模式</p><p>method: 指定请求的 method 类型， GET、POST、PUT、DELETE 等</p><p>consumes: 指定处理请求的提交内容类型（Content-Type），如 application/json,text/html;</p><p>produces: 指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回</p><p><strong>@RequestParam</strong>：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p><p><strong>@PathVariable</strong>: 路径变量。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(“user/get/mac/&#123;macAddress&#125;”)</span><br><span class="line">public String getByMacAddress(@PathVariable String macAddress)&#123;</span><br><span class="line">    //do something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数与大括号里的名字一样要相同。</p><h2 id="五、全局异常处理"><a href="#五、全局异常处理" class="headerlink" title="五、全局异常处理"></a>五、全局异常处理</h2><p><strong>@ControllerAdvice</strong>：包含 @Component。可以被扫描到。统一处理异常。</p><p><strong>@ExceptionHandler</strong>（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中，用到了各种各样的注解，一直没抽时间整理过，正好今天抽时间稍微整理了一波。整理的注解都是工作中常见的，如有纰漏请留言指出！&lt;/p&gt;

      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="注解" scheme="http://www.devcheng.net/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识点汇总整理</title>
    <link href="http://www.devcheng.net/post/72b87000.html"/>
    <id>http://www.devcheng.net/post/72b87000.html</id>
    <published>2020-08-17T12:41:47.000Z</published>
    <updated>2020-08-17T12:49:51.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。</p><p>这里先给大家安利一个在线画图<a href="https://www.processon.com/i/5915bcb6e4b0691b1f68fa96" target="_blank" rel="noopener">processon</a>，先看一下Redis知识点汇总整理好的一览图。</p><p><img src="https://s1.ax1x.com/2020/08/17/dZ8r24.png" alt="dZ8r24.png">.</p><p>由于绘制的脑图很大，以上仅是图的一部分。</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><ul><li>基础知识点</li><li>数据持久化</li><li>过期策略</li><li>内存淘汰策略</li><li>常见问题</li><li>Redis事务</li><li>主从复制</li><li>Redis集群</li><li>应用场景</li><li>对应面试题</li><li>…</li></ul><p>如有其它你觉得可以加进去的知识点，欢迎留言。后续会继续修改优化脑图！</p><p>脑图地址: <a href="https://www.processon.com/view/link/5f34b188e0b34d0806735914" target="_blank" rel="noopener">https://www.processon.com/view/link/5f34b188e0b34d0806735914</a></p><p>阅读密码：yicheng</p><hr><p><strong>The end</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。&lt;/p&gt;
&lt;p&gt;这里先给大家安利一个在线画图&lt;a hre
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis" scheme="http://www.devcheng.net/tags/Redis/"/>
    
      <category term="Redis知识点" scheme="http://www.devcheng.net/tags/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>16个Redis面试题，你能回答出来几个？</title>
    <link href="http://www.devcheng.net/post/60b1ff4c.html"/>
    <id>http://www.devcheng.net/post/60b1ff4c.html</id>
    <published>2020-08-09T13:05:00.000Z</published>
    <updated>2020-08-09T13:19:24.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！</p><h2 id="1-什么是redis"><a href="#1-什么是redis" class="headerlink" title="1.什么是redis?"></a><strong>1.什么是redis?</strong></h2><p>Redis 是一个基于内存的高性能key-value数据库。</p><h2 id="2-Redis的特点"><a href="#2-Redis的特点" class="headerlink" title="2.Redis的特点"></a><strong>2.Redis的特点</strong></h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据。</p><p>因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。</p><p>另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。<br>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h2 id="3-使用redis有哪些好处？"><a href="#3-使用redis有哪些好处？" class="headerlink" title="3.使用redis有哪些好处？"></a><strong>3.使用redis有哪些好处？</strong></h2><p>速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>支持丰富数据类型：支持string，list，set，sorted set，hash</p><p>支持事务：操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h2 id="4-redis相比memcached有哪些优势？"><a href="#4-redis相比memcached有哪些优势？" class="headerlink" title="4.redis相比memcached有哪些优势？"></a><strong>4.redis相比memcached有哪些优势？</strong></h2><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>redis的速度比memcached快很多</p><p>redis可以持久化其数据</p><h2 id="5-Memcache与Redis的区别都有哪些？"><a href="#5-Memcache与Redis的区别都有哪些？" class="headerlink" title="5.Memcache与Redis的区别都有哪些？"></a><strong>5.Memcache与Redis的区别都有哪些？</strong></h2><p>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</p><p>数据支持类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型。</p><p>使用底层模型不同：它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p><h2 id="6-redis常见性能问题和解决方案："><a href="#6-redis常见性能问题和解决方案：" class="headerlink" title="6.redis常见性能问题和解决方案："></a><strong>6.redis常见性能问题和解决方案：</strong></h2><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p><p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。</p><p>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p><p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p><p>4).Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p><h2 id="7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a><strong>7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</strong></h2><p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h2 id="8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"><a href="#8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。" class="headerlink" title="8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"></a><strong>8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。</strong></h2><p>具体登录函数或功能用空函数即可，不用详细写出。</p><p>用列表实现：列表中每个元素代表登陆时间，只要最后的第5次登陆时间和现在时间差不超过1小时就禁止登陆。用Python写的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import redis  </span><br><span class="line">import sys  </span><br><span class="line">import time  </span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0)  </span><br><span class="line">try:       </span><br><span class="line">    id = sys.argv[1]</span><br><span class="line">except:      </span><br><span class="line">    print(‘input argument error’)    </span><br><span class="line">    sys.exit(0)  </span><br><span class="line">if r.llen(id) &gt;= 5 and time.time() – float(r.lindex(id, 4)) &lt;= 3600:      </span><br><span class="line">    print(“you are forbidden logining”)</span><br><span class="line">else:       </span><br><span class="line">    print(‘you are allowed to login’)    </span><br><span class="line">    r.lpush(id, time.time())    </span><br><span class="line">    # login_func()</span><br></pre></td></tr></table></figure><h2 id="9-为什么redis需要把所有数据放到内存中"><a href="#9-为什么redis需要把所有数据放到内存中" class="headerlink" title="9.为什么redis需要把所有数据放到内存中?"></a><strong>9.为什么redis需要把所有数据放到内存中?</strong></h2><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。</p><p>如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="10-Redis是单进程单线程的"><a href="#10-Redis是单进程单线程的" class="headerlink" title="10.Redis是单进程单线程的"></a><strong>10.Redis是单进程单线程的</strong></h2><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="11-redis的并发竞争问题如何解决"><a href="#11-redis的并发竞争问题如何解决" class="headerlink" title="11.redis的并发竞争问题如何解决?"></a><strong>11.redis的并发竞争问题如何解决?</strong></h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。</p><p>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是</p><p>由于客户端连接混乱造成。对此有2种解决方法：</p><p>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度，利用setnx实现锁。</p><p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h2 id="12-redis事物的了解CAS-check-and-set-操作实现乐观锁"><a href="#12-redis事物的了解CAS-check-and-set-操作实现乐观锁" class="headerlink" title="12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?"></a><strong>12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?</strong></h2><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。</p><p>相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：</p><p>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p><p>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p><p>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。</p><p>在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</p><p>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。</p><p>然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p><p>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。</p><p>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。<br>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。</p><p>此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p><h2 id="13-WATCH命令和基于CAS的乐观锁："><a href="#13-WATCH命令和基于CAS的乐观锁：" class="headerlink" title="13.WATCH命令和基于CAS的乐观锁："></a><strong>13.WATCH命令和基于CAS的乐观锁：</strong></h2><p>在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。</p><p>例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure></p><p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景–竞态争用(race condition)。</p><p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。</p><p>为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">  val = GET mykey</span><br><span class="line">  val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">  SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前</p><p>如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p><h2 id="14-redis持久化的几种方式"><a href="#14-redis持久化的几种方式" class="headerlink" title="14.redis持久化的几种方式"></a><strong>14.redis持久化的几种方式</strong></h2><p><strong>1、快照（snapshots）</strong></p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump。rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p><strong>工作原理</strong></p><p>Redis forks。<br>子进程开始将数据写到临时RDB文件中。<br>当子进程完成写RDB文件，用新文件替换老文件。<br>这种方式可以使Redis使用copy-on-write技术。</p><p><strong>2、AOF</strong></p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。</p><p>Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式。</p><p><strong>3、虚拟内存方式</strong></p><p>当你的key很小而value很大时，使用VM的效果会比较好。因为这样节约的内存比较大。当你的key不小时，可以考虑使用一些非常方法将很大的key变成很大的value，比如你可以考虑将key，value组合成一个新的value。<br>　　<br>vm-max-threads这个参数，可以设置访问swap文件的线程数，设置最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的。可能会造成比较长时间的延迟，但是对数据完整性有很好的保证。</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库</p><h2 id="15-redis的缓存失效策略和主键失效机制"><a href="#15-redis的缓存失效策略和主键失效机制" class="headerlink" title="15.redis的缓存失效策略和主键失效机制"></a><strong>15.redis的缓存失效策略和主键失效机制</strong></h2><p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略。</p><p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p><p><strong>1、影响生存时间的一些操作</strong></p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p><p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p><p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key </p><p>因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p><p><strong>2、如何更新生存时间</strong></p><p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p><p>最大缓存配置</p><p>在 redis 中，允许用户设置最大使用内存大小，server。maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p><p>redis 提供 6种数据淘汰策略：</p><p><strong>volatile-lru：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p><strong>volatile-random：</strong>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p><strong>allkeys-lru：</strong>从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p><strong>allkeys-random：</strong>从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br>使用策略规则：</p><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p><p>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random<br>三种数据淘汰策略：</p><p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰。</p><h2 id="16-redis-最适合的场景"><a href="#16-redis-最适合的场景" class="headerlink" title="16.redis 最适合的场景"></a><strong>16.redis 最适合的场景</strong></h2><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别</p><p>那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p><p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p><p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><p><strong>（1）会话缓存（Session Cache）</strong></p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。</p><p>用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p><strong>（2）全页缓存（FPC）</strong></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>（3）队列</strong></p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p><strong>（4）排行榜/计数器</strong></p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”。</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES<br>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p><strong>（5）发布/订阅</strong></p><p>最后是Redis的发布/订阅功能。</p><p>发布/订阅的使用场景确实非常多，我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！<br>　　<br>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如此多功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！&lt;/p&gt;
&lt;h2 id=&quot;1-什
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis面试题" scheme="http://www.devcheng.net/tags/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义注解获取当前登录用户信息</title>
    <link href="http://www.devcheng.net/post/c0d388e.html"/>
    <id>http://www.devcheng.net/post/c0d388e.html</id>
    <published>2020-07-24T13:16:41.000Z</published>
    <updated>2020-07-24T13:20:33.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。</p><p>如果在本项目中，多处都需要获取登录用户的信息，难不成还要调用自己写的接口吗？显然不用！</p><p>以往的项目经验里，都是使用用户对应的Service获取，今天使用自定义注解对其进行数据绑定，从而获取登录用户信息。</p><h2 id="步骤一：编写自定义注解"><a href="#步骤一：编写自定义注解" class="headerlink" title="步骤一：编写自定义注解"></a><strong>步骤一：编写自定义注解</strong></h2><p>先自定义一个用于绑定登录用户信息的注解，且运行时有效。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户信息注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤二：自定义UserResolver"><a href="#步骤二：自定义UserResolver" class="headerlink" title="步骤二：自定义UserResolver"></a><strong>步骤二：自定义UserResolver</strong></h2><p>Spring boot封装了SpringMVC中的HandlerMethodArgumentResolver接口，自定义UserResolver要实现对应的2个接口。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户Resolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentUserMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断方法参数是否带有@CurrentUser注解且参数类型为User或其子类</span></span><br><span class="line"><span class="keyword">return</span> methodParameter.hasParameterAnnotation(CurrentUser.class) &amp;&amp; User.class.isAssignableFrom(methodParameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//获取当前登录用户</span></span><br><span class="line"><span class="keyword">return</span> userService.getCurrent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤三：WebMvcConfig配置自定义解析器"><a href="#步骤三：WebMvcConfig配置自定义解析器" class="headerlink" title="步骤三：WebMvcConfig配置自定义解析器"></a><strong>步骤三：WebMvcConfig配置自定义解析器</strong></h2><p>新建一个webconfig 实现 WebMvcConfigurer 接口， 需要重写 addArgumentResolvers 这个方法，初始化我们创建的操作类。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置自定义解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CurrentUserMethodArgumentResolver <span class="title">currentUserMethodArgumentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrentUserMethodArgumentResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">argumentResolvers.add(currentUserMethodArgumentResolver());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤四：编写代码测试"><a href="#步骤四：编写代码测试" class="headerlink" title="步骤四：编写代码测试"></a><strong>步骤四：编写代码测试</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getUser"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">queryUser</span><span class="params">( @CurrentUser UserInfoVO userInfo)</span> </span>&#123;</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>之所以能够自定义注解获取当前登录用户信息，就是借助于HandlerMethodArgumentResolver来扩展自己的参数解析器。</p><p>在resolveArgument接口中编写对应获取登录用户信息的逻辑代码。举个栗子，有的系统是从数据库中获取数据，有的则把对应数据放在redis中。所以在这里从不同地方获取即可。</p><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="HandlerMethodArgumentResolver" scheme="http://www.devcheng.net/tags/HandlerMethodArgumentResolver/"/>
    
      <category term="自定义注解" scheme="http://www.devcheng.net/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>重装系统如何继续恢复Hexo博客</title>
    <link href="http://www.devcheng.net/post/7fee676.html"/>
    <id>http://www.devcheng.net/post/7fee676.html</id>
    <published>2020-07-12T09:42:58.000Z</published>
    <updated>2020-07-13T13:38:52.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾的缘故，但是清理系统垃圾之后还是有卡顿的现象，干脆从新装一个系统得了。</p><p>在重装系统之前，事先把原来Hexo的文件夹都备份一下。同时，我还备份了对应的id_rsa和id_rsa.pub文件。</p><p><strong>如果要重装系统，务必要备份对应的文件！</strong></p><p>备份好对应的文件之后，开始重装系统！</p><h3 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a><strong>安装Node.js和Git</strong></h3><p>1.安装Node.js</p><p>2.安装Git</p><p>具体细节就不展开细说了，可自行为度娘！安装成功node.js和git之后，查看一下确保无问题。</p><p><img src="/images/devcheng_net_hexo_recover_001.png" alt="“伊成博客”"></p><h3 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a><strong>配置SSH key</strong></h3><p>在最上面，已经提及到了 SSH key 对应的2个文件，<br>找到路径 C:\Users\用户名.ssh 有无.ssh文件夹，没有则创建。</p><p>执行命令，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><p>因为重装系统之前已经备份id_rsa和id_rsa.pub文件,所以把这2个文件复制到.ssh文件夹内即可。</p><p>使用命令，测试是否成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_hexo_revover_002.png" alt="“伊成博客”"></p><h3 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a><strong>配置Git用户名和邮箱</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;devcheng&quot;    // 你的coding或github用户名，并非昵称</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;// 你的coding或github的注册邮箱</span><br></pre></td></tr></table></figure><h3 id="复制备份的文件夹"><a href="#复制备份的文件夹" class="headerlink" title="复制备份的文件夹"></a><strong>复制备份的文件夹</strong></h3><p>文件夹删除node_modules public .git .deploy_git</p><p><img src="/images/devcheng_net_hexo_recover_003.png" alt="“伊成博客”"></p><h3 id="和远程项目关联"><a href="#和远程项目关联" class="headerlink" title="和远程项目关联"></a><strong>和远程项目关联</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 你的hexo博客git地址</span><br></pre></td></tr></table></figure><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a><strong>安装hexo</strong></h3><p>开始执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>并没有成功的安装好hexo,于是从新换一个命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>依然还是提示有对应的依赖没有找到，于是我把最开始备份的整个文件夹，全部都复制到了现在这个目录。</p><p><img src="/images/devcheng_net_hexo_recover_004.png" alt="“伊成博客”"></p><h3 id="强势启动"><a href="#强势启动" class="headerlink" title="强势启动"></a><strong>强势启动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>突然发现，居然可以启动起来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>以上步骤，仅供参考，步骤不是惟一定死的，各位务必根据自己的操作情况而定。这篇博客就是从重装系统之后写的第一篇博文！<br>如有不妥之处，请留言！</p><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="恢复Hexo" scheme="http://www.devcheng.net/tags/%E6%81%A2%E5%A4%8DHexo/"/>
    
      <category term="重装系统" scheme="http://www.devcheng.net/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中按字段查询重复数据</title>
    <link href="http://www.devcheng.net/post/4dfd5416.html"/>
    <id>http://www.devcheng.net/post/4dfd5416.html</id>
    <published>2020-07-09T13:37:57.000Z</published>
    <updated>2020-07-09T13:48:17.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug(没有对数据做重复数据校验)等。</p><p>既然是难免的情况，那如何处理呢？</p><h2 id="根据一个字段查询重复数据"><a href="#根据一个字段查询重复数据" class="headerlink" title="根据一个字段查询重复数据"></a>根据一个字段查询重复数据</h2><p>举个栗子，有个用户表测试小姐姐拼命的创建同一条数据插入到用户表。<br>那么在用户表中就会存在相同用户名的多条数据，根据 用户名 查询重复数据的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> userName <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果查询出来重复数据只需要保留一条，那就得把多余的数据删除即可，对应SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName);</span><br></pre></td></tr></table></figure><p>这里是根据 用户名分组保留用户ID最大的那条数据，其它的都删掉！<br>具体保留哪条数据，各位小伙伴可自行决定~</p><h2 id="根据多个字段查询重复数据"><a href="#根据多个字段查询重复数据" class="headerlink" title="根据多个字段查询重复数据"></a>根据多个字段查询重复数据</h2><p>在举个栗子，在这个用户表中 用户名和用户类型 都重复的需要查询出来，对应的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据多个字段查询，保留一条数据，删除多余数据SQL如下：</p><p>方法一：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType);</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nameAndType <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user) tt <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType <span class="keyword">HAVING</span> <span class="keyword">count</span>(nameAndType) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>方法三：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> maxid <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(userId) <span class="keyword">as</span> maxid, <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType) t);</span><br></pre></td></tr></table></figure></p><p>方法一中删除多余重复数据和上面文章中的思路是一致的，方法二和方法三的思路是利用CONCAT函数。</p><p>以上，如果你开发过程中遇到同样问题，可以使用上面的SQL尝试一下！</p><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL" scheme="http://www.devcheng.net/tags/MySQL/"/>
    
      <category term="重复数据" scheme="http://www.devcheng.net/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java8中列表的排序(升序、降序)</title>
    <link href="http://www.devcheng.net/post/835182f7.html"/>
    <id>http://www.devcheng.net/post/835182f7.html</id>
    <published>2020-07-02T13:34:11.000Z</published>
    <updated>2020-07-02T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来。</p><p>时过境迁，现在的项目中采用了Spring Data JPa,当然也支持排序。但本文中的主角可不是它，在很多情况下我们查询出来的List数据没有排序好或是需要二次按照某字段排序，这个时候，我们就可以使用Java8对其排序。</p><p>首先，看个基础语法，如下：</p><h3 id="单个字段排序"><a href="#单个字段排序" class="headerlink" title="单个字段排序"></a>单个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回 对象集合以类属性一升序排序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序排序 注意两种写法</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">//先以属性一升序,结果进行属性一降序</span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一).reversed());</span></span><br><span class="line"><span class="comment">//以属性一降序 </span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));</span></span><br></pre></td></tr></table></figure><h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 对象集合以类属性一升序 属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span></span><br><span class="line"> list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一升序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,再进行属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(Comparator.comparing(User::getId).reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(User::getId,Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以实例代码我们可以发现</p><p>写法一： Comparator.comparing(类::属性一).reversed();</p><p>写法二： Comparator.comparing(类::属性一,Comparator.reverseOrder());</p><p>两种排序是完全不一样的,一定要区分开来。</p><p>写法一是得到排序结果后再排序；</p><p>写法二是直接进行排序,很多人会混淆导致理解出错,但写法二更好理解,建议使用写法二。</p><h2 id="完整例子demo"><a href="#完整例子demo" class="headerlink" title="完整例子demo"></a>完整例子demo</h2><p>最后贴一个完整的例子，供大家参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">22</span>,<span class="string">"张X"</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">27</span>,<span class="string">"李X"</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"王X"</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">"赵X"</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    list.add(user4);</span><br><span class="line">    <span class="keyword">for</span>(User u :list)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; newList = list.stream().sorted(Comparator.comparing(User::getAge))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">for</span>(User u :newList)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
      <category term="排序" scheme="http://www.devcheng.net/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中三大构建工具的发展历程（Ant、Maven和Gradle）</title>
    <link href="http://www.devcheng.net/post/e200ec64.html"/>
    <id>http://www.devcheng.net/post/e200ec64.html</id>
    <published>2020-06-21T07:47:09.000Z</published>
    <updated>2020-06-21T07:49:21.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们要写一个Java程序，一般的步骤是编译，测试，打包。</p><p>这个构建的过程，如果文件比较少，我们可以手动使用java, javac,jar命令去做这些事情。但当工程越来越大，文件越来越多，这个事情就不是那么地令人开心了。</p><p>因为这些命令往往都是很机械的操作。所以我们可以把这些机械的操作交给机器去做。</p><p>而在linux中，有一个工具叫make。<br>我们可以通过编写Makefile来执行工程的构建，在windows上相应的工具是nmake。</p><p>那既然有现成的工具，为什么当时没有选择Makefile呢？说道这里那就不得不提一下Ant了。</p><h2 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h2><p>说起Ant，就不得不说另一个Apache开源项目Tomcat。Tomcat作为轻量级Web容器，早已声名鹊起。最开始的时候，Ant是Tomcat的一部分，Ant的唯一目的就是build Tomcat。</p><p>不久，很多Java开源项目意识到Ant的简洁适用，更重要的是弥补Makefiles的不足。自从Jakarta以及Apache项目开始采用Ant以来,作为构建工具的Ant很快发展在各种各样的项目中。</p><p>在2000年1月，Ant脱离了Tomcat，成为独立的Apache开源项目，由独立的CVS模块维护，正式更名为Apache Ant。</p><p>第一个Ant版本是Tomcat 3.1于2000年4月19日发行的版本。此版本后来称为Ant 0.3.1。</p><p>到目前Ant最新的版本是 <strong>2020年5月13日 版本号：1.10.8</strong></p><p>具体的版本发行历程可点击链接查看 <a href="http://ant.apache.org/faq.html" target="_blank" rel="noopener">http://ant.apache.org/faq.html</a></p><h3 id="Ant示例"><a href="#Ant示例" class="headerlink" title="Ant示例"></a>Ant示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"HelloWorld"</span> <span class="attr">default</span>=<span class="string">"run"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">value</span>=<span class="string">"src"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dest"</span> <span class="attr">value</span>=<span class="string">"classes"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jarfile"</span> <span class="attr">value</span>=<span class="string">"hello.jar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;jarfile&#125;"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">depends</span>=<span class="string">"build"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">java</span> <span class="attr">classname</span>=<span class="string">"test.ant.HelloWorld"</span> <span class="attr">classpath</span>=<span class="string">"$&#123;hello_jar&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;hello_jar&#125;"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例，得知Ant定义了五个任务，init, compile, build, test,clean。</p><p>每个任务做什么都定义清楚了。在打包之前要先编译，所以通过depends来指定依赖的路径。</p><p>如果在命令行里执行ant build，那就会先执行compile，而compile又依赖于init，所以就会先执行init。</p><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant test</span><br></pre></td></tr></table></figure></p><p>通过命令就可以执行编程，打包，测试。为开发者带来了很大的便利，提供了工作效率。</p><p>但是Ant有一个很致命的缺陷，那就是没办法管理依赖。</p><p>我们一个工程，要使用很多第三方工具，不同的工具，不同的版本。</p><p>每次打包都要自己手动去把正确的版本拷到lib下面去，不用说，这个工作既枯燥还特别容易出错。为了解决这个问题，Maven如约而至。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven之前我们经常使用Ant来进行Java项目的构建，然后Ant仅是一个构建工具，它并未对项目的中的工程依赖以及项目本身进行管理，并且Ant作为构建工具未能消除软件构建的重复性，因为不同的项目需要编写对应的Ant任务。</p><p>Maven作为后来者，继承了Ant的项目构建功能，并且提供了依赖关系，项目管理的功能，因此它是一个项目管理和综合工具， 其核心的依赖管理， 项目信息管理， 中央仓库，约定大于配置的核心功能使得Maven成为当前Java项目构建和管理工具的标准选择。</p><p>Maven 发展历程： Maven –&gt; Maven2 –&gt; Maven3</p><p>到目前Maven最新的版本是 <strong>2019-11-25 版本号：3.6.3</strong></p><h3 id="Maven示例"><a href="#Maven示例" class="headerlink" title="Maven示例"></a>Maven示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...xmlns...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devcheng.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例得知，包的坐标是net.devcheng.demo:Example:0.1.0-SNAPSHOT，而工程中要依赖junit:junit:4.10。</p><p>那么Maven就会自动去帮我把junit打包进来。如果本地没有junit，maven还会帮自动去网上下载。我们还通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。</p><p>相对于上文中的Ant来说，Maven抛弃了Ant中通过target定义任务的做法，对于依赖引入了生命周期。</p><p>最后在说说 Gradle。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Gradle是一个基于Apache Ant和ApacheMaven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。</p><p>由以上定义得知，Gradle已经抛弃了Ant,Maven中Xml配置的形式。Gradle继承了Maven中仓库，坐标，依赖这些核心概念。文件的布局也和Maven相同。但同时，又继承了Ant中target的概念，我们又可以重新定义自己的任务(在Gradle中叫做task)。</p><h3 id="Gradle示例"><a href="#Gradle示例" class="headerlink" title="Gradle示例"></a>Gradle示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;</span><br><span class="line">    your tests.</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由示例可看出内容很简单，引入了java插件，指定仓库，指定依赖。可以看到依赖的设定相比起xml的写法，变得大大简化了。</p><p>到目前Gradle最新的版本是 <strong>2020年6月2日 版本号：v6.5</strong></p><h3 id="Gradle-vs-Maven"><a href="#Gradle-vs-Maven" class="headerlink" title="Gradle vs Maven"></a>Gradle vs Maven</h3><p>关于Gradle和Maven的区别，简单比较如下：</p><ul><li><p>Maven和Gradle对依赖项的scope有所不同。<br>在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。<br>而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。</p></li><li><p>Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</p></li><li>解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确。</li><li>Maven引用依赖方面采用的xml，而Gradle不是。</li></ul><hr><h6 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们要写一个Java程序，一般的步骤是编译，测试，打包。&lt;/p&gt;
&lt;p&gt;这个构建的过程，如果文件比较少，我们可以手动使用java, java
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Ant" scheme="http://www.devcheng.net/tags/Ant/"/>
    
      <category term="Maven" scheme="http://www.devcheng.net/tags/Maven/"/>
    
      <category term="Gradle" scheme="http://www.devcheng.net/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>java通过反射获取注解@Column中的信息</title>
    <link href="http://www.devcheng.net/post/74b831b2.html"/>
    <id>http://www.devcheng.net/post/74b831b2.html</id>
    <published>2020-06-20T02:44:08.000Z</published>
    <updated>2020-06-20T02:49:43.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devcheng.demo.restful.data.service.model.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonDeserialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"DEV_CHENG_FILE_DEMO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscloseFileEntity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ID"</span>,columnDefinition = <span class="string">"ID"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"APPLY_NO"</span>,columnDefinition = <span class="string">"申请号"</span>)</span><br><span class="line">    <span class="keyword">private</span> String applyNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_NAME"</span>,columnDefinition = <span class="string">"文件名称"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_SIZE"</span>,columnDefinition = <span class="string">"文件大小"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileSize;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"TITLE"</span>,columnDefinition = <span class="string">"标题"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"IS_VALID"</span>,columnDefinition = <span class="string">"是否有效"</span>)</span><br><span class="line">    <span class="keyword">private</span> String isValid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"SAVE_DATE"</span>,columnDefinition = <span class="string">"保存日期"</span>)    </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime saveDate;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上得知，需要从 @Column 注解中获取 name和columnDefinition 中的信息，那如何可以获取到对应的信息？</p><p>在获取 @Column 注解中的信息之前，先看看 columnDefinition是啥意思?</p><h2 id="columnDefinition"><a href="#columnDefinition" class="headerlink" title="columnDefinition"></a>columnDefinition</h2><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用。</p><p>值得注意的一点是：在编程语言中字符串一般都用String表示，但是数据库中varcahr数值类型有长度限制，一旦需要大文本，则需要text数值类型。但是String类型默认映射的数值类型是varchar，columnDefinition可以进行额外指定。</p><h2 id="获取注解-Column中的信息"><a href="#获取注解-Column中的信息" class="headerlink" title="获取注解@Column中的信息"></a>获取注解@Column中的信息</h2><p>实现思路：通过类路径利用反射获取到对应的注解信息，从而获取到对应@Column中的信息<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TableColumnsVO&gt; <span class="title">getFiledAndAnnotateInfo</span><span class="params">(String entityPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TableColumnsVO&gt; tableColumnsLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(entityPath);</span><br><span class="line">            Field[] fields = aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">            Column presentColumn;</span><br><span class="line">            <span class="keyword">for</span> (Field field:fields)</span><br><span class="line">            &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(Column.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    presentColumn = field.getDeclaredAnnotation(Column.class);</span><br><span class="line">                    TableColumnsVO tableData = <span class="keyword">new</span> TableColumnsVO();</span><br><span class="line">                    tableData.setColumnName(presentColumn.name());</span><br><span class="line">                    tableData.setColumnDefinationInfo(presentColumn.columnDefinition());</span><br><span class="line">                    tableColumnsLists.add(tableData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"获取字段和注释异常：%s"</span>, entityPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableColumnsLists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的 TableColumnsVO代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableColumnsVO</span></span>&#123;</span><br><span class="line">    <span class="comment">//列名</span></span><br><span class="line">    <span class="keyword">private</span> String columnName;</span><br><span class="line">    <span class="comment">//ColumnDefinationInfo信息</span></span><br><span class="line">    <span class="keyword">private</span> String columnDefinationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="java反射" scheme="http://www.devcheng.net/tags/java%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Column注解" scheme="http://www.devcheng.net/tags/Column%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>墙裂推荐一款redis客户端可视化工具之RedisPlus</title>
    <link href="http://www.devcheng.net/post/64102a3b.html"/>
    <id>http://www.devcheng.net/post/64102a3b.html</id>
    <published>2020-06-07T07:15:43.000Z</published>
    <updated>2020-06-07T07:23:36.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具。<br>比如：Redis Desktop Manager，RedisView ，RedisClient 等工具。</p><p>今天墙裂推荐一款redis客户端可视化工具：RedisPlus</p><h2 id="RedisPlus"><a href="#RedisPlus" class="headerlink" title="RedisPlus"></a><strong>RedisPlus</strong></h2><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h3><p>RedisPlus是为Redis可视化管理开发的一款开源免费的桌面客户端软件，支持Windows 、Linux、Mac三大系统平台，RedisPlus提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。该软件支持单机、集群模式连接，同时还支持SSH（单机、<strong>集群</strong>）通道连接。</p><p>项目地址： <a href="https://gitee.com/MaxBill/RedisPlus" target="_blank" rel="noopener">https://gitee.com/MaxBill/RedisPlus</a></p><p>运行截图：<br><img src="/images/devcheng_net_redis_001.jpg" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis_002.jpg" alt="“伊成博客”"></p><p>RedisPlus目前最新版本为：3.2.0。<br>项目介绍中得知，RedisPlus将不再更新迭代，包括V4.0的electron和jfx11版本都将停止开发和更新。</p><p>下载地址<br>百度下载：链接: <a href="https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ</a> 提取码: 3pcm</p><p><img src="/images/devcheng_net_redis_003.png" alt="“伊成博客”"></p><h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a><strong>最后说一句</strong></h2><p>在网上不乏有很多redis客户端工具，但是真正能支持集群的没几个工具，同时也找到了一款国外的工具，名字叫FastoRedis。<br>下载地址：<a href="https://fastoredis.com/anonim_users_downloads" target="_blank" rel="noopener">https://fastoredis.com/anonim_users_downloads</a></p><p>FastoRedis 的官方介绍<br>Download FastoRedis - cross-platform client for Redis, supported main Redis database features like: modules, cluster, sentinel, ssh tunneling.</p><p>但是这款工具是收费的，土豪请无视这句话！</p><p>最后有需要RedisPlus的又觉得从百度网盘下载麻烦的，可以加一下我的QQ群：816175200 免费获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="RedisPlus" scheme="http://www.devcheng.net/tags/RedisPlus/"/>
    
      <category term="redis客户端" scheme="http://www.devcheng.net/tags/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本新特性小结</title>
    <link href="http://www.devcheng.net/post/5ae138f6.html"/>
    <id>http://www.devcheng.net/post/5ae138f6.html</id>
    <published>2020-05-30T07:07:22.000Z</published>
    <updated>2020-05-30T07:08:50.691Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天(2020-5-30)JDK已经发布到了 JDK14。</p><p>在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。</p><p>JDK 14已经于2020年3月17日如期发布。下面介绍各个版本的新特性，后续随着JDK新版本的更新迭代，本文会持续更新。</p><p>JDK从1.5版本开始，在官方的正式文档与宣传资料中已经不再使用类似JDK1.5的名称，只有程序员内部</p><p>使用的开发版本号(DeveloperVersion，例如java-version的输出)才继续沿用1.5、1.6、1.7和1.8的版本号，</p><p>而公开版本号(Product Version)则改为JDK5、JDK6、JDK7和JDK8的命名方式。</p><h2 id="JDK-5-新特性"><a href="#JDK-5-新特性" class="headerlink" title="JDK 5 新特性"></a>JDK 5 新特性</h2><p>1.自动装箱、拆箱</p><p>2.静态导入(static import)</p><p>3.增强for循环（for-each）</p><p>4.可变参数</p><p>5.枚举（enmu）</p><p>6.泛型</p><p>7.元数据</p><p>8.线程并发库（JUC）</p><hr><h2 id="JDK-6-新特性"><a href="#JDK-6-新特性" class="headerlink" title="JDK 6 新特性"></a>JDK 6 新特性</h2><p>1.AWT中新增的两个类Desktop和SystemTray</p><p>2.使用JAXB2来实现对象与XML之间的映射</p><ol start="3"><li><p>新增处理DOM和SAX之外又一种处理XML文档的API：STAX</p></li><li><p>使用Compiler API动态编译java源文件</p></li><li><p>轻量级Http Server API</p></li><li><p>插入式注解处理API（用于处理Annotations）</p></li><li><p>用Console开发控制台程序</p></li><li><p>对ruby、groovy、javascript等脚本语言的支持</p></li><li><p>Common Annotations</p></li></ol><hr><h2 id="JDK-7-新特性"><a href="#JDK-7-新特性" class="headerlink" title="JDK 7 新特性"></a>JDK 7 新特性</h2><ol><li><p>对Java集合（Collections）的增强支持</p></li><li><p>在switch中可用String</p></li><li><p>数值可加下划线（eg:int one_million=123_1）</p></li><li><p>支持二进制文字（int binary=0b1001_1001）</p></li><li><p>简化可变参数方法的调用</p></li><li><p>自动资源管理</p></li><li><p>类型推断</p></li><li><p>catch 多个类型异常</p></li></ol><hr><h2 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h2><ol><li><p>Stream函数式操作流元素集合</p></li><li><p>Lambda表达式</p></li><li><p>新的日期时间 API(Java Date/time API)</p></li><li><p>新增接口：默认方法与静态方法</p></li><li><p>Nashorm(Rhino的接替者，轻量级高性能的javascript运行环境)</p></li><li><p>Accumlators多线程lock</p></li><li><p>方法引用，与Lambda表达式联合使用</p></li><li><p>引入重复注解和类型注解</p></li><li><p>类型注解</p></li><li><p>新增base64加解密API</p></li><li><p>数组并行（parallel）操作</p></li><li><p>JVM的permGen空间移除，被Metaspace元空间取代</p></li></ol><hr><h2 id="JDK-9-新特性"><a href="#JDK-9-新特性" class="headerlink" title="JDK 9 新特性"></a>JDK 9 新特性</h2><ol><li><p>目录结构</p></li><li><p>模块化系统</p></li><li><p>jshell</p></li><li><p>多版本兼容JAR</p></li><li><p>接口的私有方法</p></li><li><p>改进try-with-resourcs</p></li><li><p>改进砖石操作符</p></li><li><p>限制使用单独下划线标识符</p></li><li><p>String存储结构变更</p></li><li><p>快速创建只读结合</p></li><li><p>增强Stream API</p></li><li><p>改进Optional 类</p></li><li><p>多分辨率图像 API</p></li><li><p>全新 HTTP客服端API</p></li><li><p>智能JAVA 编译工具</p></li><li><p>统一JVM 日志系统</p></li><li><p>javadoc 的 HTML5 支持</p></li><li><p>java 动态编译</p></li></ol><hr><h2 id="JDK-10-新特性"><a href="#JDK-10-新特性" class="headerlink" title="JDK 10 新特性"></a>JDK 10 新特性</h2><ol><li><p>局部变量类型推断</p></li><li><p>将JDK多存储库合并为单储存库</p></li><li><p>垃圾回收接口</p></li><li><p>并行Full GC 的G1</p></li><li><p>应用数据共享</p></li><li><p>线程局部管控</p></li><li><p>移除Native-Header Generation Tool （javah）</p></li><li><p>Unicode 标签扩展</p></li><li><p>备用内存设备上分配堆内存</p></li><li><p>基于实验JAVA 的JIT 编译器</p></li><li><p>Root 证书</p></li><li><p>基于时间的版本控制</p></li></ol><hr><h2 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h2><ol><li><p>字符串加强</p></li><li><p>HttClient Api</p></li><li><p>用于 Lambda 参数的局部变量语法</p></li><li><p>ZGC (并发回收的策略)</p></li></ol><hr><h2 id="JDK-12-新特性"><a href="#JDK-12-新特性" class="headerlink" title="JDK 12 新特性"></a>JDK 12 新特性</h2><ol><li><p>Switch Expressions</p></li><li><p>Shenandoah GC (GC 算法)</p></li></ol><hr><h2 id="JDK-13-新特性"><a href="#JDK-13-新特性" class="headerlink" title="JDK 13 新特性"></a>JDK 13 新特性</h2><ol><li><p>switch优化更新</p></li><li><p>文本块升级</p></li><li><p>重新实现旧版套接字API</p></li><li><p>核心库/java.util中：I18N</p></li><li><p>增加ZGC以将未使用的堆内存返回给操作系统</p></li></ol><hr><h2 id="JDK-14-新特性"><a href="#JDK-14-新特性" class="headerlink" title="JDK 14 新特性"></a>JDK 14 新特性</h2><ol><li><p>switch优化变更为最终版</p></li><li><p>垃圾回收相</p></li></ol><ul><li>删除cms垃圾收集器</li><li>弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合</li><li>将 zgc 垃圾回收器移植到 macOS 和 windows 平台 </li></ul><ol start="3"><li><p>instanceof的模式匹配（预览版）</p></li><li><p>删除了安全库java.security.acl API</p></li><li><p>货币格式（优化）</p></li><li><p>友好的空指针异常</p></li><li><p>外部存储器API（孵化）</p></li></ol><p>… </p><p><strong> 本文会持续更新… </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;截止到今天(2020-5-30)JDK已经发布到了 JDK14。&lt;/p&gt;
&lt;p&gt;在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。&lt;/p&gt;
&lt;p&gt;JDK 14已经于2020年3月17日如期发
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="新特性" scheme="http://www.devcheng.net/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK" scheme="http://www.devcheng.net/tags/JDK/"/>
    
  </entry>
  
</feed>
