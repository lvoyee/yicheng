<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人博客网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2020-10-06T14:08:35.232Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于SpringBoot开发图书管理系统源码分享</title>
    <link href="http://www.devcheng.net/post/931cd25c.html"/>
    <id>http://www.devcheng.net/post/931cd25c.html</id>
    <published>2020-10-06T13:32:33.000Z</published>
    <updated>2020-10-06T14:08:35.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚入门SpringBoot的朋友！</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a><strong>功能描述</strong></h2><p>项目分为管理员和非管理员两种角色，其中非管理员包含：教师和学生。</p><p>在项目中管理员主要拥有的功能有：书籍管理（图书管理、借书审核、查看已借出书籍、查看换书），用户管理（学生管理、教师管理），部门管理（班级管理、学院管理），设置（修改密码、查看个人信息、操作日志、退出）。</p><p>在项目非管理员拥有的功能：借阅图书管理（借书、已借书及还书、正审核的图书），设置（修改密码、查看个人信息、退出）。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot 2.0.6.RELEASE</li><li>SpringDataJpa</li><li>Maven 3.X</li><li>Bootstarp</li><li>EasyUI</li><li>Mysql</li><li>thymeleaf</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>管理员账户和密码： admin6 / admin6</p><p>学生账户和密码：  guliduo / guliduo</p><h2 id="系统展示图"><a href="#系统展示图" class="headerlink" title="系统展示图"></a><strong>系统展示图</strong></h2><p><img src="/images/book01.png" alt="“伊成博客”"></p><p><img src="/images/book02.png" alt="“伊成博客”"></p><p><img src="/images/book03.png" alt="“伊成博客”"></p><p><img src="/images/book04.png" alt="“伊成博客”"></p><p><img src="/images/book05.png" alt="“伊成博客”"></p><p><img src="/images/book06.png" alt="“伊成博客”"></p><p><img src="/images/book07.png" alt="“伊成博客”"></p><p><img src="/images/book08.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！ 备注：图书管理系统</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖怪请绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于SpringBoot开发图书管理系统，可以当作毕业设计、期末课程作业、课间小作业等，也使用刚刚
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="在线图书管理系统" scheme="http://www.devcheng.net/tags/%E5%9C%A8%E7%BA%BF%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Class org.springframework.util.ReflectionUtils can not access a member of class异常</title>
    <link href="http://www.devcheng.net/post/50c55201.html"/>
    <id>http://www.devcheng.net/post/50c55201.html</id>
    <published>2020-09-28T09:34:25.000Z</published>
    <updated>2020-09-28T09:57:08.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020-09-25 14:02:03.393 ERROR 13920 --- [nio-8400-exec-3] c.s.b.d.support.utils.ExceptionUtils :</span><br><span class="line"> Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of class com.xxx.model.entity.XxxEntity with modifiers &quot;private&quot;; </span><br><span class="line"> nested exception is java.lang.IllegalStateException: Could not access method: </span><br><span class="line"> Class org.springframework.util.ReflectionUtils can not access a member of </span><br><span class="line"> class com.xxx.Entity with modifiers &quot;private&quot;</span><br></pre></td></tr></table></figure><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>为了完整的说明这个异常，简单的看一下代码：</p><p><strong>Entity 类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.xxx.reflect;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private void add()&#123;</span><br><span class="line">        System.out.println(&quot;add method...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(int id, String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接运行 main 方法则会报这个异常 Class . can not access a member of class . with modifiers “private” 。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置Field对象的Accessible的访问标志位为Ture，就可以通过反射获取私有变量的值，在访问时会忽略访问修饰符的检查。</p><p>所以只需要加上这行代码即可！</p><p><strong>Main类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Class c1=Student.class;</span><br><span class="line">        Object obj=(Object)c1.newInstance();</span><br><span class="line"></span><br><span class="line">        Method  method = c1.getDeclaredMethod(&quot;add&quot;);</span><br><span class="line">method.setAccessible(true); // 加上这句即可解决问题！</span><br><span class="line">        method.invoke((Student)obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，工作中多个地方用到了Java反射调用私有方法，但如果不小心很容易出错，下面看看异常信息&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="异常" scheme="http://www.devcheng.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁</title>
    <link href="http://www.devcheng.net/post/c72647c7.html"/>
    <id>http://www.devcheng.net/post/c72647c7.html</id>
    <published>2020-09-25T12:53:55.000Z</published>
    <updated>2020-09-25T13:03:42.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大白话之乐观锁和悲观锁"><a href="#大白话之乐观锁和悲观锁" class="headerlink" title="大白话之乐观锁和悲观锁"></a>大白话之乐观锁和悲观锁</h2><p>用大白话解释什么是乐观锁好悲观锁如下：</p><p>乐观锁对应于生活中乐观的人总是想着事情会往好的方向发展。</p><p>悲观锁对应于生活中悲观的人总是想着事情会往坏的方向发展。</p><h3 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁 (Optimistic Locking)"></a>乐观锁 (Optimistic Locking)</h3><p>假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p><h3 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁 (Pessimistic Lock)"></a>悲观锁 (Pessimistic Lock)</h3><p>悲观其实是我们人类一种消极的情绪，对应到锁的悲观情绪，悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后（可以理解为一个用户），其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁以及 Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>悲观锁一般多写的场景下</strong>用就比较合适。</p><h2 id="乐观的两种实现方式"><a href="#乐观的两种实现方式" class="headerlink" title="乐观的两种实现方式"></a>乐观的两种实现方式</h2><ul><li>版本号机制<br>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li></ul><p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>1.操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（100-$50 ）。</p><p>2.在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（100-$20 ）。</p><p>3.操作员 A 完成了修改工作，将数据版本号（ version=1 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</p><p>4.操作员 B 完成了操作，也将版本号（ version=1 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</p><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><ul><li>CAS算法<br>即<strong>compare and swap</strong>（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</li></ul><p>CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li><li>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。</li></ul><p>一般情况下是一个自旋操作，即不断的重试。</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><p>ABA 问题是乐观锁一个常见的问题。</p><p><strong>1 ABA 问题</strong></p><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p><p>这个问题被称为CAS操作的 <strong>“ABA”问题</strong>。</p><p>JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少）<br>synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；<br>而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由上文的介绍，相信大家都有一定的认识了，在实际工作中如何选择得需要看对应的业务场景，但随着互联网三高架构(高并发、高性能、高可用)的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p><hr><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#大白话之乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;大白话之乐观锁和悲观锁&quot;&gt;&lt;/a&gt;大白话之乐观锁和悲观锁&lt;/h2&gt;&lt;p&gt;用大白话解释什么是乐观锁好悲观锁如下：&lt;/p&gt;
&lt;p&gt;乐观锁对应于生
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="乐观锁" scheme="http://www.devcheng.net/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="悲观锁" scheme="http://www.devcheng.net/tags/%E6%82%B2%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如果面试官问你“你有什么问题问我吗？”时，你该如何回答</title>
    <link href="http://www.devcheng.net/post/185dcb3e.html"/>
    <id>http://www.devcheng.net/post/185dcb3e.html</id>
    <published>2020-09-22T13:35:33.000Z</published>
    <updated>2020-09-22T14:05:06.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了你这么多问题了，你有什么问题问我吗？”。</p><p>这个时候很多人内心就会陷入短暂的纠结中：我该问吗？不问的话面试官会不会对我影响不好？问什么问题？问这个问题会不会让面试官对我的影响不好啊？</p><h2 id="这个问题对最终面试结果的影响到底大不大"><a href="#这个问题对最终面试结果的影响到底大不大" class="headerlink" title="这个问题对最终面试结果的影响到底大不大?"></a>这个问题对最终面试结果的影响到底大不大?</h2><p>就技术面试而言，回答这个问题的时候，只要你不是触碰到你所面试的公司的雷区，那么我觉得这对你能不能拿到最终offer来说影响确实是不大的。</p><p>我说这些并不代表你就可以直接对面试官说：“我没问题了。”，个人当时面试的时候确实也说过挺多次“没问题要问了。”，最终也没有导致笔主被pass掉（可能是前面表现比较好，哈哈，自恋一下）。我现在回想起来，觉得自己当时做法其实挺不对的。</p><p>面试本身就是一个双向选择的过程，你对这个问题的回答也会侧面反映出你对这次面试的上心程度，你的问题是否有价值，也影响了你最终的选择与公司是否选择你。</p><p>面试官在技术面试中主要考察的还是你这样个人到底有没有胜任这个工作的能力以及你是否适合公司未来的发展需要，很多公司还需要你认同它的文化。</p><p>我觉得你只要不是太笨，应该不会栽在这里。除非你和另外一个人在能力上相同，但是只能在你们两个人中选一个，那么这个问题才对你能不能拿到offer至关重要。有准备总比没准备好，给面试官留一个好的影响总归是没错的。</p><p>但是，就非技术面试来说，我觉得好好回答这个问题对你最终的结果还是比较重要的。</p><p>总的来说不管是技术面试还是非技术面试，如果你想赢得公司的青睐和尊重，我觉得我们都应该重视这个问题。</p><h2 id="真诚一点-不要问太-Low-的问题"><a href="#真诚一点-不要问太-Low-的问题" class="headerlink" title="真诚一点,不要问太 Low 的问题"></a>真诚一点,不要问太 Low 的问题</h2><p>回答这个问题很重要的一点就是你没有必要放低自己的姿态问一些很虚或者故意讨好面试官的问题，也不要把自己从面经上学到的东西照搬下来使用。</p><p>面试官也不是傻子，特别是那种特别有经验的面试官，你是真心诚意的问问题，还是从别处照搬问题来讨好面试官，人家可能一听就听出来了。</p><p>总的来说，还是要真诚。</p><p>除此之外，不要问太 Low 的问题，会显得你整个人格局比较小或者说你根本没有准备（侧面反映你对这家公司不上心，既然你不上心，为什么要要你呢）。</p><p>举例几个比较 Low 的问题，大家看看自己有没有问过其中的问题：</p><ul><li>贵公司的主要业务是什么？（面试之前自己不知道提前网上查一下吗？）</li><li>贵公司的男女比例如何？（考虑脱单？记住你是来工作的！）</li><li>贵公司一年搞几次外出旅游？（你是来工作的，这些娱乐活动先别放在心上！）</li><li>……</li></ul><h2 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h2><p>针对这个问题。笔主专门找了几个专门做HR工作的小哥哥小姐姐们询问并且查阅了挺多前辈们的回答，然后结合自己的实际经历，我概括了下面几个比较适合问的问题。</p><p><strong>面对HR或者其他Level比较低的面试官时</strong></p><p><strong>1.能不能谈谈你作为一个公司老员工对公司的感受?</strong> (这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离。)</p><p><strong>2.能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你？有什么地方你觉得还不太好或者可以继续完善吗？</strong> （类似第一个问题，都是问面试官个人对于公司的看法。）</p><p><strong>3.我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进。)</p><p><strong>4.接下来我会有一段空档期，有什么值得注意或者建议学习的吗？</strong> （体现出你对工作比较上心，自助学习意识比较强。）</p><p><strong>5.这个岗位为什么还在招人？</strong> (岗位真实性和价值咨询)</p><p><strong>6.大概什么时候能给我回复呢？</strong>(终面的时候，如果面试官没有说的话，可以问一下)</p><p><strong>7…….</strong></p><p><strong>面对部门领导</strong></p><p><strong>1.部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong></p><p><strong>2.未来如果我要加入这个团队，你对我的期望是什么？</strong> （部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</p><p><strong>3.公司对新入职的员工的培养机制是什么样的呢？</strong>（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</p><p><strong>4.以您来看，这个岗位未来在公司内部的发展如何？</strong> (在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？)</p><p><strong>5.团队现在面临的最大挑战是什么？</strong> (这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期。)</p><p><strong>面对Level比较高的(比如总裁,老板)</strong></p><p><strong>1.贵公司的发展目标和方向是什么？</strong> （看下公司的发展是否满足自己的期望）</p><p><strong>2.与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong> （充分了解自己的优势和劣势）</p><p><strong>3.公司现在面临的最大挑战是什么？</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>薪酬待遇和相关福利问题一般在终面的时候（最好不要在前面几面的时候就问到这个问题），面试官会提出来或者在面试完之后以邮件的形式告知你。一般来说，如果面试官很愿意为你回答问题，对你的问题也比较上心的话，那他肯定是觉得你就是他们要招的人。</p><p>大家在面试的时候，可以根据自己对于公司或者岗位的了解程度，对上面提到的问题进行适当修饰或者修改。</p><p>上面提到的一些问题只是给没有经验的朋友一个参考，如果你还有其他比较好的问题的话，那当然也更好啦！</p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;又是一年一度的“金九银十”跳槽季，我还记得当时我去参加面试的时候，几乎每一场面试，特别是HR面和高管面的时候，面试官总是会在结尾问我:“问了
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="面试" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试经验" scheme="http://www.devcheng.net/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>你是否因为命名被diss过？</title>
    <link href="http://www.devcheng.net/post/18c03ab9.html"/>
    <id>http://www.devcheng.net/post/18c03ab9.html</id>
    <published>2020-09-18T10:56:03.000Z</published>
    <updated>2020-09-18T11:27:16.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。<br>就连世界级软件大师 Martin Fowler 大神都说过 CS 领域有两大最难的事情，一是缓存失效，一是程序命名。</p><p><img src="/images/marting-naming-1.png" alt="&quot;伊成博客&quot;"></p><h2 id="为什么需要重视命名"><a href="#为什么需要重视命名" class="headerlink" title="为什么需要重视命名"></a>为什么需要重视命名</h2><p><strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！</strong></p><p>好的命名对于其他人（包括你自己）理解你的代码有着很大的帮助！</p><p>简单举个例子说明一下命名的重要性。</p><p>《Clean Code》这本书明确指出：</p><p>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</p><p>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</p><p>举个栗子：</p><p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// check to see if the employee is eligible for full benefits</span><br><span class="line">if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; 65))</span><br></pre></td></tr></table></figure><p>应替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure><h2 id="常见命名规则以及适用场景"><a href="#常见命名规则以及适用场景" class="headerlink" title="常见命名规则以及适用场景"></a>常见命名规则以及适用场景</h2><p>这里只介绍 3 种最常见的命名规范。</p><h3 id="驼峰命名法（CamelCase）"><a href="#驼峰命名法（CamelCase）" class="headerlink" title="驼峰命名法（CamelCase）"></a>驼峰命名法（CamelCase）</h3><p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p><h4 id="大驼峰命名法（CamelCase）"><a href="#大驼峰命名法（CamelCase）" class="headerlink" title="大驼峰命名法（CamelCase）"></a>大驼峰命名法（CamelCase）</h4><ul><li>类名需要使用大驼峰命名法（UpperCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceDiscovery、ServiceInstance、LruCacheFactory</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceDiscovery、Serviceinstance、LRUCacheFactory</span><br></pre></td></tr></table></figure><h4 id="小驼峰命名法（lowerCamelCase）"><a href="#小驼峰命名法（lowerCamelCase）" class="headerlink" title="小驼峰命名法（lowerCamelCase）"></a>小驼峰命名法（lowerCamelCase）</h4><ul><li>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）</li></ul><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getUserInfo()、createCustomThreadPool()、setNameFormat(String nameFormat)</span><br><span class="line">Uservice userService;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat)</span><br><span class="line">Uservice user_service</span><br></pre></td></tr></table></figure></p><h3 id="蛇形命名法（snake-case）"><a href="#蛇形命名法（snake-case）" class="headerlink" title="蛇形命名法（snake_case）"></a>蛇形命名法（snake_case）</h3><ul><li>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</li></ul><p>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。</p><p>蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下： “shouldGet200StatusCodoWhenRequestIsValid”。</p><p>感觉如何？ </p><p><strong>相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</strong></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void should_get_200_status_code_when_request_is_valid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void shouldGet200StatusCodoWhenRequestIsValid() &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串式命名法（kebab-case）"><a href="#串式命名法（kebab-case）" class="headerlink" title="串式命名法（kebab-case）"></a>串式命名法（kebab-case）</h3><ul><li>在串式命名法中，各个单词之间通过下划线“-”连接，比如dubbo-registry。</li></ul><p>建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。<br><img src="/images/dubbo-naming-2.png" alt="&quot;伊成博客&quot;"></p><h2 id="常见命名规范"><a href="#常见命名规范" class="headerlink" title="常见命名规范"></a>常见命名规范</h2><h3 id="Java-语言基本命名规范"><a href="#Java-语言基本命名规范" class="headerlink" title="Java 语言基本命名规范"></a>Java 语言基本命名规范</h3><p><strong>1.类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p><p><strong>2.测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong>，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。并且，<strong>测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</strong></p><p><strong>3.项目文件夹名称使用串式命名法（kebab-case）</strong>，比如dubbo-registry。</p><p><strong>4.包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连接，并且各个单词必须为单数。</strong></p><p>正例： org.apache.dubbo.common.threadlocal</p><p>反例： <del>org.apache.dubbo.common.threadLocal</del></p><p><strong>5.抽象类命名使用 Abstract 开头。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）</span><br><span class="line">public abstract class AbstractClient extends AbstractEndpoint implements Client &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>6.异常类命名使用 Exception 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义的 NoSuchMethodException（出处：Dubbo源码）</span><br><span class="line">public class NoSuchMethodException extends RuntimeException &#123;</span><br><span class="line">    private static final long serialVersionUID = -2725364246023268766L;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NoSuchMethodException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7.测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）</span><br><span class="line">public class AnnotationUtilsTest &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p><h3 id="命名易读性规范"><a href="#命名易读性规范" class="headerlink" title="命名易读性规范"></a>命名易读性规范</h3><p><strong>1.为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。</strong><br>比如 CustomThreadFactory 不可以被写成 <del>CustomTF</del> 。</p><p><strong>2.命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。</strong> 这个对应我们上面说的第 1 点。</p><p><strong>3.避免无意义的命名</strong>，你起的每一个名字都要能表明意思。</p><p>正例：UserService userService; int userCount;</p><p>反例: <del>UserService service int count</del></p><p><strong>4.避免命名过长（50 个字符以内最好）</strong>，过长的命名难以阅读并且丑陋。</p><p><strong>5.不要使用拼音，更不要使用中文。</strong> 注意：像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。</p><p>正例：discount</p><p>反例：<del>dazhe</del></p><h2 id="Codelf-变量命名神器"><a href="#Codelf-变量命名神器" class="headerlink" title="Codelf:变量命名神器?"></a>Codelf:变量命名神器?</h2><p>这是一个由国人开发的网站，网上有很多人称其为变量命名神器，大家可以自行体验一下，然后再给出自己的判断。</p><p>Codelf 提供了在线网站版本，网址：<a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">https://unbug.github.io/codelf/</a></p><p>具体使用情况如下：</p><p>我选择了 Java 编程语言，然后搜索了“序列化”这个关键词，然后它就返回了很多关于序列化的命名。</p><p><img src="/images/dubbo-naming-3.png" alt="&quot;伊成博客&quot;"></p><p>并且，Codelf 还提供了 VS code 插件，看这个评价，看来大家还是很喜欢这款命名工具的。</p><p><img src="/images/dubbo-naming-4.png" alt="&quot;伊成博客&quot;"></p><hr><p><strong>The End</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中，有太多太多让我们头疼的事情了，比如变量命名、类命名、维护其他人的代码、写测试、与其他人沟通交流等等。&lt;br&gt;就连世界级软件大师 M
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="变量命名" scheme="http://www.devcheng.net/tags/%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 注解大全，建议收藏</title>
    <link href="http://www.devcheng.net/post/2ad95350.html"/>
    <id>http://www.devcheng.net/post/2ad95350.html</id>
    <published>2020-09-09T13:15:54.000Z</published>
    <updated>2020-09-09T13:39:53.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中，用到了各种各样的注解，一直没抽时间整理过，正好今天抽时间稍微整理了一波。整理的注解都是工作中常见的，如有纰漏请留言指出！</p><h2 id="一、注解-annotations-列表"><a href="#一、注解-annotations-列表" class="headerlink" title="一、注解 (annotations) 列表"></a>一、注解 (annotations) 列表</h2><p><strong>@SpringBootApplication：</strong></p><p>包含了 @ComponentScan、@Configuration 和 @EnableAutoConfiguration 注解。</p><p>其中 @ComponentScan 让 spring Boot 扫描到 Configuration 类并把它加入到程序上下文。</p><p><strong>@Configuration</strong> 等同于 spring 的 XML 配置文件；使用 Java 代码可以检查类型安全。</p><p><strong>@EnableAutoConfiguration</strong>  自动配置。</p><p><strong>@ComponentScan</strong>  组件扫描，可自动发现和装配一些 Bean。</p><p><strong>@Component</strong> 可配合 CommandLineRunner 使用，在程序启动后执行一些基础任务。</p><p><strong>@RestController</strong> 注解是 @Controller 和 @ResponseBody 的合集, 表示这是个控制器 bean, 并且是将函数的返回值直 接填入 HTTP 响应体中, 是 REST 风格的控制器。</p><p><strong>@Autowired</strong> 自动导入。</p><p><strong>@PathVariable</strong> 获取参数。</p><p><strong>@JsonBackReference</strong> 解决嵌套外链问题。</p><p><strong>@RepositoryRestResourcepublic</strong> 配合 spring-boot-starter-data-rest 使用。</p><h2 id="二、注解-annotations-详解"><a href="#二、注解-annotations-详解" class="headerlink" title="二、注解 (annotations) 详解"></a>二、注解 (annotations) 详解</h2><p><strong>@SpringBootApplication</strong>：申明让 spring boot 自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.example.myproject;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@ResponseBody</strong>：表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用，用于构建 RESTful 的 api。</p><p>在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上 @responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。</p><p>比如异步获取 json 数据，加上 @responsebody 后，会直接返回 json 数据。</p><p>该注解一般会配合 @RequestMapping 一起使用。示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(“/test”)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String test()&#123;</span><br><span class="line">    return”ok”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@Controller</strong>：用于定义控制器类，在 spring 项目中由控制器负责将用户发来的 URL 请求转发到对应的服务接口（service 层）</p><p>关注顶级架构师公众号回复“架构整洁”，送你一份惊喜礼包。</p><p>一般这个注解在类中，通常方法需要配合注解 @RequestMapping。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(“/demoInfo”)</span><br><span class="line">publicclass DemoController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DemoInfoService demoInfoService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello(Map map)&#123;</span><br><span class="line">        System.out.println(&quot;DemoController.hello()&quot;);</span><br><span class="line">        map.put(&quot;hello&quot;,&quot;from TemplateController.helloHtml&quot;);</span><br><span class="line">        //会使用hello.html或者hello.ftl模板进行渲染显示.</span><br><span class="line">        return&quot;/hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@RestController</strong>：用于标注控制层组件 (如 struts 中的 action)，@ResponseBody 和 @Controller 的合集。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.kfit.demo.web;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(“/demoInfo2”)</span><br><span class="line">publicclass DemoController2 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return&quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>@RequestMapping</strong>：提供路由信息，负责 URL 到 Controller 中的具体函数的映射。</p><p><strong>@EnableAutoConfiguration</strong>：Spring Boot 自动配置（auto-configuration）：尝试根据你添加的 jar 依赖自动配置你的 Spring 应用。</p><p>例如，如果你的 classpath 下存在 HSQLDB，并且你没有手动配置任何数据库连接 beans，那么我们将自动配置一个内存型（in-memory）数据库”。</p><p>你可以将 @EnableAutoConfiguration 或者 @SpringBootApplication 注解添加到一个 @Configuration 类上来选择自动配置。</p><p>如果发现应用了你不想要的特定自动配置类，你可以使用 @EnableAutoConfiguration 注解的排除属性来禁用它们。</p><p><strong>@ComponentScan</strong>：表示将该类自动发现扫描组件。</p><p>个人理解相当于，如果扫描到有 @Component、@Controller、@Service 等这些注解的类，并注册为 Bean，可以自动收集所有的 Spring 组件，包括 @Configuration 类。</p><p>我们经常使用 @ComponentScan 注解搜索 beans，并结合 @Autowired 注解导入。可以自动收集所有的 Spring 组件，包括 @Configuration 类。</p><p>如果没有配置的话，Spring Boot 会扫描启动类所在包下以及子包下的使用了 @Service,@Repository 等注解的类。</p><p><strong>@Configuration</strong>：相当于传统的 xml 配置文件，如果有些第三方库需要用到 xml 文件，建议仍然通过 @Configuration 类作为项目的配置主类——可以使用 @ImportResource 注解加载 xml 配置文件。</p><p><strong>@Import</strong>：用来导入其他配置类。</p><p><strong>@ImportResource</strong>：用来加载 xml 配置文件。</p><p><strong>@Autowired</strong>：自动导入依赖的 bean</p><p><strong>@Service</strong>：一般用于修饰 service 层的组件</p><p><strong>@Repository</strong>：使用 @Repository 注解可以确保 DAO 或者 repositories 提供异常转译，这个注解修饰的 DAO 或者 repositories 类会被 ComponetScan 发现并配置，同时也不需要为它们提供 XML 配置项。</p><p><strong>@Bean</strong>：用 @Bean 标注方法等价于 XML 中配置的 bean。</p><p><strong>@Value</strong>：注入 Spring boot application.properties 配置的属性的值。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(value = “#&#123;message&#125;”)</span><br><span class="line"><span class="keyword">private</span> String message;</span><br></pre></td></tr></table></figure><p><strong>@Inject</strong>：等价于默认的 @Autowired，只是没有 required 属性；</p><p><strong>@Component</strong>：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p><strong>@Bean</strong>：相当于 XML 中的, 放在方法的上面，而不是类，意思是产生一个 bean, 并交给 spring 管理。</p><p><strong>@AutoWired</strong>：自动导入依赖的 bean。byType 方式。把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到 bean 也不报错。</p><p><strong>@Qualifier</strong>：当有多个同一类型的 Bean 时，可以用 @Qualifier(“name”) 来指定。与 @Autowired 配合使用。@Qualifier 限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value = “demoInfoService”)</span><br><span class="line"><span class="keyword">private</span> DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure><p><strong>@Resource(name=”name”,type=”type”)</strong>：没有括号内内容的话，默认 byName。与 @Autowired 干类似的事。</p><h2 id="三、JPA-注解"><a href="#三、JPA-注解" class="headerlink" title="三、JPA 注解"></a>三、JPA 注解</h2><p><strong>@Entity</strong>：@Table(name=”“)：表明这是一个实体类。一般用于 jpa 这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table 可以省略</p><p><strong>@MappedSuperClass</strong>: 用在确定是父类的 entity 上。父类的属性子类可以继承。</p><p><strong>@NoRepositoryBean</strong>: 一般用作父类的 repository，有这个注解，spring 不会去实例化该 repository。</p><p><strong>@Column</strong>：如果字段名与列名相同，则可以省略。</p><p><strong>@Id</strong>：表示该属性为主键。</p><p><strong>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator= “repair_seq”)</strong>：表示主键生成策略是 sequence（可以为 Auto、IDENTITY、native 等，Auto 表示可在多个数据库间切换），指定 sequence 的名字是 repair_seq。</p><p><strong>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)</strong>：name 为 sequence 的名称，以便使用，sequenceName 为数据库的 sequence 名称，两个名称可以一致。</p><p><strong>@Transient</strong>：表示该属性并非一个到数据库表的字段的映射, ORM 框架将忽略该属性。</p><p>如果一个属性并非数据库表的字段映射, 就务必将其标示为 @Transient, 否则, ORM 框架默认其注解为 @Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p><strong>@JsonIgnore</strong>：作用是 json 序列化时将 Java bean 中的一些属性忽略掉, 序列化和反序列化都受影响。</p><p><strong>@JoinColumn（name=”loginId”）</strong>: 一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p><strong>@OneToOne、@OneToMany、@ManyToOne</strong>：对应 hibernate 配置文件中的一对一，一对多，多对一。</p><h2 id="四、springMVC-相关注解"><a href="#四、springMVC-相关注解" class="headerlink" title="四、springMVC 相关注解"></a>四、springMVC 相关注解</h2><p><strong>@RequestMapping</strong>：@RequestMapping(“/path”)表示该控制器处理所有 “/path” 的 UR L 请求。</p><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><p>params: 指定 request 中必须包含某些参数值是，才让该方法处理。</p><p>headers: 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</p><p>value: 指定请求的实际地址，指定的地址可以是 URI Template 模式</p><p>method: 指定请求的 method 类型， GET、POST、PUT、DELETE 等</p><p>consumes: 指定处理请求的提交内容类型（Content-Type），如 application/json,text/html;</p><p>produces: 指定返回的内容类型，仅当 request 请求头中的 (Accept) 类型中包含该指定类型才返回</p><p><strong>@RequestParam</strong>：用在方法的参数前面。<br>@RequestParam<br>String a =request.getParameter(“a”)。</p><p><strong>@PathVariable</strong>: 路径变量。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(“user/get/mac/&#123;macAddress&#125;”)</span><br><span class="line">public String getByMacAddress(@PathVariable String macAddress)&#123;</span><br><span class="line">    //do something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数与大括号里的名字一样要相同。</p><h2 id="五、全局异常处理"><a href="#五、全局异常处理" class="headerlink" title="五、全局异常处理"></a>五、全局异常处理</h2><p><strong>@ControllerAdvice</strong>：包含 @Component。可以被扫描到。统一处理异常。</p><p><strong>@ExceptionHandler</strong>（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中，用到了各种各样的注解，一直没抽时间整理过，正好今天抽时间稍微整理了一波。整理的注解都是工作中常见的，如有纰漏请留言指出！&lt;/p&gt;

      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="注解" scheme="http://www.devcheng.net/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识点汇总整理</title>
    <link href="http://www.devcheng.net/post/72b87000.html"/>
    <id>http://www.devcheng.net/post/72b87000.html</id>
    <published>2020-08-17T12:41:47.000Z</published>
    <updated>2020-08-17T12:49:51.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。</p><p>这里先给大家安利一个在线画图<a href="https://www.processon.com/i/5915bcb6e4b0691b1f68fa96" target="_blank" rel="noopener">processon</a>，先看一下Redis知识点汇总整理好的一览图。</p><p><img src="https://s1.ax1x.com/2020/08/17/dZ8r24.png" alt="dZ8r24.png">.</p><p>由于绘制的脑图很大，以上仅是图的一部分。</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><ul><li>基础知识点</li><li>数据持久化</li><li>过期策略</li><li>内存淘汰策略</li><li>常见问题</li><li>Redis事务</li><li>主从复制</li><li>Redis集群</li><li>应用场景</li><li>对应面试题</li><li>…</li></ul><p>如有其它你觉得可以加进去的知识点，欢迎留言。后续会继续修改优化脑图！</p><p>脑图地址: <a href="https://www.processon.com/view/link/5f34b188e0b34d0806735914" target="_blank" rel="noopener">https://www.processon.com/view/link/5f34b188e0b34d0806735914</a></p><p>阅读密码：yicheng</p><hr><p><strong>The end</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。&lt;/p&gt;
&lt;p&gt;这里先给大家安利一个在线画图&lt;a hre
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis" scheme="http://www.devcheng.net/tags/Redis/"/>
    
      <category term="Redis知识点" scheme="http://www.devcheng.net/tags/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>16个Redis面试题，你能回答出来几个？</title>
    <link href="http://www.devcheng.net/post/60b1ff4c.html"/>
    <id>http://www.devcheng.net/post/60b1ff4c.html</id>
    <published>2020-08-09T13:05:00.000Z</published>
    <updated>2020-08-09T13:19:24.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！</p><h2 id="1-什么是redis"><a href="#1-什么是redis" class="headerlink" title="1.什么是redis?"></a><strong>1.什么是redis?</strong></h2><p>Redis 是一个基于内存的高性能key-value数据库。</p><h2 id="2-Redis的特点"><a href="#2-Redis的特点" class="headerlink" title="2.Redis的特点"></a><strong>2.Redis的特点</strong></h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据。</p><p>因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。</p><p>另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。<br>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h2 id="3-使用redis有哪些好处？"><a href="#3-使用redis有哪些好处？" class="headerlink" title="3.使用redis有哪些好处？"></a><strong>3.使用redis有哪些好处？</strong></h2><p>速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>支持丰富数据类型：支持string，list，set，sorted set，hash</p><p>支持事务：操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h2 id="4-redis相比memcached有哪些优势？"><a href="#4-redis相比memcached有哪些优势？" class="headerlink" title="4.redis相比memcached有哪些优势？"></a><strong>4.redis相比memcached有哪些优势？</strong></h2><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>redis的速度比memcached快很多</p><p>redis可以持久化其数据</p><h2 id="5-Memcache与Redis的区别都有哪些？"><a href="#5-Memcache与Redis的区别都有哪些？" class="headerlink" title="5.Memcache与Redis的区别都有哪些？"></a><strong>5.Memcache与Redis的区别都有哪些？</strong></h2><p>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</p><p>数据支持类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型。</p><p>使用底层模型不同：它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p><h2 id="6-redis常见性能问题和解决方案："><a href="#6-redis常见性能问题和解决方案：" class="headerlink" title="6.redis常见性能问题和解决方案："></a><strong>6.redis常见性能问题和解决方案：</strong></h2><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p><p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。</p><p>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p><p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p><p>4).Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p><h2 id="7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a><strong>7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</strong></h2><p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h2 id="8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"><a href="#8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。" class="headerlink" title="8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"></a><strong>8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。</strong></h2><p>具体登录函数或功能用空函数即可，不用详细写出。</p><p>用列表实现：列表中每个元素代表登陆时间，只要最后的第5次登陆时间和现在时间差不超过1小时就禁止登陆。用Python写的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import redis  </span><br><span class="line">import sys  </span><br><span class="line">import time  </span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0)  </span><br><span class="line">try:       </span><br><span class="line">    id = sys.argv[1]</span><br><span class="line">except:      </span><br><span class="line">    print(‘input argument error’)    </span><br><span class="line">    sys.exit(0)  </span><br><span class="line">if r.llen(id) &gt;= 5 and time.time() – float(r.lindex(id, 4)) &lt;= 3600:      </span><br><span class="line">    print(“you are forbidden logining”)</span><br><span class="line">else:       </span><br><span class="line">    print(‘you are allowed to login’)    </span><br><span class="line">    r.lpush(id, time.time())    </span><br><span class="line">    # login_func()</span><br></pre></td></tr></table></figure><h2 id="9-为什么redis需要把所有数据放到内存中"><a href="#9-为什么redis需要把所有数据放到内存中" class="headerlink" title="9.为什么redis需要把所有数据放到内存中?"></a><strong>9.为什么redis需要把所有数据放到内存中?</strong></h2><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。</p><p>如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="10-Redis是单进程单线程的"><a href="#10-Redis是单进程单线程的" class="headerlink" title="10.Redis是单进程单线程的"></a><strong>10.Redis是单进程单线程的</strong></h2><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="11-redis的并发竞争问题如何解决"><a href="#11-redis的并发竞争问题如何解决" class="headerlink" title="11.redis的并发竞争问题如何解决?"></a><strong>11.redis的并发竞争问题如何解决?</strong></h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。</p><p>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是</p><p>由于客户端连接混乱造成。对此有2种解决方法：</p><p>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度，利用setnx实现锁。</p><p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h2 id="12-redis事物的了解CAS-check-and-set-操作实现乐观锁"><a href="#12-redis事物的了解CAS-check-and-set-操作实现乐观锁" class="headerlink" title="12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?"></a><strong>12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?</strong></h2><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。</p><p>相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：</p><p>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p><p>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p><p>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。</p><p>在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</p><p>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。</p><p>然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p><p>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。</p><p>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。<br>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。</p><p>此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p><h2 id="13-WATCH命令和基于CAS的乐观锁："><a href="#13-WATCH命令和基于CAS的乐观锁：" class="headerlink" title="13.WATCH命令和基于CAS的乐观锁："></a><strong>13.WATCH命令和基于CAS的乐观锁：</strong></h2><p>在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。</p><p>例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure></p><p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景–竞态争用(race condition)。</p><p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。</p><p>为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">  val = GET mykey</span><br><span class="line">  val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">  SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前</p><p>如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p><h2 id="14-redis持久化的几种方式"><a href="#14-redis持久化的几种方式" class="headerlink" title="14.redis持久化的几种方式"></a><strong>14.redis持久化的几种方式</strong></h2><p><strong>1、快照（snapshots）</strong></p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump。rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p><strong>工作原理</strong></p><p>Redis forks。<br>子进程开始将数据写到临时RDB文件中。<br>当子进程完成写RDB文件，用新文件替换老文件。<br>这种方式可以使Redis使用copy-on-write技术。</p><p><strong>2、AOF</strong></p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。</p><p>Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式。</p><p><strong>3、虚拟内存方式</strong></p><p>当你的key很小而value很大时，使用VM的效果会比较好。因为这样节约的内存比较大。当你的key不小时，可以考虑使用一些非常方法将很大的key变成很大的value，比如你可以考虑将key，value组合成一个新的value。<br>　　<br>vm-max-threads这个参数，可以设置访问swap文件的线程数，设置最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的。可能会造成比较长时间的延迟，但是对数据完整性有很好的保证。</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库</p><h2 id="15-redis的缓存失效策略和主键失效机制"><a href="#15-redis的缓存失效策略和主键失效机制" class="headerlink" title="15.redis的缓存失效策略和主键失效机制"></a><strong>15.redis的缓存失效策略和主键失效机制</strong></h2><p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略。</p><p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p><p><strong>1、影响生存时间的一些操作</strong></p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p><p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p><p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key </p><p>因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p><p><strong>2、如何更新生存时间</strong></p><p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p><p>最大缓存配置</p><p>在 redis 中，允许用户设置最大使用内存大小，server。maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p><p>redis 提供 6种数据淘汰策略：</p><p><strong>volatile-lru：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p><strong>volatile-random：</strong>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p><strong>allkeys-lru：</strong>从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p><strong>allkeys-random：</strong>从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br>使用策略规则：</p><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p><p>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random<br>三种数据淘汰策略：</p><p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰。</p><h2 id="16-redis-最适合的场景"><a href="#16-redis-最适合的场景" class="headerlink" title="16.redis 最适合的场景"></a><strong>16.redis 最适合的场景</strong></h2><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别</p><p>那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p><p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p><p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><p><strong>（1）会话缓存（Session Cache）</strong></p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。</p><p>用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p><strong>（2）全页缓存（FPC）</strong></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>（3）队列</strong></p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p><strong>（4）排行榜/计数器</strong></p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”。</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES<br>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p><strong>（5）发布/订阅</strong></p><p>最后是Redis的发布/订阅功能。</p><p>发布/订阅的使用场景确实非常多，我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！<br>　　<br>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如此多功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！&lt;/p&gt;
&lt;h2 id=&quot;1-什
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis面试题" scheme="http://www.devcheng.net/tags/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义注解获取当前登录用户信息</title>
    <link href="http://www.devcheng.net/post/c0d388e.html"/>
    <id>http://www.devcheng.net/post/c0d388e.html</id>
    <published>2020-07-24T13:16:41.000Z</published>
    <updated>2020-07-24T13:20:33.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。</p><p>如果在本项目中，多处都需要获取登录用户的信息，难不成还要调用自己写的接口吗？显然不用！</p><p>以往的项目经验里，都是使用用户对应的Service获取，今天使用自定义注解对其进行数据绑定，从而获取登录用户信息。</p><h2 id="步骤一：编写自定义注解"><a href="#步骤一：编写自定义注解" class="headerlink" title="步骤一：编写自定义注解"></a><strong>步骤一：编写自定义注解</strong></h2><p>先自定义一个用于绑定登录用户信息的注解，且运行时有效。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户信息注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤二：自定义UserResolver"><a href="#步骤二：自定义UserResolver" class="headerlink" title="步骤二：自定义UserResolver"></a><strong>步骤二：自定义UserResolver</strong></h2><p>Spring boot封装了SpringMVC中的HandlerMethodArgumentResolver接口，自定义UserResolver要实现对应的2个接口。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户Resolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentUserMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断方法参数是否带有@CurrentUser注解且参数类型为User或其子类</span></span><br><span class="line"><span class="keyword">return</span> methodParameter.hasParameterAnnotation(CurrentUser.class) &amp;&amp; User.class.isAssignableFrom(methodParameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//获取当前登录用户</span></span><br><span class="line"><span class="keyword">return</span> userService.getCurrent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤三：WebMvcConfig配置自定义解析器"><a href="#步骤三：WebMvcConfig配置自定义解析器" class="headerlink" title="步骤三：WebMvcConfig配置自定义解析器"></a><strong>步骤三：WebMvcConfig配置自定义解析器</strong></h2><p>新建一个webconfig 实现 WebMvcConfigurer 接口， 需要重写 addArgumentResolvers 这个方法，初始化我们创建的操作类。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置自定义解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CurrentUserMethodArgumentResolver <span class="title">currentUserMethodArgumentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrentUserMethodArgumentResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">argumentResolvers.add(currentUserMethodArgumentResolver());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤四：编写代码测试"><a href="#步骤四：编写代码测试" class="headerlink" title="步骤四：编写代码测试"></a><strong>步骤四：编写代码测试</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getUser"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">queryUser</span><span class="params">( @CurrentUser UserInfoVO userInfo)</span> </span>&#123;</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>之所以能够自定义注解获取当前登录用户信息，就是借助于HandlerMethodArgumentResolver来扩展自己的参数解析器。</p><p>在resolveArgument接口中编写对应获取登录用户信息的逻辑代码。举个栗子，有的系统是从数据库中获取数据，有的则把对应数据放在redis中。所以在这里从不同地方获取即可。</p><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="HandlerMethodArgumentResolver" scheme="http://www.devcheng.net/tags/HandlerMethodArgumentResolver/"/>
    
      <category term="自定义注解" scheme="http://www.devcheng.net/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>重装系统如何继续恢复Hexo博客</title>
    <link href="http://www.devcheng.net/post/7fee676.html"/>
    <id>http://www.devcheng.net/post/7fee676.html</id>
    <published>2020-07-12T09:42:58.000Z</published>
    <updated>2020-07-13T13:38:52.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾的缘故，但是清理系统垃圾之后还是有卡顿的现象，干脆从新装一个系统得了。</p><p>在重装系统之前，事先把原来Hexo的文件夹都备份一下。同时，我还备份了对应的id_rsa和id_rsa.pub文件。</p><p><strong>如果要重装系统，务必要备份对应的文件！</strong></p><p>备份好对应的文件之后，开始重装系统！</p><h3 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a><strong>安装Node.js和Git</strong></h3><p>1.安装Node.js</p><p>2.安装Git</p><p>具体细节就不展开细说了，可自行为度娘！安装成功node.js和git之后，查看一下确保无问题。</p><p><img src="/images/devcheng_net_hexo_recover_001.png" alt="“伊成博客”"></p><h3 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a><strong>配置SSH key</strong></h3><p>在最上面，已经提及到了 SSH key 对应的2个文件，<br>找到路径 C:\Users\用户名.ssh 有无.ssh文件夹，没有则创建。</p><p>执行命令，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><p>因为重装系统之前已经备份id_rsa和id_rsa.pub文件,所以把这2个文件复制到.ssh文件夹内即可。</p><p>使用命令，测试是否成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_hexo_revover_002.png" alt="“伊成博客”"></p><h3 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a><strong>配置Git用户名和邮箱</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;devcheng&quot;    // 你的coding或github用户名，并非昵称</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;// 你的coding或github的注册邮箱</span><br></pre></td></tr></table></figure><h3 id="复制备份的文件夹"><a href="#复制备份的文件夹" class="headerlink" title="复制备份的文件夹"></a><strong>复制备份的文件夹</strong></h3><p>文件夹删除node_modules public .git .deploy_git</p><p><img src="/images/devcheng_net_hexo_recover_003.png" alt="“伊成博客”"></p><h3 id="和远程项目关联"><a href="#和远程项目关联" class="headerlink" title="和远程项目关联"></a><strong>和远程项目关联</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 你的hexo博客git地址</span><br></pre></td></tr></table></figure><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a><strong>安装hexo</strong></h3><p>开始执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>并没有成功的安装好hexo,于是从新换一个命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>依然还是提示有对应的依赖没有找到，于是我把最开始备份的整个文件夹，全部都复制到了现在这个目录。</p><p><img src="/images/devcheng_net_hexo_recover_004.png" alt="“伊成博客”"></p><h3 id="强势启动"><a href="#强势启动" class="headerlink" title="强势启动"></a><strong>强势启动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>突然发现，居然可以启动起来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>以上步骤，仅供参考，步骤不是惟一定死的，各位务必根据自己的操作情况而定。这篇博客就是从重装系统之后写的第一篇博文！<br>如有不妥之处，请留言！</p><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="恢复Hexo" scheme="http://www.devcheng.net/tags/%E6%81%A2%E5%A4%8DHexo/"/>
    
      <category term="重装系统" scheme="http://www.devcheng.net/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中按字段查询重复数据</title>
    <link href="http://www.devcheng.net/post/4dfd5416.html"/>
    <id>http://www.devcheng.net/post/4dfd5416.html</id>
    <published>2020-07-09T13:37:57.000Z</published>
    <updated>2020-07-09T13:48:17.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug(没有对数据做重复数据校验)等。</p><p>既然是难免的情况，那如何处理呢？</p><h2 id="根据一个字段查询重复数据"><a href="#根据一个字段查询重复数据" class="headerlink" title="根据一个字段查询重复数据"></a>根据一个字段查询重复数据</h2><p>举个栗子，有个用户表测试小姐姐拼命的创建同一条数据插入到用户表。<br>那么在用户表中就会存在相同用户名的多条数据，根据 用户名 查询重复数据的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> userName <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果查询出来重复数据只需要保留一条，那就得把多余的数据删除即可，对应SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName);</span><br></pre></td></tr></table></figure><p>这里是根据 用户名分组保留用户ID最大的那条数据，其它的都删掉！<br>具体保留哪条数据，各位小伙伴可自行决定~</p><h2 id="根据多个字段查询重复数据"><a href="#根据多个字段查询重复数据" class="headerlink" title="根据多个字段查询重复数据"></a>根据多个字段查询重复数据</h2><p>在举个栗子，在这个用户表中 用户名和用户类型 都重复的需要查询出来，对应的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据多个字段查询，保留一条数据，删除多余数据SQL如下：</p><p>方法一：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType);</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nameAndType <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user) tt <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType <span class="keyword">HAVING</span> <span class="keyword">count</span>(nameAndType) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>方法三：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> maxid <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(userId) <span class="keyword">as</span> maxid, <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType) t);</span><br></pre></td></tr></table></figure></p><p>方法一中删除多余重复数据和上面文章中的思路是一致的，方法二和方法三的思路是利用CONCAT函数。</p><p>以上，如果你开发过程中遇到同样问题，可以使用上面的SQL尝试一下！</p><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL" scheme="http://www.devcheng.net/tags/MySQL/"/>
    
      <category term="重复数据" scheme="http://www.devcheng.net/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java8中列表的排序(升序、降序)</title>
    <link href="http://www.devcheng.net/post/835182f7.html"/>
    <id>http://www.devcheng.net/post/835182f7.html</id>
    <published>2020-07-02T13:34:11.000Z</published>
    <updated>2020-07-02T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来。</p><p>时过境迁，现在的项目中采用了Spring Data JPa,当然也支持排序。但本文中的主角可不是它，在很多情况下我们查询出来的List数据没有排序好或是需要二次按照某字段排序，这个时候，我们就可以使用Java8对其排序。</p><p>首先，看个基础语法，如下：</p><h3 id="单个字段排序"><a href="#单个字段排序" class="headerlink" title="单个字段排序"></a>单个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回 对象集合以类属性一升序排序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序排序 注意两种写法</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">//先以属性一升序,结果进行属性一降序</span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一).reversed());</span></span><br><span class="line"><span class="comment">//以属性一降序 </span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));</span></span><br></pre></td></tr></table></figure><h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 对象集合以类属性一升序 属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span></span><br><span class="line"> list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一升序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,再进行属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(Comparator.comparing(User::getId).reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(User::getId,Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以实例代码我们可以发现</p><p>写法一： Comparator.comparing(类::属性一).reversed();</p><p>写法二： Comparator.comparing(类::属性一,Comparator.reverseOrder());</p><p>两种排序是完全不一样的,一定要区分开来。</p><p>写法一是得到排序结果后再排序；</p><p>写法二是直接进行排序,很多人会混淆导致理解出错,但写法二更好理解,建议使用写法二。</p><h2 id="完整例子demo"><a href="#完整例子demo" class="headerlink" title="完整例子demo"></a>完整例子demo</h2><p>最后贴一个完整的例子，供大家参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">22</span>,<span class="string">"张X"</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">27</span>,<span class="string">"李X"</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"王X"</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">"赵X"</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    list.add(user4);</span><br><span class="line">    <span class="keyword">for</span>(User u :list)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; newList = list.stream().sorted(Comparator.comparing(User::getAge))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">for</span>(User u :newList)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
      <category term="排序" scheme="http://www.devcheng.net/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中三大构建工具的发展历程（Ant、Maven和Gradle）</title>
    <link href="http://www.devcheng.net/post/e200ec64.html"/>
    <id>http://www.devcheng.net/post/e200ec64.html</id>
    <published>2020-06-21T07:47:09.000Z</published>
    <updated>2020-06-21T07:49:21.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们要写一个Java程序，一般的步骤是编译，测试，打包。</p><p>这个构建的过程，如果文件比较少，我们可以手动使用java, javac,jar命令去做这些事情。但当工程越来越大，文件越来越多，这个事情就不是那么地令人开心了。</p><p>因为这些命令往往都是很机械的操作。所以我们可以把这些机械的操作交给机器去做。</p><p>而在linux中，有一个工具叫make。<br>我们可以通过编写Makefile来执行工程的构建，在windows上相应的工具是nmake。</p><p>那既然有现成的工具，为什么当时没有选择Makefile呢？说道这里那就不得不提一下Ant了。</p><h2 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h2><p>说起Ant，就不得不说另一个Apache开源项目Tomcat。Tomcat作为轻量级Web容器，早已声名鹊起。最开始的时候，Ant是Tomcat的一部分，Ant的唯一目的就是build Tomcat。</p><p>不久，很多Java开源项目意识到Ant的简洁适用，更重要的是弥补Makefiles的不足。自从Jakarta以及Apache项目开始采用Ant以来,作为构建工具的Ant很快发展在各种各样的项目中。</p><p>在2000年1月，Ant脱离了Tomcat，成为独立的Apache开源项目，由独立的CVS模块维护，正式更名为Apache Ant。</p><p>第一个Ant版本是Tomcat 3.1于2000年4月19日发行的版本。此版本后来称为Ant 0.3.1。</p><p>到目前Ant最新的版本是 <strong>2020年5月13日 版本号：1.10.8</strong></p><p>具体的版本发行历程可点击链接查看 <a href="http://ant.apache.org/faq.html" target="_blank" rel="noopener">http://ant.apache.org/faq.html</a></p><h3 id="Ant示例"><a href="#Ant示例" class="headerlink" title="Ant示例"></a>Ant示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"HelloWorld"</span> <span class="attr">default</span>=<span class="string">"run"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">value</span>=<span class="string">"src"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dest"</span> <span class="attr">value</span>=<span class="string">"classes"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jarfile"</span> <span class="attr">value</span>=<span class="string">"hello.jar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;jarfile&#125;"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">depends</span>=<span class="string">"build"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">java</span> <span class="attr">classname</span>=<span class="string">"test.ant.HelloWorld"</span> <span class="attr">classpath</span>=<span class="string">"$&#123;hello_jar&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;hello_jar&#125;"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例，得知Ant定义了五个任务，init, compile, build, test,clean。</p><p>每个任务做什么都定义清楚了。在打包之前要先编译，所以通过depends来指定依赖的路径。</p><p>如果在命令行里执行ant build，那就会先执行compile，而compile又依赖于init，所以就会先执行init。</p><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant test</span><br></pre></td></tr></table></figure></p><p>通过命令就可以执行编程，打包，测试。为开发者带来了很大的便利，提供了工作效率。</p><p>但是Ant有一个很致命的缺陷，那就是没办法管理依赖。</p><p>我们一个工程，要使用很多第三方工具，不同的工具，不同的版本。</p><p>每次打包都要自己手动去把正确的版本拷到lib下面去，不用说，这个工作既枯燥还特别容易出错。为了解决这个问题，Maven如约而至。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven之前我们经常使用Ant来进行Java项目的构建，然后Ant仅是一个构建工具，它并未对项目的中的工程依赖以及项目本身进行管理，并且Ant作为构建工具未能消除软件构建的重复性，因为不同的项目需要编写对应的Ant任务。</p><p>Maven作为后来者，继承了Ant的项目构建功能，并且提供了依赖关系，项目管理的功能，因此它是一个项目管理和综合工具， 其核心的依赖管理， 项目信息管理， 中央仓库，约定大于配置的核心功能使得Maven成为当前Java项目构建和管理工具的标准选择。</p><p>Maven 发展历程： Maven –&gt; Maven2 –&gt; Maven3</p><p>到目前Maven最新的版本是 <strong>2019-11-25 版本号：3.6.3</strong></p><h3 id="Maven示例"><a href="#Maven示例" class="headerlink" title="Maven示例"></a>Maven示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...xmlns...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devcheng.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例得知，包的坐标是net.devcheng.demo:Example:0.1.0-SNAPSHOT，而工程中要依赖junit:junit:4.10。</p><p>那么Maven就会自动去帮我把junit打包进来。如果本地没有junit，maven还会帮自动去网上下载。我们还通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。</p><p>相对于上文中的Ant来说，Maven抛弃了Ant中通过target定义任务的做法，对于依赖引入了生命周期。</p><p>最后在说说 Gradle。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Gradle是一个基于Apache Ant和ApacheMaven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。</p><p>由以上定义得知，Gradle已经抛弃了Ant,Maven中Xml配置的形式。Gradle继承了Maven中仓库，坐标，依赖这些核心概念。文件的布局也和Maven相同。但同时，又继承了Ant中target的概念，我们又可以重新定义自己的任务(在Gradle中叫做task)。</p><h3 id="Gradle示例"><a href="#Gradle示例" class="headerlink" title="Gradle示例"></a>Gradle示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;</span><br><span class="line">    your tests.</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由示例可看出内容很简单，引入了java插件，指定仓库，指定依赖。可以看到依赖的设定相比起xml的写法，变得大大简化了。</p><p>到目前Gradle最新的版本是 <strong>2020年6月2日 版本号：v6.5</strong></p><h3 id="Gradle-vs-Maven"><a href="#Gradle-vs-Maven" class="headerlink" title="Gradle vs Maven"></a>Gradle vs Maven</h3><p>关于Gradle和Maven的区别，简单比较如下：</p><ul><li><p>Maven和Gradle对依赖项的scope有所不同。<br>在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。<br>而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。</p></li><li><p>Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</p></li><li>解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确。</li><li>Maven引用依赖方面采用的xml，而Gradle不是。</li></ul><hr><h6 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们要写一个Java程序，一般的步骤是编译，测试，打包。&lt;/p&gt;
&lt;p&gt;这个构建的过程，如果文件比较少，我们可以手动使用java, java
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Ant" scheme="http://www.devcheng.net/tags/Ant/"/>
    
      <category term="Maven" scheme="http://www.devcheng.net/tags/Maven/"/>
    
      <category term="Gradle" scheme="http://www.devcheng.net/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>java通过反射获取注解@Column中的信息</title>
    <link href="http://www.devcheng.net/post/74b831b2.html"/>
    <id>http://www.devcheng.net/post/74b831b2.html</id>
    <published>2020-06-20T02:44:08.000Z</published>
    <updated>2020-06-20T02:49:43.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devcheng.demo.restful.data.service.model.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonDeserialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"DEV_CHENG_FILE_DEMO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscloseFileEntity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ID"</span>,columnDefinition = <span class="string">"ID"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"APPLY_NO"</span>,columnDefinition = <span class="string">"申请号"</span>)</span><br><span class="line">    <span class="keyword">private</span> String applyNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_NAME"</span>,columnDefinition = <span class="string">"文件名称"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_SIZE"</span>,columnDefinition = <span class="string">"文件大小"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileSize;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"TITLE"</span>,columnDefinition = <span class="string">"标题"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"IS_VALID"</span>,columnDefinition = <span class="string">"是否有效"</span>)</span><br><span class="line">    <span class="keyword">private</span> String isValid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"SAVE_DATE"</span>,columnDefinition = <span class="string">"保存日期"</span>)    </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime saveDate;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上得知，需要从 @Column 注解中获取 name和columnDefinition 中的信息，那如何可以获取到对应的信息？</p><p>在获取 @Column 注解中的信息之前，先看看 columnDefinition是啥意思?</p><h2 id="columnDefinition"><a href="#columnDefinition" class="headerlink" title="columnDefinition"></a>columnDefinition</h2><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用。</p><p>值得注意的一点是：在编程语言中字符串一般都用String表示，但是数据库中varcahr数值类型有长度限制，一旦需要大文本，则需要text数值类型。但是String类型默认映射的数值类型是varchar，columnDefinition可以进行额外指定。</p><h2 id="获取注解-Column中的信息"><a href="#获取注解-Column中的信息" class="headerlink" title="获取注解@Column中的信息"></a>获取注解@Column中的信息</h2><p>实现思路：通过类路径利用反射获取到对应的注解信息，从而获取到对应@Column中的信息<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TableColumnsVO&gt; <span class="title">getFiledAndAnnotateInfo</span><span class="params">(String entityPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TableColumnsVO&gt; tableColumnsLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(entityPath);</span><br><span class="line">            Field[] fields = aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">            Column presentColumn;</span><br><span class="line">            <span class="keyword">for</span> (Field field:fields)</span><br><span class="line">            &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(Column.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    presentColumn = field.getDeclaredAnnotation(Column.class);</span><br><span class="line">                    TableColumnsVO tableData = <span class="keyword">new</span> TableColumnsVO();</span><br><span class="line">                    tableData.setColumnName(presentColumn.name());</span><br><span class="line">                    tableData.setColumnDefinationInfo(presentColumn.columnDefinition());</span><br><span class="line">                    tableColumnsLists.add(tableData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"获取字段和注释异常：%s"</span>, entityPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableColumnsLists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的 TableColumnsVO代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableColumnsVO</span></span>&#123;</span><br><span class="line">    <span class="comment">//列名</span></span><br><span class="line">    <span class="keyword">private</span> String columnName;</span><br><span class="line">    <span class="comment">//ColumnDefinationInfo信息</span></span><br><span class="line">    <span class="keyword">private</span> String columnDefinationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="java反射" scheme="http://www.devcheng.net/tags/java%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Column注解" scheme="http://www.devcheng.net/tags/Column%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>墙裂推荐一款redis客户端可视化工具之RedisPlus</title>
    <link href="http://www.devcheng.net/post/64102a3b.html"/>
    <id>http://www.devcheng.net/post/64102a3b.html</id>
    <published>2020-06-07T07:15:43.000Z</published>
    <updated>2020-06-07T07:23:36.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具。<br>比如：Redis Desktop Manager，RedisView ，RedisClient 等工具。</p><p>今天墙裂推荐一款redis客户端可视化工具：RedisPlus</p><h2 id="RedisPlus"><a href="#RedisPlus" class="headerlink" title="RedisPlus"></a><strong>RedisPlus</strong></h2><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h3><p>RedisPlus是为Redis可视化管理开发的一款开源免费的桌面客户端软件，支持Windows 、Linux、Mac三大系统平台，RedisPlus提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。该软件支持单机、集群模式连接，同时还支持SSH（单机、<strong>集群</strong>）通道连接。</p><p>项目地址： <a href="https://gitee.com/MaxBill/RedisPlus" target="_blank" rel="noopener">https://gitee.com/MaxBill/RedisPlus</a></p><p>运行截图：<br><img src="/images/devcheng_net_redis_001.jpg" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis_002.jpg" alt="“伊成博客”"></p><p>RedisPlus目前最新版本为：3.2.0。<br>项目介绍中得知，RedisPlus将不再更新迭代，包括V4.0的electron和jfx11版本都将停止开发和更新。</p><p>下载地址<br>百度下载：链接: <a href="https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ</a> 提取码: 3pcm</p><p><img src="/images/devcheng_net_redis_003.png" alt="“伊成博客”"></p><h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a><strong>最后说一句</strong></h2><p>在网上不乏有很多redis客户端工具，但是真正能支持集群的没几个工具，同时也找到了一款国外的工具，名字叫FastoRedis。<br>下载地址：<a href="https://fastoredis.com/anonim_users_downloads" target="_blank" rel="noopener">https://fastoredis.com/anonim_users_downloads</a></p><p>FastoRedis 的官方介绍<br>Download FastoRedis - cross-platform client for Redis, supported main Redis database features like: modules, cluster, sentinel, ssh tunneling.</p><p>但是这款工具是收费的，土豪请无视这句话！</p><p>最后有需要RedisPlus的又觉得从百度网盘下载麻烦的，可以加一下我的QQ群：816175200 免费获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="RedisPlus" scheme="http://www.devcheng.net/tags/RedisPlus/"/>
    
      <category term="redis客户端" scheme="http://www.devcheng.net/tags/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本新特性小结</title>
    <link href="http://www.devcheng.net/post/5ae138f6.html"/>
    <id>http://www.devcheng.net/post/5ae138f6.html</id>
    <published>2020-05-30T07:07:22.000Z</published>
    <updated>2020-05-30T07:08:50.691Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天(2020-5-30)JDK已经发布到了 JDK14。</p><p>在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。</p><p>JDK 14已经于2020年3月17日如期发布。下面介绍各个版本的新特性，后续随着JDK新版本的更新迭代，本文会持续更新。</p><p>JDK从1.5版本开始，在官方的正式文档与宣传资料中已经不再使用类似JDK1.5的名称，只有程序员内部</p><p>使用的开发版本号(DeveloperVersion，例如java-version的输出)才继续沿用1.5、1.6、1.7和1.8的版本号，</p><p>而公开版本号(Product Version)则改为JDK5、JDK6、JDK7和JDK8的命名方式。</p><h2 id="JDK-5-新特性"><a href="#JDK-5-新特性" class="headerlink" title="JDK 5 新特性"></a>JDK 5 新特性</h2><p>1.自动装箱、拆箱</p><p>2.静态导入(static import)</p><p>3.增强for循环（for-each）</p><p>4.可变参数</p><p>5.枚举（enmu）</p><p>6.泛型</p><p>7.元数据</p><p>8.线程并发库（JUC）</p><hr><h2 id="JDK-6-新特性"><a href="#JDK-6-新特性" class="headerlink" title="JDK 6 新特性"></a>JDK 6 新特性</h2><p>1.AWT中新增的两个类Desktop和SystemTray</p><p>2.使用JAXB2来实现对象与XML之间的映射</p><ol start="3"><li><p>新增处理DOM和SAX之外又一种处理XML文档的API：STAX</p></li><li><p>使用Compiler API动态编译java源文件</p></li><li><p>轻量级Http Server API</p></li><li><p>插入式注解处理API（用于处理Annotations）</p></li><li><p>用Console开发控制台程序</p></li><li><p>对ruby、groovy、javascript等脚本语言的支持</p></li><li><p>Common Annotations</p></li></ol><hr><h2 id="JDK-7-新特性"><a href="#JDK-7-新特性" class="headerlink" title="JDK 7 新特性"></a>JDK 7 新特性</h2><ol><li><p>对Java集合（Collections）的增强支持</p></li><li><p>在switch中可用String</p></li><li><p>数值可加下划线（eg:int one_million=123_1）</p></li><li><p>支持二进制文字（int binary=0b1001_1001）</p></li><li><p>简化可变参数方法的调用</p></li><li><p>自动资源管理</p></li><li><p>类型推断</p></li><li><p>catch 多个类型异常</p></li></ol><hr><h2 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h2><ol><li><p>Stream函数式操作流元素集合</p></li><li><p>Lambda表达式</p></li><li><p>新的日期时间 API(Java Date/time API)</p></li><li><p>新增接口：默认方法与静态方法</p></li><li><p>Nashorm(Rhino的接替者，轻量级高性能的javascript运行环境)</p></li><li><p>Accumlators多线程lock</p></li><li><p>方法引用，与Lambda表达式联合使用</p></li><li><p>引入重复注解和类型注解</p></li><li><p>类型注解</p></li><li><p>新增base64加解密API</p></li><li><p>数组并行（parallel）操作</p></li><li><p>JVM的permGen空间移除，被Metaspace元空间取代</p></li></ol><hr><h2 id="JDK-9-新特性"><a href="#JDK-9-新特性" class="headerlink" title="JDK 9 新特性"></a>JDK 9 新特性</h2><ol><li><p>目录结构</p></li><li><p>模块化系统</p></li><li><p>jshell</p></li><li><p>多版本兼容JAR</p></li><li><p>接口的私有方法</p></li><li><p>改进try-with-resourcs</p></li><li><p>改进砖石操作符</p></li><li><p>限制使用单独下划线标识符</p></li><li><p>String存储结构变更</p></li><li><p>快速创建只读结合</p></li><li><p>增强Stream API</p></li><li><p>改进Optional 类</p></li><li><p>多分辨率图像 API</p></li><li><p>全新 HTTP客服端API</p></li><li><p>智能JAVA 编译工具</p></li><li><p>统一JVM 日志系统</p></li><li><p>javadoc 的 HTML5 支持</p></li><li><p>java 动态编译</p></li></ol><hr><h2 id="JDK-10-新特性"><a href="#JDK-10-新特性" class="headerlink" title="JDK 10 新特性"></a>JDK 10 新特性</h2><ol><li><p>局部变量类型推断</p></li><li><p>将JDK多存储库合并为单储存库</p></li><li><p>垃圾回收接口</p></li><li><p>并行Full GC 的G1</p></li><li><p>应用数据共享</p></li><li><p>线程局部管控</p></li><li><p>移除Native-Header Generation Tool （javah）</p></li><li><p>Unicode 标签扩展</p></li><li><p>备用内存设备上分配堆内存</p></li><li><p>基于实验JAVA 的JIT 编译器</p></li><li><p>Root 证书</p></li><li><p>基于时间的版本控制</p></li></ol><hr><h2 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h2><ol><li><p>字符串加强</p></li><li><p>HttClient Api</p></li><li><p>用于 Lambda 参数的局部变量语法</p></li><li><p>ZGC (并发回收的策略)</p></li></ol><hr><h2 id="JDK-12-新特性"><a href="#JDK-12-新特性" class="headerlink" title="JDK 12 新特性"></a>JDK 12 新特性</h2><ol><li><p>Switch Expressions</p></li><li><p>Shenandoah GC (GC 算法)</p></li></ol><hr><h2 id="JDK-13-新特性"><a href="#JDK-13-新特性" class="headerlink" title="JDK 13 新特性"></a>JDK 13 新特性</h2><ol><li><p>switch优化更新</p></li><li><p>文本块升级</p></li><li><p>重新实现旧版套接字API</p></li><li><p>核心库/java.util中：I18N</p></li><li><p>增加ZGC以将未使用的堆内存返回给操作系统</p></li></ol><hr><h2 id="JDK-14-新特性"><a href="#JDK-14-新特性" class="headerlink" title="JDK 14 新特性"></a>JDK 14 新特性</h2><ol><li><p>switch优化变更为最终版</p></li><li><p>垃圾回收相</p></li></ol><ul><li>删除cms垃圾收集器</li><li>弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合</li><li>将 zgc 垃圾回收器移植到 macOS 和 windows 平台 </li></ul><ol start="3"><li><p>instanceof的模式匹配（预览版）</p></li><li><p>删除了安全库java.security.acl API</p></li><li><p>货币格式（优化）</p></li><li><p>友好的空指针异常</p></li><li><p>外部存储器API（孵化）</p></li></ol><p>… </p><p><strong> 本文会持续更新… </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;截止到今天(2020-5-30)JDK已经发布到了 JDK14。&lt;/p&gt;
&lt;p&gt;在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。&lt;/p&gt;
&lt;p&gt;JDK 14已经于2020年3月17日如期发
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="新特性" scheme="http://www.devcheng.net/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK" scheme="http://www.devcheng.net/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>15个超实用的IDEA快捷键</title>
    <link href="http://www.devcheng.net/post/ea3f1216.html"/>
    <id>http://www.devcheng.net/post/ea3f1216.html</id>
    <published>2020-05-23T04:28:19.000Z</published>
    <updated>2020-05-23T04:47:57.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a><strong>叨叨叨</strong></h3><p>相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ctrl+V)也是常用的快捷键之一。<br>掌握必要的一些快捷键，可以提高工作效率，但是IDEA中的快捷键可不是一个两个。为此博主特意整理里15个高频超级实用<br>的IDEA快捷键。</p><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h3><p><strong>Ctrl + Alt + O</strong>  : 移除未使用的包 </p><blockquote><p>tip:可能会和QQ 屏幕识图快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + M</strong> :重构函数:将选中代码提取为函数 </p><p><strong>Ctrl + Alt + L</strong> :代码格式化</p><blockquote><p>tip:可能会和QQ 中的快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + T</strong>:可以把代码包在一个块内，例如：try/catch</p><p><strong>Ctrl + Alt + B</strong>:定位至选中类或者方法的具体实现</p><p><strong>Ctrl + Shift + F</strong>:全局查找快捷键</p><p><strong>Ctrl + Shift + R</strong>:全局替换</p><p><strong>Ctrl + Shift + U</strong>:大小写切换</p><p><strong>Ctrl + Shift + /</strong>:使用 /**/ 注释</p><p><strong>Ctrl + /</strong>:使用 // 注释</p><p><strong>Ctrl + X（Ctrl + Y）</strong>:删除行</p><p><strong>Ctrl + D</strong>:复制行</p><p><strong>Ctrl+Shift+Alt+J</strong>:批量修改变量快捷键</p><p><strong>F2 或 Shift+F2</strong>:快速定位高亮错误或警告</p><p><strong>Shift+Click</strong>:可以关闭文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;叨叨叨&quot;&gt;&lt;a href=&quot;#叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;叨叨叨&quot;&gt;&lt;/a&gt;&lt;strong&gt;叨叨叨&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ct
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="IDEA快捷键" scheme="http://www.devcheng.net/tags/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发的毕业论文管理系统</title>
    <link href="http://www.devcheng.net/post/1129f657.html"/>
    <id>http://www.devcheng.net/post/1129f657.html</id>
    <published>2020-05-08T12:22:47.000Z</published>
    <updated>2020-09-20T07:09:15.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管理员。<br>不同角色拥有不同的菜单功能，管理员是系统中权限最大的一个角色，即可以管理系统的各个配置以及数据操作。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA 2019.3<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven</li><li>Thymeleaf</li><li>Echarts</li><li>文件服务器centos7</li><li>…</li></ul><h2 id="项目页面预览"><a href="#项目页面预览" class="headerlink" title="项目页面预览"></a><strong>项目页面预览</strong></h2><ul><li><p>系统登录页<br><img src="/images/bylw1.png" alt="“伊成博客”"></p></li><li><p>系统首页<br><img src="/images/bylw2.png" alt="“伊成博客”"></p></li><li><p>个人信息页<br><img src="/images/bylw3.png" alt="“伊成博客”"></p></li><li><p>数据分析页<br><img src="/images/bylw4.png" alt="“伊成博客”"></p></li><li><p>选题情况页<br><img src="/images/bylw5.png" alt="“伊成博客”"></p></li><li><p>菜单开关页<br><img src="/images/bylw6.png" alt="“伊成博客”"></p></li><li><p>学生管理页<br><img src="/images/bylw7.png" alt="“伊成博客”"></p></li><li><p>修改密码页<br><img src="/images/bylw8.png" alt="“伊成博客”"></p></li><li><p>下载任务书<br><img src="/images/bylw9.png" alt="“伊成博客”"></p></li><li><p>上传论文页<br><img src="/images/bylw10.png" alt="“伊成博客”"></p></li><li><p>选定学生页<br><img src="/images/bylw11.png" alt="“伊成博客”"></p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>使用IDEA(eclipse)前导入本项目前，请确保你本地环境是已经配置好了Java环境变量，本地安装好了虚拟机且是centos7。<br>文件服务器搭建可以参考 <a href="http://www.devcheng.net/post/c668f449.html">点击 文件服务器搭建 传送门</a></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！</p><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a><strong>温馨提示</strong></h2><p>本项目可以当做毕业设计，内含毕业论文。</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖党绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="毕业论文管理系统" scheme="http://www.devcheng.net/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>centos7.x搭建ftp服务及创建用户</title>
    <link href="http://www.devcheng.net/post/c668f449.html"/>
    <id>http://www.devcheng.net/post/c668f449.html</id>
    <published>2020-04-18T13:23:05.000Z</published>
    <updated>2020-04-18T13:45:26.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FTP是什么东东？"><a href="#FTP是什么东东？" class="headerlink" title="FTP是什么东东？"></a>FTP是什么东东？</h2><p>FTP是 File Transfer Protocol 文件传输协议的英文名称,用于在Internet上控制文件的双向传输. 同时它也是一个应用程序.一般的Linux系统默认带有ftp软件或者是vsftpd。</p><h2 id="为何搭建？"><a href="#为何搭建？" class="headerlink" title="为何搭建？"></a>为何搭建？</h2><p>目的是从window系统中上传文件到linux系统的服务器里。</p><p>##安装步骤<br>提前使用终端工具连接上对应的服务器，这里我们以Xshell 为例</p><p><strong> 步骤一 </strong><br>登录到服务器后，先切换为 root 用户<br>切换到 home 文件夹下（可以换任意一个你喜欢的文件夹下，这里以home文件夹为例）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br></pre></td></tr></table></figure></p><p><strong> 步骤二 </strong><br>接着，输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤三 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤四 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vsftpd</span><br></pre></td></tr></table></figure></p><p>注意： 安装完成后，找到 /etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。</p><p><strong> 步骤五 </strong><br>修改selinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsebool -a | grep ftp</span><br></pre></td></tr></table></figure></p><p> <img src="/images/devcheng_net_ftp2.png" alt="“伊成博客”"></p><p>执行上面命令，从返回的结果看到 ftpd_full_access 和 tftp_home_dir两行都是off，说明没有开启外网的访问。</p><p><strong> 步骤六 </strong><br>开启外网的访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># setsebool -P ftpd_full_access on</span></span><br><span class="line">[root@bogon ~]<span class="comment"># setsebool -P tftp_home_dir on</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/devcheng_net_ftp3.png" alt="“伊成博客”"></p><p><strong> 步骤七 </strong><br>关闭匿名访问<br>修改 /etc/vsftpd/vsftpd.conf文件：<br>找到 anonymous_enable=NO  #将YES改为NO</p><p>到此基本配置都完成了，使用以下命令重启 ftp 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure></p><p>另外设置一下 开机启动 ftp 服务<br>使用以下命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> vsftpd.service</span><br></pre></td></tr></table></figure></p><p>通过以上的几个步骤，ftp 服务就已经搭建完毕，接着我们还需要创建用户并指定对应的目录</p><h2 id="创建目录以及用户"><a href="#创建目录以及用户" class="headerlink" title="创建目录以及用户"></a>创建目录以及用户</h2><p>在/var 目录下创建一个 www 文件夹,www文件夹中创建一个site文件夹一个da文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> www</span><br><span class="line">mkdir site</span><br><span class="line">mkdir da</span><br></pre></td></tr></table></figure></p><h3 id="创建用户da并指定用户目录为-var-www-da"><a href="#创建用户da并指定用户目录为-var-www-da" class="headerlink" title="创建用户da并指定用户目录为/var/www/da"></a>创建用户da并指定用户目录为/var/www/da</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /var/www/da da</span><br><span class="line">passwd da</span><br></pre></td></tr></table></figure><p>修改xiao用户的用户目录为/var/www/site<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d /var/www/site xiao</span><br></pre></td></tr></table></figure></p><h3 id="查看新创建的用户的信息"><a href="#查看新创建的用户的信息" class="headerlink" title="查看新创建的用户的信息"></a>查看新创建的用户的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp4.png" alt="“伊成博客”"></p><h3 id="修改-etc-vsftpd-vsftpd-conf文件"><a href="#修改-etc-vsftpd-vsftpd-conf文件" class="headerlink" title="修改/etc/vsftpd/vsftpd.conf文件"></a>修改/etc/vsftpd/vsftpd.conf文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi vsftpd.conf</span><br></pre></td></tr></table></figure><p>找到 userlist_enable=YES 在这句后面换行追加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userlist_deny=NO       </span><br><span class="line">userlist_file=/etc/vsftpd/user_list</span><br></pre></td></tr></table></figure></p><p>完成 vsftpd.conf 文件修改之后保存退出。</p><h3 id="编辑-user-list-文件"><a href="#编辑-user-list-文件" class="headerlink" title="编辑 user_list 文件"></a>编辑 user_list 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi user_list</span><br></pre></td></tr></table></figure><p>把上面的两个用户 一行一个用户名,输入 da 和xiao<br>按下esc键退出输入模式进入命令模式<br>输入:wq 保存并退出</p><h3 id="配置文件夹权限"><a href="#配置文件夹权限" class="headerlink" title="配置文件夹权限"></a>配置文件夹权限</h3><p>切换到 /var/www 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www</span><br></pre></td></tr></table></figure></p><h3 id="更改www里面两个文件夹的权限"><a href="#更改www里面两个文件夹的权限" class="headerlink" title="更改www里面两个文件夹的权限"></a>更改www里面两个文件夹的权限</h3><p>输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown da:da da</span><br><span class="line">chown xiao:xiao site</span><br></pre></td></tr></table></figure></p><h3 id="修改da用户的所属用户组-并修改site文件夹的权限"><a href="#修改da用户的所属用户组-并修改site文件夹的权限" class="headerlink" title="修改da用户的所属用户组,并修改site文件夹的权限"></a>修改da用户的所属用户组,并修改site文件夹的权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g xiao da</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp5.png" alt="“伊成博客”"></p><p>修改site文件夹的权限,允许同一个用户组的用户拥有rwx权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 site</span><br></pre></td></tr></table></figure></p><p>到此搭建ftp和创建目录和创建对应用户都全部完成！<br>接下来在代码中验证一下</p><p>使用springboot的配置文件application.yml 配置对应信息，如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ftp:</span><br><span class="line">  host: 192.168.43.41 #你服务器的ip</span><br><span class="line">  port: 21            #端口</span><br><span class="line">  userName: da        #以上创建的ftp用户名</span><br><span class="line">  password: da        #以上创建的ftp密码</span><br><span class="line">  basePath: /var/www/da #文件存放目录</span><br></pre></td></tr></table></figure></p><p><strong>上传文件 代码段 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(String host, <span class="keyword">int</span> port, String username, String password, String basePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String filePath, String filename, InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    FTPClient ftp = <span class="keyword">new</span> FTPClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> reply;</span><br><span class="line">        ftp.connect(host, port);<span class="comment">// 连接FTP服务器</span></span><br><span class="line">        <span class="comment">// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span></span><br><span class="line">        ftp.login(username, password);<span class="comment">// 登录</span></span><br><span class="line">        reply = ftp.getReplyCode();</span><br><span class="line">        <span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</span><br><span class="line">            ftp.disconnect();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切换到上传目录</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.changeWorkingDirectory(basePath + filePath)) &#123;</span><br><span class="line">            <span class="comment">//如果目录不存在创建目录</span></span><br><span class="line">            String[] dirs = filePath.split(<span class="string">"/"</span>);</span><br><span class="line">            String tempPath = basePath;</span><br><span class="line">            <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == dir || <span class="string">""</span>.equals(dir)) <span class="keyword">continue</span>;</span><br><span class="line">                tempPath += <span class="string">"/"</span> + dir;</span><br><span class="line">                <span class="keyword">if</span> (!ftp.changeWorkingDirectory(tempPath)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ftp.makeDirectory(tempPath)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ftp.changeWorkingDirectory(tempPath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置上传文件的类型为二进制类型</span></span><br><span class="line">        ftp.setFileType(FTP.BINARY_FILE_TYPE);</span><br><span class="line">        <span class="comment">//上传文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.storeFile(filename, input)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        ftp.logout();</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftp.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ftp.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_ftp6.png" alt="“伊成博客”"></p><p>看到这里说明以上的配置都没问题，到此本文告一段落了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FTP是什么东东？&quot;&gt;&lt;a href=&quot;#FTP是什么东东？&quot; class=&quot;headerlink&quot; title=&quot;FTP是什么东东？&quot;&gt;&lt;/a&gt;FTP是什么东东？&lt;/h2&gt;&lt;p&gt;FTP是 File Transfer Protocol 文件传输协议的英文名称,用于
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="centos7" scheme="http://www.devcheng.net/tags/centos7/"/>
    
      <category term="搭建ftp服务" scheme="http://www.devcheng.net/tags/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>win10怎么把两张图片合并为一张</title>
    <link href="http://www.devcheng.net/post/87dbd908.html"/>
    <id>http://www.devcheng.net/post/87dbd908.html</id>
    <published>2020-04-07T05:37:28.000Z</published>
    <updated>2020-04-08T01:56:18.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。</p><p>不管你的操作系统是win7还是win10都自带了一个 画图 软件，利用自带的画图软件就可以轻易合成图片了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备两种图片待合成的图片，例如我这里<br><img src="/images/devcheng_net_pic1.png" alt="“伊成博客”"></p><h2 id="图片合成步骤"><a href="#图片合成步骤" class="headerlink" title="图片合成步骤"></a>图片合成步骤</h2><p><strong> 第一步：</strong><br>点击任意一张图片，选择打开方式 – 选择 画图。<br><img src="/images/devcheng_net_pic2.png" alt="“伊成博客”"></p><p><strong> 第二步：</strong><br>将图片的长和宽做对应的变化，拉伸出更多空白地方用于展示其他图片。<br><img src="/images/devcheng_net_pic3.png" alt="“伊成博客”"></p><p><strong> 第三步：</strong><br>点击 主页 – 点击粘贴 – 选择 粘贴来源<br><img src="/images/devcheng_net_pic4.png" alt="“伊成博客”"></p><p><strong> 第四步：</strong><br>选择需要合成的图片，点击打开。<br><img src="/images/devcheng_net_pic5.png" alt="“伊成博客”"></p><p><strong> 第五步：</strong><br>把两张图片做好对应的位置变化，保存即可。<br><img src="/images/devcheng_net_pic6.png" alt="“伊成博客”"></p><p>这样两张图片就轻易合成为一张图片了，如果是多张图需要合并为一张图，重复操作步骤三即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="win10" scheme="http://www.devcheng.net/tags/win10/"/>
    
      <category term="图片合成" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"/>
    
  </entry>
  
</feed>
