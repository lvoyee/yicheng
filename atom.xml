<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人博客网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2020-08-17T12:49:51.967Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis知识点汇总整理</title>
    <link href="http://www.devcheng.net/post/72b87000.html"/>
    <id>http://www.devcheng.net/post/72b87000.html</id>
    <published>2020-08-17T12:41:47.000Z</published>
    <updated>2020-08-17T12:49:51.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。</p><p>这里先给大家安利一个在线画图<a href="https://www.processon.com/i/5915bcb6e4b0691b1f68fa96" target="_blank" rel="noopener">processon</a>，先看一下Redis知识点汇总整理好的一览图。</p><p><img src="https://s1.ax1x.com/2020/08/17/dZ8r24.png" alt="dZ8r24.png">.</p><p>由于绘制的脑图很大，以上仅是图的一部分。</p><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><ul><li>基础知识点</li><li>数据持久化</li><li>过期策略</li><li>内存淘汰策略</li><li>常见问题</li><li>Redis事务</li><li>主从复制</li><li>Redis集群</li><li>应用场景</li><li>对应面试题</li><li>…</li></ul><p>如有其它你觉得可以加进去的知识点，欢迎留言。后续会继续修改优化脑图！</p><p>脑图地址: <a href="https://www.processon.com/view/link/5f34b188e0b34d0806735914" target="_blank" rel="noopener">https://www.processon.com/view/link/5f34b188e0b34d0806735914</a></p><p>阅读密码：yicheng</p><hr><p><strong>The end</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近，利用业余时间把Redis的知识点从基础到面试常问的点，全面系统的画了一个脑图。&lt;/p&gt;
&lt;p&gt;这里先给大家安利一个在线画图&lt;a hre
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis" scheme="http://www.devcheng.net/tags/Redis/"/>
    
      <category term="Redis知识点" scheme="http://www.devcheng.net/tags/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>16个Redis面试题，你能回答出来几个？</title>
    <link href="http://www.devcheng.net/post/60b1ff4c.html"/>
    <id>http://www.devcheng.net/post/60b1ff4c.html</id>
    <published>2020-08-09T13:05:00.000Z</published>
    <updated>2020-08-09T13:19:24.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！</p><h2 id="1-什么是redis"><a href="#1-什么是redis" class="headerlink" title="1.什么是redis?"></a><strong>1.什么是redis?</strong></h2><p>Redis 是一个基于内存的高性能key-value数据库。</p><h2 id="2-Redis的特点"><a href="#2-Redis的特点" class="headerlink" title="2.Redis的特点"></a><strong>2.Redis的特点</strong></h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据。</p><p>因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。</p><p>另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。<br>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h2 id="3-使用redis有哪些好处？"><a href="#3-使用redis有哪些好处？" class="headerlink" title="3.使用redis有哪些好处？"></a><strong>3.使用redis有哪些好处？</strong></h2><p>速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>支持丰富数据类型：支持string，list，set，sorted set，hash</p><p>支持事务：操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h2 id="4-redis相比memcached有哪些优势？"><a href="#4-redis相比memcached有哪些优势？" class="headerlink" title="4.redis相比memcached有哪些优势？"></a><strong>4.redis相比memcached有哪些优势？</strong></h2><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</p><p>redis的速度比memcached快很多</p><p>redis可以持久化其数据</p><h2 id="5-Memcache与Redis的区别都有哪些？"><a href="#5-Memcache与Redis的区别都有哪些？" class="headerlink" title="5.Memcache与Redis的区别都有哪些？"></a><strong>5.Memcache与Redis的区别都有哪些？</strong></h2><p>存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</p><p>数据支持类型：Memcache对数据类型支持相对简单。Redis有复杂的数据类型。</p><p>使用底层模型不同：它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </p><h2 id="6-redis常见性能问题和解决方案："><a href="#6-redis常见性能问题和解决方案：" class="headerlink" title="6.redis常见性能问题和解决方案："></a><strong>6.redis常见性能问题和解决方案：</strong></h2><p>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</p><p>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。</p><p>Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</p><p>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</p><p>4).Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p><h2 id="7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#7-mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a><strong>7.mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</strong></h2><p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><h2 id="8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"><a href="#8-请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。" class="headerlink" title="8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。"></a><strong>8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。</strong></h2><p>具体登录函数或功能用空函数即可，不用详细写出。</p><p>用列表实现：列表中每个元素代表登陆时间，只要最后的第5次登陆时间和现在时间差不超过1小时就禁止登陆。用Python写的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import redis  </span><br><span class="line">import sys  </span><br><span class="line">import time  </span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0)  </span><br><span class="line">try:       </span><br><span class="line">    id = sys.argv[1]</span><br><span class="line">except:      </span><br><span class="line">    print(‘input argument error’)    </span><br><span class="line">    sys.exit(0)  </span><br><span class="line">if r.llen(id) &gt;= 5 and time.time() – float(r.lindex(id, 4)) &lt;= 3600:      </span><br><span class="line">    print(“you are forbidden logining”)</span><br><span class="line">else:       </span><br><span class="line">    print(‘you are allowed to login’)    </span><br><span class="line">    r.lpush(id, time.time())    </span><br><span class="line">    # login_func()</span><br></pre></td></tr></table></figure><h2 id="9-为什么redis需要把所有数据放到内存中"><a href="#9-为什么redis需要把所有数据放到内存中" class="headerlink" title="9.为什么redis需要把所有数据放到内存中?"></a><strong>9.为什么redis需要把所有数据放到内存中?</strong></h2><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。</p><p>如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h2 id="10-Redis是单进程单线程的"><a href="#10-Redis是单进程单线程的" class="headerlink" title="10.Redis是单进程单线程的"></a><strong>10.Redis是单进程单线程的</strong></h2><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="11-redis的并发竞争问题如何解决"><a href="#11-redis的并发竞争问题如何解决" class="headerlink" title="11.redis的并发竞争问题如何解决?"></a><strong>11.redis的并发竞争问题如何解决?</strong></h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。</p><p>Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是</p><p>由于客户端连接混乱造成。对此有2种解决方法：</p><p>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度，利用setnx实现锁。</p><p>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p><h2 id="12-redis事物的了解CAS-check-and-set-操作实现乐观锁"><a href="#12-redis事物的了解CAS-check-and-set-操作实现乐观锁" class="headerlink" title="12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?"></a><strong>12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?</strong></h2><p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。</p><p>相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：</p><p>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p><p>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p><p>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为”BEGIN TRANSACTION”语句。</p><p>在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</p><p>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。</p><p>然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</p><p>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。</p><p>然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。<br>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。</p><p>此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p><h2 id="13-WATCH命令和基于CAS的乐观锁："><a href="#13-WATCH命令和基于CAS的乐观锁：" class="headerlink" title="13.WATCH命令和基于CAS的乐观锁："></a><strong>13.WATCH命令和基于CAS的乐观锁：</strong></h2><p>在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务执行失败。</p><p>例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure></p><p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景–竞态争用(race condition)。</p><p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。</p><p>为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">  val = GET mykey</span><br><span class="line">  val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">  SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前</p><p>如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p><h2 id="14-redis持久化的几种方式"><a href="#14-redis持久化的几种方式" class="headerlink" title="14.redis持久化的几种方式"></a><strong>14.redis持久化的几种方式</strong></h2><p><strong>1、快照（snapshots）</strong></p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump。rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p><strong>工作原理</strong></p><p>Redis forks。<br>子进程开始将数据写到临时RDB文件中。<br>当子进程完成写RDB文件，用新文件替换老文件。<br>这种方式可以使Redis使用copy-on-write技术。</p><p><strong>2、AOF</strong></p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。</p><p>Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式。</p><p><strong>3、虚拟内存方式</strong></p><p>当你的key很小而value很大时，使用VM的效果会比较好。因为这样节约的内存比较大。当你的key不小时，可以考虑使用一些非常方法将很大的key变成很大的value，比如你可以考虑将key，value组合成一个新的value。<br>　　<br>vm-max-threads这个参数，可以设置访问swap文件的线程数，设置最好不要超过机器的核数，如果设置为0，那么所有对swap文件的操作都是串行的。可能会造成比较长时间的延迟，但是对数据完整性有很好的保证。</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库</p><h2 id="15-redis的缓存失效策略和主键失效机制"><a href="#15-redis的缓存失效策略和主键失效机制" class="headerlink" title="15.redis的缓存失效策略和主键失效机制"></a><strong>15.redis的缓存失效策略和主键失效机制</strong></h2><p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略。</p><p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p><p><strong>1、影响生存时间的一些操作</strong></p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p><p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p><p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key </p><p>因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p><p><strong>2、如何更新生存时间</strong></p><p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p><p>最大缓存配置</p><p>在 redis 中，允许用户设置最大使用内存大小，server。maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p><p>redis 提供 6种数据淘汰策略：</p><p><strong>volatile-lru：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl：</strong>从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p><strong>volatile-random：</strong>从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p><strong>allkeys-lru：</strong>从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p><strong>allkeys-random：</strong>从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p><p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br>使用策略规则：</p><p>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p><p>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random<br>三种数据淘汰策略：</p><p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰。</p><h2 id="16-redis-最适合的场景"><a href="#16-redis-最适合的场景" class="headerlink" title="16.redis 最适合的场景"></a><strong>16.redis 最适合的场景</strong></h2><p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别</p><p>那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p><p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p><p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><p><strong>（1）会话缓存（Session Cache）</strong></p><p>最常用的一种使用Redis的情景是会话缓存（session cache）。</p><p>用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p><p><strong>（2）全页缓存（FPC）</strong></p><p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。</p><p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p><p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p><p><strong>（3）队列</strong></p><p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。</p><p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p><p><strong>（4）排行榜/计数器</strong></p><p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p><p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”。</p><p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p>ZRANGE user_scores 0 10 WITHSCORES<br>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。</p><p><strong>（5）发布/订阅</strong></p><p>最后是Redis的发布/订阅功能。</p><p>发布/订阅的使用场景确实非常多，我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！<br>　　<br>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如此多功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;从网上整理一些在面试过程中常问的Redis相关的面试题，建议各位看官收藏！&lt;/p&gt;
&lt;h2 id=&quot;1-什
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Redis面试题" scheme="http://www.devcheng.net/tags/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义注解获取当前登录用户信息</title>
    <link href="http://www.devcheng.net/post/c0d388e.html"/>
    <id>http://www.devcheng.net/post/c0d388e.html</id>
    <published>2020-07-24T13:16:41.000Z</published>
    <updated>2020-07-24T13:20:33.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。</p><p>如果在本项目中，多处都需要获取登录用户的信息，难不成还要调用自己写的接口吗？显然不用！</p><p>以往的项目经验里，都是使用用户对应的Service获取，今天使用自定义注解对其进行数据绑定，从而获取登录用户信息。</p><h2 id="步骤一：编写自定义注解"><a href="#步骤一：编写自定义注解" class="headerlink" title="步骤一：编写自定义注解"></a><strong>步骤一：编写自定义注解</strong></h2><p>先自定义一个用于绑定登录用户信息的注解，且运行时有效。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户信息注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤二：自定义UserResolver"><a href="#步骤二：自定义UserResolver" class="headerlink" title="步骤二：自定义UserResolver"></a><strong>步骤二：自定义UserResolver</strong></h2><p>Spring boot封装了SpringMVC中的HandlerMethodArgumentResolver接口，自定义UserResolver要实现对应的2个接口。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前登录用户Resolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentUserMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断方法参数是否带有@CurrentUser注解且参数类型为User或其子类</span></span><br><span class="line"><span class="keyword">return</span> methodParameter.hasParameterAnnotation(CurrentUser.class) &amp;&amp; User.class.isAssignableFrom(methodParameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//获取当前登录用户</span></span><br><span class="line"><span class="keyword">return</span> userService.getCurrent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤三：WebMvcConfig配置自定义解析器"><a href="#步骤三：WebMvcConfig配置自定义解析器" class="headerlink" title="步骤三：WebMvcConfig配置自定义解析器"></a><strong>步骤三：WebMvcConfig配置自定义解析器</strong></h2><p>新建一个webconfig 实现 WebMvcConfigurer 接口， 需要重写 addArgumentResolvers 这个方法，初始化我们创建的操作类。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置自定义解析器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CurrentUserMethodArgumentResolver <span class="title">currentUserMethodArgumentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CurrentUserMethodArgumentResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">argumentResolvers.add(currentUserMethodArgumentResolver());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤四：编写代码测试"><a href="#步骤四：编写代码测试" class="headerlink" title="步骤四：编写代码测试"></a><strong>步骤四：编写代码测试</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getUser"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">queryUser</span><span class="params">( @CurrentUser UserInfoVO userInfo)</span> </span>&#123;</span><br><span class="line">    System.out.println(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>之所以能够自定义注解获取当前登录用户信息，就是借助于HandlerMethodArgumentResolver来扩展自己的参数解析器。</p><p>在resolveArgument接口中编写对应获取登录用户信息的逻辑代码。举个栗子，有的系统是从数据库中获取数据，有的则把对应数据放在redis中。所以在这里从不同地方获取即可。</p><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在项目开发过程中，难免都要获取当前登录用户的信息。通常的做法，都是开发一个获取用户信息的接口。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="HandlerMethodArgumentResolver" scheme="http://www.devcheng.net/tags/HandlerMethodArgumentResolver/"/>
    
      <category term="自定义注解" scheme="http://www.devcheng.net/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>重装系统如何继续恢复Hexo博客</title>
    <link href="http://www.devcheng.net/post/7fee676.html"/>
    <id>http://www.devcheng.net/post/7fee676.html</id>
    <published>2020-07-12T09:42:58.000Z</published>
    <updated>2020-07-13T13:38:52.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾的缘故，但是清理系统垃圾之后还是有卡顿的现象，干脆从新装一个系统得了。</p><p>在重装系统之前，事先把原来Hexo的文件夹都备份一下。同时，我还备份了对应的id_rsa和id_rsa.pub文件。</p><p><strong>如果要重装系统，务必要备份对应的文件！</strong></p><p>备份好对应的文件之后，开始重装系统！</p><h3 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a><strong>安装Node.js和Git</strong></h3><p>1.安装Node.js</p><p>2.安装Git</p><p>具体细节就不展开细说了，可自行为度娘！安装成功node.js和git之后，查看一下确保无问题。</p><p><img src="/images/devcheng_net_hexo_recover_001.png" alt="“伊成博客”"></p><h3 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a><strong>配置SSH key</strong></h3><p>在最上面，已经提及到了 SSH key 对应的2个文件，<br>找到路径 C:\Users\用户名.ssh 有无.ssh文件夹，没有则创建。</p><p>执行命令，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><p>因为重装系统之前已经备份id_rsa和id_rsa.pub文件,所以把这2个文件复制到.ssh文件夹内即可。</p><p>使用命令，测试是否成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_hexo_revover_002.png" alt="“伊成博客”"></p><h3 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a><strong>配置Git用户名和邮箱</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;devcheng&quot;    // 你的coding或github用户名，并非昵称</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;// 你的coding或github的注册邮箱</span><br></pre></td></tr></table></figure><h3 id="复制备份的文件夹"><a href="#复制备份的文件夹" class="headerlink" title="复制备份的文件夹"></a><strong>复制备份的文件夹</strong></h3><p>文件夹删除node_modules public .git .deploy_git</p><p><img src="/images/devcheng_net_hexo_recover_003.png" alt="“伊成博客”"></p><h3 id="和远程项目关联"><a href="#和远程项目关联" class="headerlink" title="和远程项目关联"></a><strong>和远程项目关联</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 你的hexo博客git地址</span><br></pre></td></tr></table></figure><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a><strong>安装hexo</strong></h3><p>开始执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>并没有成功的安装好hexo,于是从新换一个命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>依然还是提示有对应的依赖没有找到，于是我把最开始备份的整个文件夹，全部都复制到了现在这个目录。</p><p><img src="/images/devcheng_net_hexo_recover_004.png" alt="“伊成博客”"></p><h3 id="强势启动"><a href="#强势启动" class="headerlink" title="强势启动"></a><strong>强势启动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>突然发现，居然可以启动起来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>以上步骤，仅供参考，步骤不是惟一定死的，各位务必根据自己的操作情况而定。这篇博客就是从重装系统之后写的第一篇博文！<br>如有不妥之处，请留言！</p><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="恢复Hexo" scheme="http://www.devcheng.net/tags/%E6%81%A2%E5%A4%8DHexo/"/>
    
      <category term="重装系统" scheme="http://www.devcheng.net/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中按字段查询重复数据</title>
    <link href="http://www.devcheng.net/post/4dfd5416.html"/>
    <id>http://www.devcheng.net/post/4dfd5416.html</id>
    <published>2020-07-09T13:37:57.000Z</published>
    <updated>2020-07-09T13:48:17.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug(没有对数据做重复数据校验)等。</p><p>既然是难免的情况，那如何处理呢？</p><h2 id="根据一个字段查询重复数据"><a href="#根据一个字段查询重复数据" class="headerlink" title="根据一个字段查询重复数据"></a>根据一个字段查询重复数据</h2><p>举个栗子，有个用户表测试小姐姐拼命的创建同一条数据插入到用户表。<br>那么在用户表中就会存在相同用户名的多条数据，根据 用户名 查询重复数据的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> userName <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果查询出来重复数据只需要保留一条，那就得把多余的数据删除即可，对应SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName);</span><br></pre></td></tr></table></figure><p>这里是根据 用户名分组保留用户ID最大的那条数据，其它的都删掉！<br>具体保留哪条数据，各位小伙伴可自行决定~</p><h2 id="根据多个字段查询重复数据"><a href="#根据多个字段查询重复数据" class="headerlink" title="根据多个字段查询重复数据"></a>根据多个字段查询重复数据</h2><p>在举个栗子，在这个用户表中 用户名和用户类型 都重复的需要查询出来，对应的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据多个字段查询，保留一条数据，删除多余数据SQL如下：</p><p>方法一：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType);</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nameAndType <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user) tt <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType <span class="keyword">HAVING</span> <span class="keyword">count</span>(nameAndType) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>方法三：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> maxid <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(userId) <span class="keyword">as</span> maxid, <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType) t);</span><br></pre></td></tr></table></figure></p><p>方法一中删除多余重复数据和上面文章中的思路是一致的，方法二和方法三的思路是利用CONCAT函数。</p><p>以上，如果你开发过程中遇到同样问题，可以使用上面的SQL尝试一下！</p><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL" scheme="http://www.devcheng.net/tags/MySQL/"/>
    
      <category term="重复数据" scheme="http://www.devcheng.net/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java8中列表的排序(升序、降序)</title>
    <link href="http://www.devcheng.net/post/835182f7.html"/>
    <id>http://www.devcheng.net/post/835182f7.html</id>
    <published>2020-07-02T13:34:11.000Z</published>
    <updated>2020-07-02T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来。</p><p>时过境迁，现在的项目中采用了Spring Data JPa,当然也支持排序。但本文中的主角可不是它，在很多情况下我们查询出来的List数据没有排序好或是需要二次按照某字段排序，这个时候，我们就可以使用Java8对其排序。</p><p>首先，看个基础语法，如下：</p><h3 id="单个字段排序"><a href="#单个字段排序" class="headerlink" title="单个字段排序"></a>单个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回 对象集合以类属性一升序排序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序排序 注意两种写法</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">//先以属性一升序,结果进行属性一降序</span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一).reversed());</span></span><br><span class="line"><span class="comment">//以属性一降序 </span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));</span></span><br></pre></td></tr></table></figure><h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 对象集合以类属性一升序 属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span></span><br><span class="line"> list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一升序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,再进行属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(Comparator.comparing(User::getId).reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(User::getId,Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以实例代码我们可以发现</p><p>写法一： Comparator.comparing(类::属性一).reversed();</p><p>写法二： Comparator.comparing(类::属性一,Comparator.reverseOrder());</p><p>两种排序是完全不一样的,一定要区分开来。</p><p>写法一是得到排序结果后再排序；</p><p>写法二是直接进行排序,很多人会混淆导致理解出错,但写法二更好理解,建议使用写法二。</p><h2 id="完整例子demo"><a href="#完整例子demo" class="headerlink" title="完整例子demo"></a>完整例子demo</h2><p>最后贴一个完整的例子，供大家参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">22</span>,<span class="string">"张X"</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">27</span>,<span class="string">"李X"</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"王X"</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">"赵X"</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    list.add(user4);</span><br><span class="line">    <span class="keyword">for</span>(User u :list)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; newList = list.stream().sorted(Comparator.comparing(User::getAge))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">for</span>(User u :newList)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
      <category term="排序" scheme="http://www.devcheng.net/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中三大构建工具的发展历程（Ant、Maven和Gradle）</title>
    <link href="http://www.devcheng.net/post/e200ec64.html"/>
    <id>http://www.devcheng.net/post/e200ec64.html</id>
    <published>2020-06-21T07:47:09.000Z</published>
    <updated>2020-06-21T07:49:21.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们要写一个Java程序，一般的步骤是编译，测试，打包。</p><p>这个构建的过程，如果文件比较少，我们可以手动使用java, javac,jar命令去做这些事情。但当工程越来越大，文件越来越多，这个事情就不是那么地令人开心了。</p><p>因为这些命令往往都是很机械的操作。所以我们可以把这些机械的操作交给机器去做。</p><p>而在linux中，有一个工具叫make。<br>我们可以通过编写Makefile来执行工程的构建，在windows上相应的工具是nmake。</p><p>那既然有现成的工具，为什么当时没有选择Makefile呢？说道这里那就不得不提一下Ant了。</p><h2 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h2><p>说起Ant，就不得不说另一个Apache开源项目Tomcat。Tomcat作为轻量级Web容器，早已声名鹊起。最开始的时候，Ant是Tomcat的一部分，Ant的唯一目的就是build Tomcat。</p><p>不久，很多Java开源项目意识到Ant的简洁适用，更重要的是弥补Makefiles的不足。自从Jakarta以及Apache项目开始采用Ant以来,作为构建工具的Ant很快发展在各种各样的项目中。</p><p>在2000年1月，Ant脱离了Tomcat，成为独立的Apache开源项目，由独立的CVS模块维护，正式更名为Apache Ant。</p><p>第一个Ant版本是Tomcat 3.1于2000年4月19日发行的版本。此版本后来称为Ant 0.3.1。</p><p>到目前Ant最新的版本是 <strong>2020年5月13日 版本号：1.10.8</strong></p><p>具体的版本发行历程可点击链接查看 <a href="http://ant.apache.org/faq.html" target="_blank" rel="noopener">http://ant.apache.org/faq.html</a></p><h3 id="Ant示例"><a href="#Ant示例" class="headerlink" title="Ant示例"></a>Ant示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"HelloWorld"</span> <span class="attr">default</span>=<span class="string">"run"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">value</span>=<span class="string">"src"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dest"</span> <span class="attr">value</span>=<span class="string">"classes"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jarfile"</span> <span class="attr">value</span>=<span class="string">"hello.jar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;jarfile&#125;"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">depends</span>=<span class="string">"build"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">java</span> <span class="attr">classname</span>=<span class="string">"test.ant.HelloWorld"</span> <span class="attr">classpath</span>=<span class="string">"$&#123;hello_jar&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;hello_jar&#125;"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例，得知Ant定义了五个任务，init, compile, build, test,clean。</p><p>每个任务做什么都定义清楚了。在打包之前要先编译，所以通过depends来指定依赖的路径。</p><p>如果在命令行里执行ant build，那就会先执行compile，而compile又依赖于init，所以就会先执行init。</p><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant test</span><br></pre></td></tr></table></figure></p><p>通过命令就可以执行编程，打包，测试。为开发者带来了很大的便利，提供了工作效率。</p><p>但是Ant有一个很致命的缺陷，那就是没办法管理依赖。</p><p>我们一个工程，要使用很多第三方工具，不同的工具，不同的版本。</p><p>每次打包都要自己手动去把正确的版本拷到lib下面去，不用说，这个工作既枯燥还特别容易出错。为了解决这个问题，Maven如约而至。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven之前我们经常使用Ant来进行Java项目的构建，然后Ant仅是一个构建工具，它并未对项目的中的工程依赖以及项目本身进行管理，并且Ant作为构建工具未能消除软件构建的重复性，因为不同的项目需要编写对应的Ant任务。</p><p>Maven作为后来者，继承了Ant的项目构建功能，并且提供了依赖关系，项目管理的功能，因此它是一个项目管理和综合工具， 其核心的依赖管理， 项目信息管理， 中央仓库，约定大于配置的核心功能使得Maven成为当前Java项目构建和管理工具的标准选择。</p><p>Maven 发展历程： Maven –&gt; Maven2 –&gt; Maven3</p><p>到目前Maven最新的版本是 <strong>2019-11-25 版本号：3.6.3</strong></p><h3 id="Maven示例"><a href="#Maven示例" class="headerlink" title="Maven示例"></a>Maven示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...xmlns...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devcheng.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例得知，包的坐标是net.devcheng.demo:Example:0.1.0-SNAPSHOT，而工程中要依赖junit:junit:4.10。</p><p>那么Maven就会自动去帮我把junit打包进来。如果本地没有junit，maven还会帮自动去网上下载。我们还通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。</p><p>相对于上文中的Ant来说，Maven抛弃了Ant中通过target定义任务的做法，对于依赖引入了生命周期。</p><p>最后在说说 Gradle。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Gradle是一个基于Apache Ant和ApacheMaven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。</p><p>由以上定义得知，Gradle已经抛弃了Ant,Maven中Xml配置的形式。Gradle继承了Maven中仓库，坐标，依赖这些核心概念。文件的布局也和Maven相同。但同时，又继承了Ant中target的概念，我们又可以重新定义自己的任务(在Gradle中叫做task)。</p><h3 id="Gradle示例"><a href="#Gradle示例" class="headerlink" title="Gradle示例"></a>Gradle示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;</span><br><span class="line">    your tests.</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由示例可看出内容很简单，引入了java插件，指定仓库，指定依赖。可以看到依赖的设定相比起xml的写法，变得大大简化了。</p><p>到目前Gradle最新的版本是 <strong>2020年6月2日 版本号：v6.5</strong></p><h3 id="Gradle-vs-Maven"><a href="#Gradle-vs-Maven" class="headerlink" title="Gradle vs Maven"></a>Gradle vs Maven</h3><p>关于Gradle和Maven的区别，简单比较如下：</p><ul><li><p>Maven和Gradle对依赖项的scope有所不同。<br>在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。<br>而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。</p></li><li><p>Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</p></li><li>解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确。</li><li>Maven引用依赖方面采用的xml，而Gradle不是。</li></ul><hr><h6 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们要写一个Java程序，一般的步骤是编译，测试，打包。&lt;/p&gt;
&lt;p&gt;这个构建的过程，如果文件比较少，我们可以手动使用java, java
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Ant" scheme="http://www.devcheng.net/tags/Ant/"/>
    
      <category term="Maven" scheme="http://www.devcheng.net/tags/Maven/"/>
    
      <category term="Gradle" scheme="http://www.devcheng.net/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>java通过反射获取注解@Column中的信息</title>
    <link href="http://www.devcheng.net/post/74b831b2.html"/>
    <id>http://www.devcheng.net/post/74b831b2.html</id>
    <published>2020-06-20T02:44:08.000Z</published>
    <updated>2020-06-20T02:49:43.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devcheng.demo.restful.data.service.model.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonDeserialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"DEV_CHENG_FILE_DEMO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscloseFileEntity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ID"</span>,columnDefinition = <span class="string">"ID"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"APPLY_NO"</span>,columnDefinition = <span class="string">"申请号"</span>)</span><br><span class="line">    <span class="keyword">private</span> String applyNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_NAME"</span>,columnDefinition = <span class="string">"文件名称"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_SIZE"</span>,columnDefinition = <span class="string">"文件大小"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileSize;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"TITLE"</span>,columnDefinition = <span class="string">"标题"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"IS_VALID"</span>,columnDefinition = <span class="string">"是否有效"</span>)</span><br><span class="line">    <span class="keyword">private</span> String isValid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"SAVE_DATE"</span>,columnDefinition = <span class="string">"保存日期"</span>)    </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime saveDate;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上得知，需要从 @Column 注解中获取 name和columnDefinition 中的信息，那如何可以获取到对应的信息？</p><p>在获取 @Column 注解中的信息之前，先看看 columnDefinition是啥意思?</p><h2 id="columnDefinition"><a href="#columnDefinition" class="headerlink" title="columnDefinition"></a>columnDefinition</h2><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用。</p><p>值得注意的一点是：在编程语言中字符串一般都用String表示，但是数据库中varcahr数值类型有长度限制，一旦需要大文本，则需要text数值类型。但是String类型默认映射的数值类型是varchar，columnDefinition可以进行额外指定。</p><h2 id="获取注解-Column中的信息"><a href="#获取注解-Column中的信息" class="headerlink" title="获取注解@Column中的信息"></a>获取注解@Column中的信息</h2><p>实现思路：通过类路径利用反射获取到对应的注解信息，从而获取到对应@Column中的信息<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TableColumnsVO&gt; <span class="title">getFiledAndAnnotateInfo</span><span class="params">(String entityPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TableColumnsVO&gt; tableColumnsLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(entityPath);</span><br><span class="line">            Field[] fields = aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">            Column presentColumn;</span><br><span class="line">            <span class="keyword">for</span> (Field field:fields)</span><br><span class="line">            &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(Column.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    presentColumn = field.getDeclaredAnnotation(Column.class);</span><br><span class="line">                    TableColumnsVO tableData = <span class="keyword">new</span> TableColumnsVO();</span><br><span class="line">                    tableData.setColumnName(presentColumn.name());</span><br><span class="line">                    tableData.setColumnDefinationInfo(presentColumn.columnDefinition());</span><br><span class="line">                    tableColumnsLists.add(tableData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"获取字段和注释异常：%s"</span>, entityPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableColumnsLists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的 TableColumnsVO代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableColumnsVO</span></span>&#123;</span><br><span class="line">    <span class="comment">//列名</span></span><br><span class="line">    <span class="keyword">private</span> String columnName;</span><br><span class="line">    <span class="comment">//ColumnDefinationInfo信息</span></span><br><span class="line">    <span class="keyword">private</span> String columnDefinationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="java反射" scheme="http://www.devcheng.net/tags/java%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Column注解" scheme="http://www.devcheng.net/tags/Column%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>墙裂推荐一款redis客户端可视化工具之RedisPlus</title>
    <link href="http://www.devcheng.net/post/64102a3b.html"/>
    <id>http://www.devcheng.net/post/64102a3b.html</id>
    <published>2020-06-07T07:15:43.000Z</published>
    <updated>2020-06-07T07:23:36.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具。<br>比如：Redis Desktop Manager，RedisView ，RedisClient 等工具。</p><p>今天墙裂推荐一款redis客户端可视化工具：RedisPlus</p><h2 id="RedisPlus"><a href="#RedisPlus" class="headerlink" title="RedisPlus"></a><strong>RedisPlus</strong></h2><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h3><p>RedisPlus是为Redis可视化管理开发的一款开源免费的桌面客户端软件，支持Windows 、Linux、Mac三大系统平台，RedisPlus提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。该软件支持单机、集群模式连接，同时还支持SSH（单机、<strong>集群</strong>）通道连接。</p><p>项目地址： <a href="https://gitee.com/MaxBill/RedisPlus" target="_blank" rel="noopener">https://gitee.com/MaxBill/RedisPlus</a></p><p>运行截图：<br><img src="/images/devcheng_net_redis_001.jpg" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis_002.jpg" alt="“伊成博客”"></p><p>RedisPlus目前最新版本为：3.2.0。<br>项目介绍中得知，RedisPlus将不再更新迭代，包括V4.0的electron和jfx11版本都将停止开发和更新。</p><p>下载地址<br>百度下载：链接: <a href="https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ</a> 提取码: 3pcm</p><p><img src="/images/devcheng_net_redis_003.png" alt="“伊成博客”"></p><h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a><strong>最后说一句</strong></h2><p>在网上不乏有很多redis客户端工具，但是真正能支持集群的没几个工具，同时也找到了一款国外的工具，名字叫FastoRedis。<br>下载地址：<a href="https://fastoredis.com/anonim_users_downloads" target="_blank" rel="noopener">https://fastoredis.com/anonim_users_downloads</a></p><p>FastoRedis 的官方介绍<br>Download FastoRedis - cross-platform client for Redis, supported main Redis database features like: modules, cluster, sentinel, ssh tunneling.</p><p>但是这款工具是收费的，土豪请无视这句话！</p><p>最后有需要RedisPlus的又觉得从百度网盘下载麻烦的，可以加一下我的QQ群：816175200 免费获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="RedisPlus" scheme="http://www.devcheng.net/tags/RedisPlus/"/>
    
      <category term="redis客户端" scheme="http://www.devcheng.net/tags/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本新特性小结</title>
    <link href="http://www.devcheng.net/post/5ae138f6.html"/>
    <id>http://www.devcheng.net/post/5ae138f6.html</id>
    <published>2020-05-30T07:07:22.000Z</published>
    <updated>2020-05-30T07:08:50.691Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天(2020-5-30)JDK已经发布到了 JDK14。</p><p>在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。</p><p>JDK 14已经于2020年3月17日如期发布。下面介绍各个版本的新特性，后续随着JDK新版本的更新迭代，本文会持续更新。</p><p>JDK从1.5版本开始，在官方的正式文档与宣传资料中已经不再使用类似JDK1.5的名称，只有程序员内部</p><p>使用的开发版本号(DeveloperVersion，例如java-version的输出)才继续沿用1.5、1.6、1.7和1.8的版本号，</p><p>而公开版本号(Product Version)则改为JDK5、JDK6、JDK7和JDK8的命名方式。</p><h2 id="JDK-5-新特性"><a href="#JDK-5-新特性" class="headerlink" title="JDK 5 新特性"></a>JDK 5 新特性</h2><p>1.自动装箱、拆箱</p><p>2.静态导入(static import)</p><p>3.增强for循环（for-each）</p><p>4.可变参数</p><p>5.枚举（enmu）</p><p>6.泛型</p><p>7.元数据</p><p>8.线程并发库（JUC）</p><hr><h2 id="JDK-6-新特性"><a href="#JDK-6-新特性" class="headerlink" title="JDK 6 新特性"></a>JDK 6 新特性</h2><p>1.AWT中新增的两个类Desktop和SystemTray</p><p>2.使用JAXB2来实现对象与XML之间的映射</p><ol start="3"><li><p>新增处理DOM和SAX之外又一种处理XML文档的API：STAX</p></li><li><p>使用Compiler API动态编译java源文件</p></li><li><p>轻量级Http Server API</p></li><li><p>插入式注解处理API（用于处理Annotations）</p></li><li><p>用Console开发控制台程序</p></li><li><p>对ruby、groovy、javascript等脚本语言的支持</p></li><li><p>Common Annotations</p></li></ol><hr><h2 id="JDK-7-新特性"><a href="#JDK-7-新特性" class="headerlink" title="JDK 7 新特性"></a>JDK 7 新特性</h2><ol><li><p>对Java集合（Collections）的增强支持</p></li><li><p>在switch中可用String</p></li><li><p>数值可加下划线（eg:int one_million=123_1）</p></li><li><p>支持二进制文字（int binary=0b1001_1001）</p></li><li><p>简化可变参数方法的调用</p></li><li><p>自动资源管理</p></li><li><p>类型推断</p></li><li><p>catch 多个类型异常</p></li></ol><hr><h2 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h2><ol><li><p>Stream函数式操作流元素集合</p></li><li><p>Lambda表达式</p></li><li><p>新的日期时间 API(Java Date/time API)</p></li><li><p>新增接口：默认方法与静态方法</p></li><li><p>Nashorm(Rhino的接替者，轻量级高性能的javascript运行环境)</p></li><li><p>Accumlators多线程lock</p></li><li><p>方法引用，与Lambda表达式联合使用</p></li><li><p>引入重复注解和类型注解</p></li><li><p>类型注解</p></li><li><p>新增base64加解密API</p></li><li><p>数组并行（parallel）操作</p></li><li><p>JVM的permGen空间移除，被Metaspace元空间取代</p></li></ol><hr><h2 id="JDK-9-新特性"><a href="#JDK-9-新特性" class="headerlink" title="JDK 9 新特性"></a>JDK 9 新特性</h2><ol><li><p>目录结构</p></li><li><p>模块化系统</p></li><li><p>jshell</p></li><li><p>多版本兼容JAR</p></li><li><p>接口的私有方法</p></li><li><p>改进try-with-resourcs</p></li><li><p>改进砖石操作符</p></li><li><p>限制使用单独下划线标识符</p></li><li><p>String存储结构变更</p></li><li><p>快速创建只读结合</p></li><li><p>增强Stream API</p></li><li><p>改进Optional 类</p></li><li><p>多分辨率图像 API</p></li><li><p>全新 HTTP客服端API</p></li><li><p>智能JAVA 编译工具</p></li><li><p>统一JVM 日志系统</p></li><li><p>javadoc 的 HTML5 支持</p></li><li><p>java 动态编译</p></li></ol><hr><h2 id="JDK-10-新特性"><a href="#JDK-10-新特性" class="headerlink" title="JDK 10 新特性"></a>JDK 10 新特性</h2><ol><li><p>局部变量类型推断</p></li><li><p>将JDK多存储库合并为单储存库</p></li><li><p>垃圾回收接口</p></li><li><p>并行Full GC 的G1</p></li><li><p>应用数据共享</p></li><li><p>线程局部管控</p></li><li><p>移除Native-Header Generation Tool （javah）</p></li><li><p>Unicode 标签扩展</p></li><li><p>备用内存设备上分配堆内存</p></li><li><p>基于实验JAVA 的JIT 编译器</p></li><li><p>Root 证书</p></li><li><p>基于时间的版本控制</p></li></ol><hr><h2 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h2><ol><li><p>字符串加强</p></li><li><p>HttClient Api</p></li><li><p>用于 Lambda 参数的局部变量语法</p></li><li><p>ZGC (并发回收的策略)</p></li></ol><hr><h2 id="JDK-12-新特性"><a href="#JDK-12-新特性" class="headerlink" title="JDK 12 新特性"></a>JDK 12 新特性</h2><ol><li><p>Switch Expressions</p></li><li><p>Shenandoah GC (GC 算法)</p></li></ol><hr><h2 id="JDK-13-新特性"><a href="#JDK-13-新特性" class="headerlink" title="JDK 13 新特性"></a>JDK 13 新特性</h2><ol><li><p>switch优化更新</p></li><li><p>文本块升级</p></li><li><p>重新实现旧版套接字API</p></li><li><p>核心库/java.util中：I18N</p></li><li><p>增加ZGC以将未使用的堆内存返回给操作系统</p></li></ol><hr><h2 id="JDK-14-新特性"><a href="#JDK-14-新特性" class="headerlink" title="JDK 14 新特性"></a>JDK 14 新特性</h2><ol><li><p>switch优化变更为最终版</p></li><li><p>垃圾回收相</p></li></ol><ul><li>删除cms垃圾收集器</li><li>弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合</li><li>将 zgc 垃圾回收器移植到 macOS 和 windows 平台 </li></ul><ol start="3"><li><p>instanceof的模式匹配（预览版）</p></li><li><p>删除了安全库java.security.acl API</p></li><li><p>货币格式（优化）</p></li><li><p>友好的空指针异常</p></li><li><p>外部存储器API（孵化）</p></li></ol><p>… </p><p><strong> 本文会持续更新… </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;截止到今天(2020-5-30)JDK已经发布到了 JDK14。&lt;/p&gt;
&lt;p&gt;在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。&lt;/p&gt;
&lt;p&gt;JDK 14已经于2020年3月17日如期发
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="新特性" scheme="http://www.devcheng.net/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK" scheme="http://www.devcheng.net/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>15个超实用的IDEA快捷键</title>
    <link href="http://www.devcheng.net/post/ea3f1216.html"/>
    <id>http://www.devcheng.net/post/ea3f1216.html</id>
    <published>2020-05-23T04:28:19.000Z</published>
    <updated>2020-05-23T04:47:57.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a><strong>叨叨叨</strong></h3><p>相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ctrl+V)也是常用的快捷键之一。<br>掌握必要的一些快捷键，可以提高工作效率，但是IDEA中的快捷键可不是一个两个。为此博主特意整理里15个高频超级实用<br>的IDEA快捷键。</p><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h3><p><strong>Ctrl + Alt + O</strong>  : 移除未使用的包 </p><blockquote><p>tip:可能会和QQ 屏幕识图快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + M</strong> :重构函数:将选中代码提取为函数 </p><p><strong>Ctrl + Alt + L</strong> :代码格式化</p><blockquote><p>tip:可能会和QQ 中的快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + T</strong>:可以把代码包在一个块内，例如：try/catch</p><p><strong>Ctrl + Alt + B</strong>:定位至选中类或者方法的具体实现</p><p><strong>Ctrl + Shift + F</strong>:全局查找快捷键</p><p><strong>Ctrl + Shift + R</strong>:全局替换</p><p><strong>Ctrl + Shift + U</strong>:大小写切换</p><p><strong>Ctrl + Shift + /</strong>:使用 /**/ 注释</p><p><strong>Ctrl + /</strong>:使用 // 注释</p><p><strong>Ctrl + X（Ctrl + Y）</strong>:删除行</p><p><strong>Ctrl + D</strong>:复制行</p><p><strong>Ctrl+Shift+Alt+J</strong>:批量修改变量快捷键</p><p><strong>F2 或 Shift+F2</strong>:快速定位高亮错误或警告</p><p><strong>Shift+Click</strong>:可以关闭文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;叨叨叨&quot;&gt;&lt;a href=&quot;#叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;叨叨叨&quot;&gt;&lt;/a&gt;&lt;strong&gt;叨叨叨&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ct
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="IDEA快捷键" scheme="http://www.devcheng.net/tags/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发的毕业论文管理系统</title>
    <link href="http://www.devcheng.net/post/1129f657.html"/>
    <id>http://www.devcheng.net/post/1129f657.html</id>
    <published>2020-05-08T12:22:47.000Z</published>
    <updated>2020-05-08T13:24:49.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管理员。<br>不同角色拥有不同的菜单功能，管理员是系统中权限最大的一个角色，即可以管理系统的各个配置以及数据操作。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA 2019.3<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven</li><li>Thymeleaf</li><li>Echarts</li><li>文件服务器centos7</li><li>…</li></ul><h2 id="项目页面预览"><a href="#项目页面预览" class="headerlink" title="项目页面预览"></a><strong>项目页面预览</strong></h2><ul><li><p>系统登录页<br><img src="/images/bylw1.png" alt="“伊成博客”"></p></li><li><p>系统首页<br><img src="/images/bylw2.png" alt="“伊成博客”"></p></li><li><p>个人信息页<br><img src="/images/bylw3.png" alt="“伊成博客”"></p></li><li><p>数据分析页<br><img src="/images/bylw4.png" alt="“伊成博客”"></p></li><li><p>选题情况页<br><img src="/images/bylw5.png" alt="“伊成博客”"></p></li><li><p>菜单开关页<br><img src="/images/bylw6.png" alt="“伊成博客”"></p></li><li><p>学生管理页<br><img src="/images/bylw7.png" alt="“伊成博客”"></p></li><li><p>修改密码页<br><img src="/images/bylw8.png" alt="“伊成博客”"></p></li><li><p>下载任务书<br><img src="/images/bylw9.png" alt="“伊成博客”"></p></li><li><p>上传论文页<br><img src="/images/bylw10.png" alt="“伊成博客”"></p></li><li><p>选定学生页<br><img src="/images/bylw11.png" alt="“伊成博客”"></p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>使用IDEA(eclipse)前导入本项目前，请确保你本地环境是已经配置好了Java环境变量，本地安装好了虚拟机且是centos7。<br>文件服务器搭建可以参考 <a href="http://www.devcheng.net/post/c668f449.html">点击 文件服务器搭建 传送门</a></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索我们的群号：816175200</p><p>也可以直接在博客里找到我的QQ联系我！</p><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a><strong>温馨提示</strong></h2><p>本项目可以当做毕业设计，内含毕业论文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="毕业论文管理系统" scheme="http://www.devcheng.net/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>centos7.x搭建ftp服务及创建用户</title>
    <link href="http://www.devcheng.net/post/c668f449.html"/>
    <id>http://www.devcheng.net/post/c668f449.html</id>
    <published>2020-04-18T13:23:05.000Z</published>
    <updated>2020-04-18T13:45:26.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FTP是什么东东？"><a href="#FTP是什么东东？" class="headerlink" title="FTP是什么东东？"></a>FTP是什么东东？</h2><p>FTP是 File Transfer Protocol 文件传输协议的英文名称,用于在Internet上控制文件的双向传输. 同时它也是一个应用程序.一般的Linux系统默认带有ftp软件或者是vsftpd。</p><h2 id="为何搭建？"><a href="#为何搭建？" class="headerlink" title="为何搭建？"></a>为何搭建？</h2><p>目的是从window系统中上传文件到linux系统的服务器里。</p><p>##安装步骤<br>提前使用终端工具连接上对应的服务器，这里我们以Xshell 为例</p><p><strong> 步骤一 </strong><br>登录到服务器后，先切换为 root 用户<br>切换到 home 文件夹下（可以换任意一个你喜欢的文件夹下，这里以home文件夹为例）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br></pre></td></tr></table></figure></p><p><strong> 步骤二 </strong><br>接着，输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤三 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤四 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vsftpd</span><br></pre></td></tr></table></figure></p><p>注意： 安装完成后，找到 /etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。</p><p><strong> 步骤五 </strong><br>修改selinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsebool -a | grep ftp</span><br></pre></td></tr></table></figure></p><p> <img src="/images/devcheng_net_ftp2.png" alt="“伊成博客”"></p><p>执行上面命令，从返回的结果看到 ftpd_full_access 和 tftp_home_dir两行都是off，说明没有开启外网的访问。</p><p><strong> 步骤六 </strong><br>开启外网的访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># setsebool -P ftpd_full_access on</span></span><br><span class="line">[root@bogon ~]<span class="comment"># setsebool -P tftp_home_dir on</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/devcheng_net_ftp3.png" alt="“伊成博客”"></p><p><strong> 步骤七 </strong><br>关闭匿名访问<br>修改 /etc/vsftpd/vsftpd.conf文件：<br>找到 anonymous_enable=NO  #将YES改为NO</p><p>到此基本配置都完成了，使用以下命令重启 ftp 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure></p><p>另外设置一下 开机启动 ftp 服务<br>使用以下命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> vsftpd.service</span><br></pre></td></tr></table></figure></p><p>通过以上的几个步骤，ftp 服务就已经搭建完毕，接着我们还需要创建用户并指定对应的目录</p><h2 id="创建目录以及用户"><a href="#创建目录以及用户" class="headerlink" title="创建目录以及用户"></a>创建目录以及用户</h2><p>在/var 目录下创建一个 www 文件夹,www文件夹中创建一个site文件夹一个da文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> www</span><br><span class="line">mkdir site</span><br><span class="line">mkdir da</span><br></pre></td></tr></table></figure></p><h3 id="创建用户da并指定用户目录为-var-www-da"><a href="#创建用户da并指定用户目录为-var-www-da" class="headerlink" title="创建用户da并指定用户目录为/var/www/da"></a>创建用户da并指定用户目录为/var/www/da</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /var/www/da da</span><br><span class="line">passwd da</span><br></pre></td></tr></table></figure><p>修改xiao用户的用户目录为/var/www/site<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d /var/www/site xiao</span><br></pre></td></tr></table></figure></p><h3 id="查看新创建的用户的信息"><a href="#查看新创建的用户的信息" class="headerlink" title="查看新创建的用户的信息"></a>查看新创建的用户的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp4.png" alt="“伊成博客”"></p><h3 id="修改-etc-vsftpd-vsftpd-conf文件"><a href="#修改-etc-vsftpd-vsftpd-conf文件" class="headerlink" title="修改/etc/vsftpd/vsftpd.conf文件"></a>修改/etc/vsftpd/vsftpd.conf文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi vsftpd.conf</span><br></pre></td></tr></table></figure><p>找到 userlist_enable=YES 在这句后面换行追加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userlist_deny=NO       </span><br><span class="line">userlist_file=/etc/vsftpd/user_list</span><br></pre></td></tr></table></figure></p><p>完成 vsftpd.conf 文件修改之后保存退出。</p><h3 id="编辑-user-list-文件"><a href="#编辑-user-list-文件" class="headerlink" title="编辑 user_list 文件"></a>编辑 user_list 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi user_list</span><br></pre></td></tr></table></figure><p>把上面的两个用户 一行一个用户名,输入 da 和xiao<br>按下esc键退出输入模式进入命令模式<br>输入:wq 保存并退出</p><h3 id="配置文件夹权限"><a href="#配置文件夹权限" class="headerlink" title="配置文件夹权限"></a>配置文件夹权限</h3><p>切换到 /var/www 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www</span><br></pre></td></tr></table></figure></p><h3 id="更改www里面两个文件夹的权限"><a href="#更改www里面两个文件夹的权限" class="headerlink" title="更改www里面两个文件夹的权限"></a>更改www里面两个文件夹的权限</h3><p>输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown da:da da</span><br><span class="line">chown xiao:xiao site</span><br></pre></td></tr></table></figure></p><h3 id="修改da用户的所属用户组-并修改site文件夹的权限"><a href="#修改da用户的所属用户组-并修改site文件夹的权限" class="headerlink" title="修改da用户的所属用户组,并修改site文件夹的权限"></a>修改da用户的所属用户组,并修改site文件夹的权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g xiao da</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp5.png" alt="“伊成博客”"></p><p>修改site文件夹的权限,允许同一个用户组的用户拥有rwx权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 site</span><br></pre></td></tr></table></figure></p><p>到此搭建ftp和创建目录和创建对应用户都全部完成！<br>接下来在代码中验证一下</p><p>使用springboot的配置文件application.yml 配置对应信息，如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ftp:</span><br><span class="line">  host: 192.168.43.41 #你服务器的ip</span><br><span class="line">  port: 21            #端口</span><br><span class="line">  userName: da        #以上创建的ftp用户名</span><br><span class="line">  password: da        #以上创建的ftp密码</span><br><span class="line">  basePath: /var/www/da #文件存放目录</span><br></pre></td></tr></table></figure></p><p><strong>上传文件 代码段 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(String host, <span class="keyword">int</span> port, String username, String password, String basePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String filePath, String filename, InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    FTPClient ftp = <span class="keyword">new</span> FTPClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> reply;</span><br><span class="line">        ftp.connect(host, port);<span class="comment">// 连接FTP服务器</span></span><br><span class="line">        <span class="comment">// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span></span><br><span class="line">        ftp.login(username, password);<span class="comment">// 登录</span></span><br><span class="line">        reply = ftp.getReplyCode();</span><br><span class="line">        <span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</span><br><span class="line">            ftp.disconnect();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切换到上传目录</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.changeWorkingDirectory(basePath + filePath)) &#123;</span><br><span class="line">            <span class="comment">//如果目录不存在创建目录</span></span><br><span class="line">            String[] dirs = filePath.split(<span class="string">"/"</span>);</span><br><span class="line">            String tempPath = basePath;</span><br><span class="line">            <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == dir || <span class="string">""</span>.equals(dir)) <span class="keyword">continue</span>;</span><br><span class="line">                tempPath += <span class="string">"/"</span> + dir;</span><br><span class="line">                <span class="keyword">if</span> (!ftp.changeWorkingDirectory(tempPath)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ftp.makeDirectory(tempPath)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ftp.changeWorkingDirectory(tempPath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置上传文件的类型为二进制类型</span></span><br><span class="line">        ftp.setFileType(FTP.BINARY_FILE_TYPE);</span><br><span class="line">        <span class="comment">//上传文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.storeFile(filename, input)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        ftp.logout();</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftp.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ftp.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_ftp6.png" alt="“伊成博客”"></p><p>看到这里说明以上的配置都没问题，到此本文告一段落了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FTP是什么东东？&quot;&gt;&lt;a href=&quot;#FTP是什么东东？&quot; class=&quot;headerlink&quot; title=&quot;FTP是什么东东？&quot;&gt;&lt;/a&gt;FTP是什么东东？&lt;/h2&gt;&lt;p&gt;FTP是 File Transfer Protocol 文件传输协议的英文名称,用于
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="centos7" scheme="http://www.devcheng.net/tags/centos7/"/>
    
      <category term="搭建ftp服务" scheme="http://www.devcheng.net/tags/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>win10怎么把两张图片合并为一张</title>
    <link href="http://www.devcheng.net/post/87dbd908.html"/>
    <id>http://www.devcheng.net/post/87dbd908.html</id>
    <published>2020-04-07T05:37:28.000Z</published>
    <updated>2020-04-08T01:56:18.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。</p><p>不管你的操作系统是win7还是win10都自带了一个 画图 软件，利用自带的画图软件就可以轻易合成图片了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备两种图片待合成的图片，例如我这里<br><img src="/images/devcheng_net_pic1.png" alt="“伊成博客”"></p><h2 id="图片合成步骤"><a href="#图片合成步骤" class="headerlink" title="图片合成步骤"></a>图片合成步骤</h2><p><strong> 第一步：</strong><br>点击任意一张图片，选择打开方式 – 选择 画图。<br><img src="/images/devcheng_net_pic2.png" alt="“伊成博客”"></p><p><strong> 第二步：</strong><br>将图片的长和宽做对应的变化，拉伸出更多空白地方用于展示其他图片。<br><img src="/images/devcheng_net_pic3.png" alt="“伊成博客”"></p><p><strong> 第三步：</strong><br>点击 主页 – 点击粘贴 – 选择 粘贴来源<br><img src="/images/devcheng_net_pic4.png" alt="“伊成博客”"></p><p><strong> 第四步：</strong><br>选择需要合成的图片，点击打开。<br><img src="/images/devcheng_net_pic5.png" alt="“伊成博客”"></p><p><strong> 第五步：</strong><br>把两张图片做好对应的位置变化，保存即可。<br><img src="/images/devcheng_net_pic6.png" alt="“伊成博客”"></p><p>这样两张图片就轻易合成为一张图片了，如果是多张图需要合并为一张图，重复操作步骤三即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="win10" scheme="http://www.devcheng.net/tags/win10/"/>
    
      <category term="图片合成" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis常问面试题整理</title>
    <link href="http://www.devcheng.net/post/3ffff771.html"/>
    <id>http://www.devcheng.net/post/3ffff771.html</id>
    <published>2020-03-29T05:40:39.000Z</published>
    <updated>2020-03-29T06:16:33.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库。<br>传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin" target="_blank" rel="noopener">CAP 定理</a></p><h2 id="1-Redis支持哪几种数据类型？"><a href="#1-Redis支持哪几种数据类型？" class="headerlink" title="1.Redis支持哪几种数据类型？"></a>1.Redis支持哪几种数据类型？</h2><p>1.string：最基本的数据类型，二进制安全的字符串，最大512M。<br>2.list：按照添加顺序保持顺序的字符串列表。<br>3.set：无序的字符串集合，不存在重复的元素。<br>4.sorted set：已排序的字符串集合。<br>5.hash：key-value对的一种集合。<br><img src="/images/devcheng_net_redis1.png" alt="“伊成博客”"></p><p>另外还有四种特殊的 数据类型<br>1.BloomFilter<br>2.HyperLogLog<br>3.BitMap<br>4.Geo</p><p>这几种数据类型的具体介绍。立即了解redis其他的数据类型 : <a href="https://developer.51cto.com/art/201911/605731.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201911/605731.htm</a></p><p><strong> 注意 关于数据类型多说两句：</strong></p><p>redis里存的都是二进制数据，其实就是字节数组（byte[]），这些字节数据是没有数据类型的，只有把它们按照合理的格式解码后，可以变成一个字符串，整数或对象，此时才具有数据类型。</p><p>这一点必须要记住。<strong> 所以任何东西只要能转化成字节数组（byte[]）的，都可以存到redis里</strong>。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成byte数组。</p><ul><li>关键字（Keys）是用于标识一段数据的一个字符串</li><li>值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么</li></ul><p><strong> 关于key </strong></p><ul><li>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率</li><li>key也不要太短，太短的话，key的可读性会降低</li><li>在一个项目中，key最好使用统一的命名模式，例如 user:10000:passwd</li></ul><h2 id="2-Redis是单进程单线程的吗？"><a href="#2-Redis是单进程单线程的吗？" class="headerlink" title="2.Redis是单进程单线程的吗？"></a>2.Redis是单进程单线程的吗？</h2><p>Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="3-Redis为什么是单线程的？"><a href="#3-Redis为什么是单线程的？" class="headerlink" title="3.Redis为什么是单线程的？"></a>3.Redis为什么是单线程的？</h2><p>多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。<br>因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。<br>单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。</p><p>补充额外知识点 ：其它开源软件采用的模型<br>Nginx：多进程单线程模型<br>Memcached：单进程多线程模型</p><h2 id="4-Memcache与Redis的区别都有哪些？"><a href="#4-Memcache与Redis的区别都有哪些？" class="headerlink" title="4.Memcache与Redis的区别都有哪些？"></a>4.Memcache与Redis的区别都有哪些？</h2><p><strong> Memcache （MC）</strong></p><p>看看 MC 的特点：<br>MC 处理请求时使用多线程异步 IO 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；<br>MC 功能简单，使用内存存储数据；<br>MC 的内存结构以及钙化问题我就不细说了，大家可以查看官网了解下；<br>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；<br>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；<br>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：<br>key 不能超过 250 个字节；<br>value 不能超过 1M 字节；<br>key 的最大失效时间是 30 天；<br>只支持 K-V 结构，不提供持久化和主从同步功能。</p><p><strong> Redis </strong></p><p>先简单说一下 Redis 的特点，方便和 MC 比较。</p><ul><li>与 MC 不同的是，Redis 采用单线程模式处理请求。<br>这样做的原因有 2 个：<br>一个是因为采用了非阻塞的异步事件处理机制；<br>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。</li><li>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</li><li>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。</li><li>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。</li></ul><h2 id="5-什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"><a href="#5-什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？" class="headerlink" title="5.什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"></a>5.什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？</h2><p>1.redis持久化就是把内存的数据写到磁盘中去，防止服务器宕机了内存数据丢失。<br>2.数据持久化的方式有2种：    RDB(默认)  和 AOF 。</p><p><strong> RDB （redis database）</strong><br>    核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数<br><img src="/images/devcheng_net_redis2.png" alt="“伊成博客”"></p><p><strong> AOF （append-only file）</strong><br>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作<br>AOF 写入保存。</p><p>存储的内容是 redis通讯协议格式命令的命令文本存储。点击立即了解  —&gt;  <a href="https://www.cnblogs.com/nele/p/8908298.html" target="_blank" rel="noopener">https://www.cnblogs.com/nele/p/8908298.html</a></p><p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件<br>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。<br><img src="/images/devcheng_net_redis3.png" alt="“伊成博客”"></p><p>区别：<br>1、AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。<br>2、AOF 比 RDB 更安全也更大<br>3、RDB 性能比 AOF 好<br>4、如果两个都配了优先加载AOF</p><h2 id="6-说说-Redis-的淘汰策略？"><a href="#6-说说-Redis-的淘汰策略？" class="headerlink" title="6.说说 Redis 的淘汰策略？"></a>6.说说 Redis 的淘汰策略？</h2><p>Redis提供了6中淘汰策略。</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><p><strong> 使用策略规则：</strong><br>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru<br>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p><h2 id="7-什么是缓存穿透，缓存击穿，缓存雪崩？"><a href="#7-什么是缓存穿透，缓存击穿，缓存雪崩？" class="headerlink" title="7. 什么是缓存穿透，缓存击穿，缓存雪崩？"></a>7. 什么是缓存穿透，缓存击穿，缓存雪崩？</h2><p><strong> 缓存穿透</strong><br>描述： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>解决方案：</p><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p><p><strong> 缓存击穿 </strong></p><p>描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p><p>解决方案：</p><p>设置热点数据永远不过期。<br>加互斥锁，互斥锁参考代码如下：<br><img src="/images/devcheng_net_redis4.png" alt="“伊成博客”"></p><p>说明：</p><p>1）缓存中有数据，直接走上述代码13行后就返回结果了</p><p>2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。</p><p>3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。</p><p><strong> 缓存雪崩</strong> </p><p>描述： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案：</p><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。<br>设置热点数据永远不过期。</p><h2 id="8-Redis-架构模式有哪些？讲讲各自的特点？"><a href="#8-Redis-架构模式有哪些？讲讲各自的特点？" class="headerlink" title="8. Redis 架构模式有哪些？讲讲各自的特点？"></a>8. Redis 架构模式有哪些？讲讲各自的特点？</h2><p><img src="/images/devcheng_net_redis5.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis6.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis7.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis8.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis9.png" alt="“伊成博客”"></p><h2 id="9-redis-集群方案都有哪些？"><a href="#9-redis-集群方案都有哪些？" class="headerlink" title="9. redis 集群方案都有哪些？"></a>9. redis 集群方案都有哪些？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p><p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><h2 id="10-在Redis中如何保证只存20W的热点数据？"><a href="#10-在Redis中如何保证只存20W的热点数据？" class="headerlink" title="10. 在Redis中如何保证只存20W的热点数据？"></a>10. 在Redis中如何保证只存20W的热点数据？</h2><p>先计算出20W数据需要占用数据的空间，然后设置数据淘汰策略为 allkey-lru 回收最少使用策略。</p><h2 id="11-Redis支持的Java客户端都有哪些？官方推荐使用哪个？"><a href="#11-Redis支持的Java客户端都有哪些？官方推荐使用哪个？" class="headerlink" title="11.Redis支持的Java客户端都有哪些？官方推荐使用哪个？"></a>11.Redis支持的Java客户端都有哪些？官方推荐使用哪个？</h2><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="12-Redis和Redisson有什么关系？"><a href="#12-Redis和Redisson有什么关系？" class="headerlink" title="12.Redis和Redisson有什么关系？"></a>12.Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象<br> (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><h2 id="13-Jedis与Redisson对比有什么优缺点？"><a href="#13-Jedis与Redisson对比有什么优缺点？" class="headerlink" title="13.Jedis与Redisson对比有什么优缺点？"></a>13.Jedis与Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。<br>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="14-Redis支持事务吗？"><a href="#14-Redis支持事务吗？" class="headerlink" title="14.Redis支持事务吗？"></a>14.Redis支持事务吗？</h2><p>支持 , 表现为多条命令，要么都执行，要么都不执行。</p><p>redis的事务可以分为两步，定义事务和执行事务。<br>使用multi命令开启一个事务，然后把要执行的所有命令都依次排上去。<br>这就定义好了一个事务。此时使用exec命令来执行这个事务，或使用discard命令来放弃这个事务。<br>你可能希望在你的事务开始前，你关心的key不想被别人操作，那么可以使用watch命令来监视这些key，<br>如果开始执行前这些key被其它命令操作了则会取消事务的。也可以使用unwatch命令来取消对这些key的监视。</p><p>redis事务具有以下特点：<br>1、如果开始执行事务前出错，则所有命令都不执行<br>2、一旦开始，则保证所有命令一次性按顺序执行完而不被打断<br>3、如果执行过程中遇到错误，会继续执行下去，不会停止的<br>4、对于执行过程中遇到错误，是不会进行回滚的</p><p>很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。保证不了原子性是因为redis不支持回滚，不过它也给出了不支持的理由。</p><p>不支持回滚的理由：<br>1、redis认为，失败都是由命令使用不当造成<br>2、redis这样做，是为了保持内部实现简单快速<br>3、redis还认为，回滚并不能解决所有问题<br>因此 , 使用redis事务的不太多</p><h2 id="15-Redis分布式锁如何续期？"><a href="#15-Redis分布式锁如何续期？" class="headerlink" title="15. Redis分布式锁如何续期？"></a>15. Redis分布式锁如何续期？</h2><p><a href="https://zhuanlan.zhihu.com/p/71185118" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71185118</a></p><p>16.Redis分布式锁如何防止死锁<br> 方法1 ， 编写2个方法一个加锁，一个解锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li><li>已有锁存在，不做任何操作。</li></ol><p><strong> 解锁代码</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 释放分布式锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">       String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">       Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">       <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，没想到这次居然用上了。<br>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。<br>eval()方法是将Lua代码交给Redis服务端执行</p><p><strong> Redis常用命令及介绍 </strong><br><strong> 字符串：</strong><br>setnx(key,value)  只在键 key 不存在的情况下， 将键 key 的值设置为 value 。key存在,不做任何操作。<br>setex(key,seconds,value)   将key设置及生存时间seconds秒,原值存在覆盖。<br>psetex(key,milliseconds,value) 与setex同样,只是单位是毫秒。<br>getset(key,value)   设置新值并返回旧值,不存在返回nil<br>setrange(key,offset,value) 从偏移量开始offset开始<br>mset 同时给多个key复制</p><p><strong> 哈希表(map)：</strong><br>hset(hash field value)  将哈希表 hash 中域 field 的值设置为 value<br>hmset key field value [field value …] 同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>hget hash field  返回哈希表中给定域的值。<br>hgetall key      返回哈希表 key 中，所有的域和值。</p><p><strong> 队列(queue):</strong><br>lpush key value [value …] 将一个或多个值 value 插入到列表 key 的表头<br>lpop key   移除并返回列表 key 的头元素,不存在返回nil<br>lset key index value  将列表 key 下标为 index 的元素的值设置为 value 。<br>brpop key [key …]  timeout 在超时时间内移除列表尾元素，阻塞的。</p><p><strong> 集合：</strong><br>sadd key member [member …]  将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略<br>sismember key member  如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。<br>spop key  移除集合key的随机元素<br>smembers key  返回集合 key 中的所有成员。<br>sdiff key [key …]  返回给定多个集合之间的差集。</p><p><strong> 有序集合：</strong><br>zadd key score member [[score member] [score member] …]   将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>zscore key member 返回有序集 key 中，成员 member 的 score 值。<br>zcount key min max   score 值在 min 和 max 之间的成员的数量。<br>zrange key start stop [withscores]  返回有序集 key 中，指定区间内的成员(从小到大)。<br>zrank key member  返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br>zrem key member [member …]   移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>时效性：<br>expire(key,seconds) 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<br>expireat( key,timestamp) 设置过期时间戳,expireatcache1355292000# 这个 key 将在 2012.12.12 过期<br>ttl(key) 返回剩余时间<br>persist key 移除key有效期，转换成永久的</p><p>数据指令：<br>keys pattern   符合给定模式的 key 列表。阻塞的<br>scan  异步的  有重复 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="redis" scheme="http://www.devcheng.net/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发的动漫商城系统源码分享</title>
    <link href="http://www.devcheng.net/post/536e3846.html"/>
    <id>http://www.devcheng.net/post/536e3846.html</id>
    <published>2020-03-15T09:24:25.000Z</published>
    <updated>2020-03-15T09:55:48.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>动漫商城项目包括商城前台系统和商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。<br>前台商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、支付流程、订单流程(微信支付/支付宝沙箱支付)、个人订单管理、会员中心、帮助中心、公告管理等模块。<br>后台管理系统包含数据面板、轮播图管理、商品管理、订单管理、会员管理、分类管理、系统设置等模块。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven 3.X</li><li>Thymeleaf</li></ul><h2 id="前台页面预览"><a href="#前台页面预览" class="headerlink" title="前台页面预览"></a><strong>前台页面预览</strong></h2><ul><li><p>动漫商城首页<br><img src="/images/动漫商城-首页.png" alt="“伊成博客”"></p></li><li><p>商品详情页面<br><img src="/images/动漫商城-商品详情.png" alt="“伊成博客”"></p></li><li><p>购物车页面<br><img src="/images/动漫商城-购物车.png" alt="“伊成博客”"></p></li><li><p>登录页面<br><img src="/images/动漫商城-登录.png" alt="“伊成博客”"></p></li></ul><h2 id="后台管理页面预览"><a href="#后台管理页面预览" class="headerlink" title="后台管理页面预览"></a><strong>后台管理页面预览</strong></h2><ul><li><p>轮播图配置<br><img src="/images/微信截图_1.png" alt="“伊成博客”"></p></li><li><p>商品管理<br><img src="/images/微信截图_2.png" alt="“伊成博客”"></p></li><li><p>会员管理<br><img src="/images/微信截图_3.png" alt="“伊成博客”"></p></li><li><p>订单管理<br><img src="/images/微信截图_4.png" alt="“伊成博客”"></p></li><li><p>公告管理<br><img src="/images/微信截图_5.png" alt="“伊成博客”"></p></li></ul><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要欢迎进群私聊我哦！<br>QQ 搜索我们的群号：816175200<br>也可以直接在博客里找到我的QQ联系我！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;动漫商城项目包括商城前台系统和商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。&lt;
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="源代码" scheme="http://www.devcheng.net/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
      <category term="动漫商城系统" scheme="http://www.devcheng.net/tags/%E5%8A%A8%E6%BC%AB%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot + MyBatis + Maven论坛内容管理系统源码</title>
    <link href="http://www.devcheng.net/post/be40dded.html"/>
    <id>http://www.devcheng.net/post/be40dded.html</id>
    <published>2020-03-02T15:24:39.000Z</published>
    <updated>2020-03-14T12:01:32.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕设描述"><a href="#毕设描述" class="headerlink" title="毕设描述"></a><strong>毕设描述</strong></h2><p>xxxForum是一个基于Spring Boot + MyBatis + Maven开发的一个论坛内容管理系统，主要实现了的功能有：</p><ul><li>前台页面展示数据、广告展示</li><li>内容模块：发帖、评论、帖子分类、分页、回帖统计、访问统计、表单验证</li><li>用户模块：权限、资料、头像、邮箱验证</li><li>管理：后台管理、统计图表、帖子/分类管理</li></ul><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>windows 7 , jdk 1.8</p><h2 id="项目采用技术"><a href="#项目采用技术" class="headerlink" title="项目采用技术"></a><strong>项目采用技术</strong></h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a><strong>后端</strong></h3><ul><li>Spring Boot 1.5.5</li><li>Spring Security 4</li><li>Mybatis(mybatis-spring-boot-starter 1.3.1)</li><li>Maven 3.X</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a><strong>前端</strong></h3><ul><li>Thymeleaf</li><li>Bootstrap</li><li>jQuery</li><li>Chart.js</li><li>bootstrap-select</li><li>daterangepicker</li></ul><h2 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a><strong>数据库文件</strong></h2><p>在项目文件里面</p><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a><strong>项目截图</strong></h2><p><img src="/images/shouye1.png" alt="“论坛内容管理系统”"></p><p><img src="/images/tiezidetail2.png" alt="“论坛内容管理系统”"></p><p><img src="/images/login3.png" alt="“论坛内容管理系统”"></p><p><img src="/images/zhuce4.png" alt="“论坛内容管理系统”"></p><p><img src="/images/table5.png" alt="“论坛内容管理系统”"></p><p><img src="/images/user6.png" alt="“论坛内容管理系统”"></p><p><img src="/images/fenlei9.png" alt="“论坛内容管理系统”"></p><p><img src="/images/run1.png" alt="“论坛内容管理系统”"></p><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>登录用户名和密码</p><p>admin / admin </p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>QQ 搜索我们的群号：816175200</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li>头像如何配置？<br>在电脑选一个盘，新建一个文件夹 例如：在C盘新建一个avatar文件夹，里面存放你的头像图片。<br>找到 application.properties 配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ==============================</span><br><span class="line"># avator location</span><br><span class="line"># ==============================</span><br><span class="line">resource.staticResourceLocation=C:/avatar/</span><br></pre></td></tr></table></figure></li></ol><p>写好配置，找到 StaticResourceConfig 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">   //这里也要和之前的对应起来</span><br><span class="line">   registry.addResourceHandler(&quot;/avatar/**&quot;).addResourceLocations(&quot;file:C:/avatar/&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据库里面和这对应就可以了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;毕设描述&quot;&gt;&lt;a href=&quot;#毕设描述&quot; class=&quot;headerlink&quot; title=&quot;毕设描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;毕设描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;xxxForum是一个基于Spring Boot + MyBatis + Maven开发的
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="论坛内容管理系统" scheme="http://www.devcheng.net/tags/%E8%AE%BA%E5%9D%9B%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java8日期和时间段的计算</title>
    <link href="http://www.devcheng.net/post/55e45d5a.html"/>
    <id>http://www.devcheng.net/post/55e45d5a.html</id>
    <published>2020-02-25T05:53:57.000Z</published>
    <updated>2020-03-29T05:42:08.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java8之前，计算日期相差多少天一般的做法都是借助SimpleDateFormat对两个日期格式化之后在进行比较。在编写代码的过程中，计算一个方法具体耗时多少分钟，执行了多少秒等需求，一般也是借助System.currentTimeMillis()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"此处消耗了："</span>+(end-start));</span><br></pre></td></tr></table></figure><p>下面看看在Java8中如何计算日期差以及时间差。</p><h2 id="Java8中计算日期差"><a href="#Java8中计算日期差" class="headerlink" title="Java8中计算日期差"></a>Java8中计算日期差</h2><p>比如日期A是1992-08-01 到 今天（2020-02-25）一共相差多少天：</p><p>代码1 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate startDate = LocalDate.of(<span class="number">1992</span>, Month.AUGUST, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"日期A : "</span> + startDate);</span><br><span class="line"></span><br><span class="line">        LocalDate endDate = LocalDate.of(<span class="number">2020</span>, Month.FEBRUARY, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"日期B : "</span> + endDate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> daysDiff = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line">        System.out.println(<span class="string">"两个日期之间的差在天数   : "</span> + daysDiff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">日期A : 1992-08-01</span><br><span class="line">日期B : 2020-02-25</span><br><span class="line">两个日期之间的差在天数   : 10069</span><br></pre></td></tr></table></figure><p>代码2 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Period period = Period.between(LocalDate.of(<span class="number">1992</span>, <span class="number">8</span>, <span class="number">1</span>), LocalDate.of(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">25</span>));</span><br><span class="line">        System.out.println(<span class="string">"两个日期之间的差   : "</span> + period.getYears()+<span class="string">"年，"</span>+period.getMonths()+<span class="string">"月，"</span>+period.getDays()+<span class="string">"天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个日期之间的差   : 27年，6月，24天</span><br></pre></td></tr></table></figure><p> <strong>ChronoUnit 类可用于在单个时间单位内测量一段时间，例如天数或秒。</strong></p><p> <strong>Period类 主要用方法getYears()，getMonths()和getDays()来计算。</strong></p><h2 id="Java8中计算时间差"><a href="#Java8中计算时间差" class="headerlink" title="Java8中计算时间差"></a>Java8中计算时间差</h2><p>列如文中说的计算某个方法运行耗时了多长，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设是业务逻辑部分代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"---"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"此处消耗了（s）: "</span> + Duration.between(start, end).getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- ...</span><br><span class="line">---99994</span><br><span class="line">---99995</span><br><span class="line">---99996</span><br><span class="line">---99997</span><br><span class="line">---99998</span><br><span class="line">---99999</span><br><span class="line">此处消耗了（s）: 1</span><br></pre></td></tr></table></figure><p><strong>Duration 类提供了使用基于时间的值（如秒，纳秒）测量时间量的方法。</strong></p><p>关于三个类更多的说明，可自行参考官方API。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a> (官方API)</p><p><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">http://www.matools.com/api/java8</a> (中文版API)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java8之前，计算日期相差多少天一般的做法都是借助SimpleDateFormat对两个日期格式化之后在进行比较。在编写代码的过程中，计
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>org.springframework.amqp.support.converter.MessageConversionExcep异常</title>
    <link href="http://www.devcheng.net/post/128dfa7.html"/>
    <id>http://www.devcheng.net/post/128dfa7.html</id>
    <published>2020-02-22T07:18:35.000Z</published>
    <updated>2020-02-22T07:20:32.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>最近，在用Spring Boot+rabbitMQ整合的过程中，测试生产者发送单条字符串消息到消费者消费这个过程没出现任何问题。</p><p>可是在实际应用中，往往在生产中不可能只生产字符串的，更多时候需要生产一个对象发送到队列，消费者从队列里面获取一个对象进行消费。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><p>先定义一个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中，可以发现定义对象的时候已经做了序列化了。</p><p>生产者代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息方法调用: 构建自定义对象消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">//id + 时间戳 全局唯一 </span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">"0987654321"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"exchange-2"</span>, <span class="string">"springboot.def"</span>, order, correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试生产者发送代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSender2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Order order = <span class="keyword">new</span> Order(<span class="string">"001"</span>, <span class="string">"第一个订单"</span>);</span><br><span class="line">     rabbitSender.sendOrder(order);</span><br><span class="line">     <span class="comment">//防止资源提前关闭，ConfirmCallback异步回调失败</span></span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RabbitListener(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.name&#125;"</span>, </span><br><span class="line">            durable=<span class="string">"$&#123;spring.rabbitmq.listener.order.queue.durable&#125;"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.name&#125;"</span>, </span><br><span class="line">            durable=<span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;"</span>, </span><br><span class="line">            type= <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.type&#125;"</span>, </span><br><span class="line">            ignoreDeclarationExceptions = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions&#125;"</span>),</span><br><span class="line">            key = <span class="string">"$&#123;spring.rabbitmq.listener.order.key&#125;"</span></span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(@Payload Order order, </span></span></span><br><span class="line"><span class="function"><span class="params">            Channel channel, </span></span></span><br><span class="line"><span class="function"><span class="params">            @Headers Map&lt;String, Object&gt; headers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------------------------------"</span>);</span><br><span class="line">        System.err.println(<span class="string">"消费端order: "</span> + order.getId());</span><br><span class="line">        Long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">        <span class="comment">//手工ACK</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当生产者有数据发送到队列的时候，消费者这端代码报了一个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Listener method could not be invoked with the incoming message</span><br><span class="line">Endpoint handler details:</span><br><span class="line">Method [public void com.rabbit.producer.RabbitProducer.receiver.OrderRecevier.onOrderMessage(com.rabbit.producer.RabbitProducer.entity.Order,com.rabbitmq.client.Channel,java.util.Map&lt;java.lang.String, java.lang.Object&gt;) throws java.lang.Exception]</span><br><span class="line">Bean [com.rabbit.producer.RabbitProducer.receiver.OrderRecevier@600b7b3d]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:185) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.onMessage(MessagingMessageListenerAdapter.java:120) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:1414) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.actualInvokeListener(AbstractMessageListenerContainer.java:1337) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:1324) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:1303) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:817) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:801) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$700(SimpleMessageListenerContainer.java:77) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1042) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at java.lang.Thread.run(Thread.java:745) [na:1.8.0_71]</span><br><span class="line">Caused by: org.springframework.messaging.converter.MessageConversionException: Cannot convert from [com.rabbit.Springboot4RabbitMQ.entity.Order] to [com.rabbit.producer.RabbitProducer.entity.Order] for GenericMessage [payload=Order [id=RabbitMQTestId0002, name=HelloWorld, messageId=1538919928275$0836e0e7-4976-457e-92fb-44b937255855], headers=&#123;amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=order.ABC, amqp_receivedExchange=order-exchange, amqp_deliveryTag=1, amqp_consumerQueue=order-queue, amqp_redelivered=false, id=0ffe4dcd-048f-f274-bca9-5550f9ecebb1, amqp_consumerTag=amq.ctag-82Oo3kl1I138E2pvVRsczA, contentType=application/x-java-serialized-object, timestamp=1538919929083&#125;]</span><br><span class="line">at org.springframework.messaging.handler.annotation.support.PayloadArgumentResolver.resolveArgument(PayloadArgumentResolver.java:144) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:116) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:137) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:109) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:51) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:182) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">... 10 common frames omitted</span><br></pre></td></tr></table></figure></p><p>从异常信息中可以看到是消费者对消息反序列化的时候失败了。虽然两个项目中的Order类是完全一样的，但在进行反序列化的时候还是失败了!</p><p>于是找了一番解决方案··</p><p><strong>第一种</strong>：<br>消费者引用生产者项目中的消息体即Order.java</p><p>在消费者项目上【右键】-&gt;【Bulid Path】-&gt;【Configure Build Path】-&gt;【Projects】-&gt;【Add】 选择生产者项目，然后消费者项目就可以引用生产者项目中类，这样完全保证了两个项目中JavaBean是一致的，所以能解决反序列失败的问题。</p><p><strong>第二种</strong>：<br>生产者在发送消息前将消息体转换为JSONObject，消费者以JSONObject接收消息，再转换为对应的实体类。</p><p>生产者的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息方法调用: 构建自定义对象消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">//id + 时间戳 全局唯一 </span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">"0987654321"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"exchange-2"</span>, <span class="string">"springboot.def"</span>, FastJsonConvertUtil.toJsonObject(order), correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.name&#125;"</span>, durable = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.durable&#125;"</span>), exchange = <span class="meta">@Exchange</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.name&#125;"</span>, durable = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;"</span>, type = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.type&#125;"</span>, ignoreDeclarationExceptions = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationeExceptions&#125;"</span>), key = <span class="string">"$&#123;spring.rabbitmq.listener.order.key&#125;"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(@Payload JSONObject object, Channel channel, @Headers Map&lt;String, Object&gt; headers)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">        Order order = JsonConvertUtils.convertJSONToObject(object);</span><br><span class="line">        System.err.println(<span class="string">"消费端Order: "</span> + order.toString());</span><br><span class="line">        Long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近，在用Spring Boot+rabbitMQ整合的过程中，测试生产者发送单条字符串消息到消费者消费这
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="rabbitMQ" scheme="http://www.devcheng.net/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot后台管理系统</title>
    <link href="http://www.devcheng.net/post/fb5a8cfd.html"/>
    <id>http://www.devcheng.net/post/fb5a8cfd.html</id>
    <published>2020-02-15T10:43:04.000Z</published>
    <updated>2020-05-17T05:25:46.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/devcheng_share_m_1.jpg" alt="“Spring-Boot后台管理系统”"></p><h3 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a><strong>叨叨叨</strong></h3><p>spring boot 后台管理系统，可以让你接触到的技术栈有以下：</p><ul><li>spring boot</li><li>shiro</li><li>druid</li><li>maven</li><li>…</li></ul><p>数据库用的是 mysql，前端使用的是 thymeleaf模板引擎。<br>开发工具：IntelliJ IDEA ，JDK 1.8</p><p>现在已经实现的功能点有：</p><ul><li>登录 / 退出</li><li>用户管理</li><li>角色管理</li><li>权限管理</li></ul><p>基本上学习用户角色权限，作为入门就足够了哦！如果有其他的想法，你可以下载这个代码根据自己的需求加上你自己的需求即可。</p><p>接着看一下项目截图：</p><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a><strong>登录页面</strong></h3><p><img src="/images/share_1.png" alt="“Spring Boot后台管理系统”"></p><h3 id="功能1"><a href="#功能1" class="headerlink" title="功能1"></a><strong>功能1</strong></h3><p><img src="/images/share_2.png" alt="“Spring Boot后台管理系统”"></p><h3 id="功能2"><a href="#功能2" class="headerlink" title="功能2"></a><strong>功能2</strong></h3><p><img src="/images/share_3.png" alt="“Spring Boot后台管理系统”"></p><h3 id="加入我们群"><a href="#加入我们群" class="headerlink" title="加入我们群"></a><strong>加入我们群</strong></h3><p>如果有需要，欢迎可以加入我们的QQ群！（QQ搜索 816175200，加入我们的QQ群吧！）<br>有任何问题，也可以加入我们的QQ群，欢迎交（che）流（dan）！</p><h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a><strong>如何获取</strong></h3><p>方式一：将本博客网址 <a href="http://www.devcheng.net">www.devcheng.net</a> 发送到任意2个技术群，截图发我即可获取源码。</p><p>方式二：通过本文打赏也可获取源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/devcheng_share_m_1.jpg&quot; alt=&quot;“Spring-Boot后台管理系统”&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;叨叨叨&quot;&gt;&lt;a href=&quot;#叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;叨叨叨&quot;&gt;&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="spring boot" scheme="http://www.devcheng.net/tags/spring-boot/"/>
    
  </entry>
  
</feed>
