<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2021-11-16T12:25:01.624Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA之UML类图学习笔记</title>
    <link href="http://www.devcheng.net/post/385bde4f.html"/>
    <id>http://www.devcheng.net/post/385bde4f.html</id>
    <published>2021-11-16T12:09:40.000Z</published>
    <updated>2021-11-16T12:25:01.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA之UML类图学习笔记"><a href="#JAVA之UML类图学习笔记" class="headerlink" title="JAVA之UML类图学习笔记"></a>JAVA之UML类图学习笔记</h2><p>学习设计模式必不可少需要了解熟悉各个模式的UML类图，为了了解每个设计模式之间各个类的关系和结构很有必要学习一下UML类图。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言，1997 年被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>统一建模语言能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。它的应用领域很宽，不仅适合于一般系统的开发，而且适合于并行与分布式系统的建模。</p><p>UML 从目标系统的不同角度出发，定义了<strong>用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图</strong>等9种图。</p><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><h4 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h4><p>指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。</p><p>在UML中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p><p>(1) 类名（Name）是一个字符串，例如，School。</p><p>(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]属性名:类型[=默认值]</span><br></pre></td></tr></table></figure><p>举个栗子： -name:String</p><p><strong>tips:</strong>  “可见性” 指的是该属性对类外的元素是否可见。</p><p>类图中表示可见性的符号如下：</p><table><thead><tr><th><strong>+</strong></th><th><strong>public</strong></th></tr></thead><tbody><tr><td><strong>-</strong></td><td><strong>private</strong></td></tr><tr><td>#</td><td><strong>protected</strong></td></tr><tr><td><strong>~</strong></td><td><strong>package</strong></td></tr></tbody></table><p><strong>(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性]名称(参数列表)[:返回类型]</span><br></pre></td></tr></table></figure><p><strong>举个栗子，类的表示参考下图：</strong></p><p><img src="/images/leitu_20211116103518.png" alt="“伊成博客”"></p><h4 id="接口-（interface）"><a href="#接口-（interface）" class="headerlink" title="接口 （interface）"></a>接口 （interface）</h4><p>接口是指对象行为的描述，一个类可有一个或多个接口。</p><p><img src="/images/leitu_20211116104822.png" alt="“伊成博客”"></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p><p><img src="/images/leitu_gx_001.jpg" alt="“伊成博客”"></p><h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p>UML 中的类图有以下几种关系：</p><p><strong>依赖关系（<em>Dependency</em>）、关联关系（Association）、聚合关系（Aggregation）、组合关系（Composition）、泛化关系（Generalization）和实现关系 (Realization)</strong>。</p><p>其中泛化和实现的耦合度相等，它们是最强的。</p><h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。图所示是人与手机的关系图，人通过手机的语音传送方法打电话。</p><p><img src="/images/leitu_gx_002.jpg" alt="“伊成博客”"></p><h5 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h5><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p><p>关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。图 5 所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。</p><p><img src="/images/leitu_gx_003.jpg" alt="“伊成博客”"></p><h5 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h5><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。图所示是大学和教师的关系图。</p><p><img src="/images/leitu_gx_004.jpg" alt="“伊成博客”"></p><h5 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h5><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。图所示是头和嘴的关系图。</p><p><img src="/images/leitu_gx_005.jpg" alt="“伊成博客”"></p><h5 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h5><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如图所示。</p><p><img src="/images/leitu_gx_006.jpg" alt="“伊成博客”"></p><h5 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h5><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图所示。</p><p><img src="/images/leitu_gx_007.jpg" alt="“伊成博客”"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>便于记忆，特此绘制一个表格记录类之间的关系。</p><table><thead><tr><th style="text-align:left">类关系</th><th>说明</th><th>代码表现</th><th>箭头及指向</th></tr></thead><tbody><tr><td style="text-align:left"><strong>依赖关系</strong></td><td>是一种使用的关系,尽量不使用双向的互相依赖</td><td>局部变量、方法的参数或者对静态方法的调用</td><td>带箭头的虚线，指向被使用者</td></tr><tr><td style="text-align:left"><strong>关联关系</strong></td><td>是一种拥有的关系,它使一个类知道另一个类的属性和方法</td><td>成员变量</td><td>带普通箭头的实心线，指向被拥有者</td></tr><tr><td style="text-align:left"><strong>聚合关系</strong></td><td>是整体与部分的关系</td><td>成员变量</td><td>带空心菱形的实心线，菱形指向整体</td></tr><tr><td style="text-align:left"><strong>组合关系</strong></td><td>是整体与部分的关系</td><td>成员变量</td><td>带实心菱形的实线，菱形指向整体</td></tr><tr><td style="text-align:left"><strong>泛化关系</strong></td><td>是一种继承关系,它指定了子类如何特化父类的所有特征和行为</td><td>——</td><td>带三角箭头的实线，箭头指向父类</td></tr><tr><td style="text-align:left"><strong>实现关系</strong></td><td>一种类与接口的关系，表示类是接口所有特征和行为的实现</td><td>——</td><td>带三角箭头的虚线，箭头指向接口</td></tr></tbody></table><p>各种关系的强弱顺序：</p><p><strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p><p>看完这些脑袋是不是嗡嗡的啊，少年，还有一个速记表格如下：</p><p><img src="/images/leitu_zj_20211116144939.png" alt="“伊成博客”"></p><p>看以上表格可快速看懂类和类之间的关系图，学会了你也可以快速绘制UML类图了，分享到此结束！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JAVA之UML类图学习笔记&quot;&gt;&lt;a href=&quot;#JAVA之UML类图学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JAVA之UML类图学习笔记&quot;&gt;&lt;/a&gt;JAVA之UML类图学习笔记&lt;/h2&gt;&lt;p&gt;学习设计模式必不可少需要了解熟悉各个模式的U
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="UML类图" scheme="http://www.devcheng.net/tags/UML%E7%B1%BB%E5%9B%BE/"/>
    
      <category term="类图" scheme="http://www.devcheng.net/tags/%E7%B1%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化命令Explain使用介绍</title>
    <link href="http://www.devcheng.net/post/506c22fa.html"/>
    <id>http://www.devcheng.net/post/506c22fa.html</id>
    <published>2021-10-20T11:42:53.000Z</published>
    <updated>2021-10-20T12:15:56.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> user_info <span class="keyword">WHERE</span>  id &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>   <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`age`</span>  <span class="built_in">INT</span>(<span class="number">11</span>)              <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_index`</span> (<span class="string">`name`</span>)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'xys'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'a'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'b'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'c'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'d'</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'e'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'f'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'g'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'h'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'i'</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>           <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span>      <span class="built_in">BIGINT</span>(<span class="number">20</span>)           <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`productor`</span>    <span class="built_in">VARCHAR</span>(<span class="number">30</span>)          <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`user_product_detail_index`</span> (<span class="string">`user_id`</span>, <span class="string">`product_name`</span>, <span class="string">`productor`</span>)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p2'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'DX'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p5'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'p3'</span>, <span class="string">'MA'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">'p8'</span>, <span class="string">'TE'</span>);</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li>key: 此次查询中确切使用到的索引.</li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line">|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p><ul><li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li><li><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. 例如:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 314</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: test.order_info.user_id</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 9</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li></ul><p>例如下面的例子就是一个范围查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         FROM user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 AND 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li></ul><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: name_index</span><br><span class="line">      key_len: 152</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 <code>Using index</code>.</p><ul><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">     filtered: 10.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="type-类型的性能比较"><a href="#type-类型的性能比较" class="headerlink" title="type 类型的性能比较"></a>type 类型的性能比较</h4><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li>字符串<ul><li>char(n): n 字节长度</li><li>varchar(n): 如果是 utf8 编码, 则是 3 <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em> n + 2 字节.</li></ul></li><li>数值类型:<ul><li>TINYINT: 1字节</li><li>SMALLINT: 2字节</li><li>MEDIUMINT: 3字节</li><li>INT: 4字节</li><li>BIGINT: 8字节</li></ul></li><li>时间类型<ul><li>DATE: 3字节</li><li>TIMESTAMP: 4字节</li><li>DATETIME: 8字节</li></ul></li><li>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</li></ul><p>我们来举两个简单的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 9</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">     filtered: 11.11</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 161</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 2</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li></ul><p>例如下面的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index; Using filesort</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>我们的索引是</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code>.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MySQL 提供了一个 EXPLAIN 命令, 它可以对 &lt;code&gt;SELECT&lt;/code&gt; 语句进行分析, 并输出 &lt;code&gt;SEL
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL优化" scheme="http://www.devcheng.net/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
      <category term="Explain" scheme="http://www.devcheng.net/tags/Explain/"/>
    
  </entry>
  
  <entry>
    <title>来一波安利手绘流程图神器，亲测好用</title>
    <link href="http://www.devcheng.net/post/70b4b9af.html"/>
    <id>http://www.devcheng.net/post/70b4b9af.html</id>
    <published>2021-10-17T08:31:24.000Z</published>
    <updated>2021-10-17T08:46:49.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前几天在gitee无意浏览其它小伙伴分享源码时，我惊奇的发现人家写的md文档里面的流程图（配图）和一般的不太一样，常规的线条都是规规矩矩，四四方方的。可能是看多了常规的流程图的原因，让我才如此惊奇，</p><p><strong>常规的图如下</strong>：</p><p><img src="https://pic2.zhimg.com/v2-46b50a7988961668d1e064db6ab30451_r.jpg" alt="preview"></p><p><strong>不一样的风格流程图如下</strong>：</p><p><img src="/images/image-20211017152014148.png" alt="“伊成博客”"></p><p>网上查询了一下，这不一样的风格流程图叫 手绘流程图。顾名思义就是类似徒手绘画出来的，继续查询了一番，终于在某乎上发现了一个不错的神器。</p><p><img src="/images/image-20211017152633838.png" alt="“伊成博客”"></p><h1 id="神器之draw-io"><a href="#神器之draw-io" class="headerlink" title="神器之draw.io"></a>神器之draw.io</h1><h2 id="draw-io-是啥玩意"><a href="#draw-io-是啥玩意" class="headerlink" title="draw.io 是啥玩意"></a>draw.io 是啥玩意</h2><p>百度了一番，才知道<em>draw.io</em> 是一款免费的在线图表编辑工具, 可以用来编辑工作流, BPM, org charts, UML, ER图, 网络拓朴图等.</p><p><img src="/images/image-20211017152910249.png" alt="“伊成博客”"></p><h1 id="如何使用draw-io-绘制手绘风格的图"><a href="#如何使用draw-io-绘制手绘风格的图" class="headerlink" title="如何使用draw.io 绘制手绘风格的图"></a>如何使用draw.io 绘制手绘风格的图</h1><p>访问draw.io 之后就可以开始画图了，但是我拖了一个椭圆出来之后发现还是常规的圆，这和我期望的不一致啊，后来一顿操作摸索下来，需要在勾选 Sketch 。</p><p>接着就可以愉快的绘制你想要的手绘风格的各种图了。</p><p><img src="/images/image-20211017153439685.png" alt="“伊成博客”"></p><p>欣赏几张我绘制的吧！</p><hr><h4 id="JDBC执行流程"><a href="#JDBC执行流程" class="headerlink" title="JDBC执行流程"></a>JDBC执行流程</h4><p><img src="/images/devcheng_net_jdbc6.png" alt="“伊成博客”"></p><hr><h4 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h4><p><img src="/images/image-20211017162547007.png" alt="“伊成博客”"></p><p>以上分享到此结束！</p><p>draw.io地址： <a href="https://app.diagrams.net/" target="_blank" rel="noopener">https://app.diagrams.net/</a></p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前几天在gitee无意浏览其它小伙伴分享源码时，我惊奇的发现人家写的md文档里面的流程图（配图）和一般的不太一样，常规的线条
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="手绘流程图" scheme="http://www.devcheng.net/tags/%E6%89%8B%E7%BB%98%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
      <category term="draw.io" scheme="http://www.devcheng.net/tags/draw-io/"/>
    
  </entry>
  
  <entry>
    <title>jenkins打包前端项目</title>
    <link href="http://www.devcheng.net/post/92a007c9.html"/>
    <id>http://www.devcheng.net/post/92a007c9.html</id>
    <published>2021-09-24T01:27:47.000Z</published>
    <updated>2021-09-24T01:37:05.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里我的 Jenkins版本是：2.303.1</p><p><img src="/images/image-20210923153840448.png" alt="“伊成博客”"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>点击 左边菜单栏中 “Manage Jenkins”  –&gt; “Manager Plugins”。</p><p><img src="/images/image-20210923153947249.png" alt="“伊成博客”"></p><p>在输入框中输入 nodeJS,搜索安装即可（我这里是已经安装过了的截图）</p><p><img src="/images/image-20210923154210082.png" alt="“伊成博客”"></p><h2 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h2><p><img src="/images/image-20210923154511889.png" alt="“伊成博客”"></p><p>选择对应的版本，点击 保存 和 应用 按钮即可。</p><p><img src="/images/image-20210923154603315.png" alt="“伊成博客”"></p><p>做到这，准备工作都已经作完了，接着就是创建一个任务。</p><h2 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h2><p>输入名称，选择一个自由风格的项目。</p><p><img src="/images/image-20210923154808081.png" alt="“伊成博客”"></p><p>配置General(我这里保持构建的最大个数写的是 10，大家可以按需配置)</p><p><img src="/images/image-20210923154921941.png" alt="“伊成博客”"></p><p>配置 源码管理，填写对应的项目gitlab地址。</p><p><img src="/images/image-20210923155040885.png" alt="“伊成博客”"></p><p>配置构建环境</p><p><img src="/images/image-20210923155138628.png" alt="“伊成博客”"></p><p>配置构建</p><p>在构建中选择执行shell</p><p><img src="/images/image-20210923155213737.png" alt="“伊成博客”"></p><p>对应的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH </span><br><span class="line">node -v  </span><br><span class="line">npm -v   </span><br><span class="line">npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>执行成功后可以看到控制台输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> DONE  Build complete. The dist directory is ready to be deployed.</span><br><span class="line"> INFO  Check out deployment instructions at https://cli.vuejs.org/guide/deployment.html</span><br><span class="line">      </span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure><p><img src="/images/image-20210923155740843.png" alt="“伊成博客”"></p><hr><p>The end …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;这里我的 Jenkins版本是：2.303.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image-2021092
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="jenkins" scheme="http://www.devcheng.net/tags/jenkins/"/>
    
      <category term="jenkins打包" scheme="http://www.devcheng.net/tags/jenkins%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>如何配置虚拟机互相免密ssh登录</title>
    <link href="http://www.devcheng.net/post/3ab16e7d.html"/>
    <id>http://www.devcheng.net/post/3ab16e7d.html</id>
    <published>2021-08-31T12:02:25.000Z</published>
    <updated>2021-08-31T12:07:27.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如何让多台虚拟机之间免密互相可登录，接下来我们实战演示一下。</p><p>实现准备2台服务器，各自的IP分别为 192.168.191.128 和 192.168.191.129 。</p><h3 id="①-查看ssh-server状态"><a href="#①-查看ssh-server状态" class="headerlink" title="① 查看ssh server状态"></a>① 查看ssh server状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@jenkins ~]# systemctl status sshd</span><br><span class="line">● sshd.service - OpenSSH server daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 二 2021-08-31 15:13:37 CST; 23min ago</span><br><span class="line">     Docs: man:sshd(8)</span><br><span class="line">           man:sshd_config(5)</span><br><span class="line"> Main PID: 1082 (sshd)</span><br><span class="line">    Tasks: 1</span><br><span class="line">   CGroup: /system.slice/sshd.service</span><br><span class="line">           └─1082 /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">8月 31 15:13:37 jenkins systemd[1]: Starting OpenSSH server daemon...</span><br><span class="line">8月 31 15:13:37 jenkins sshd[1082]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">8月 31 15:13:37 jenkins sshd[1082]: Server listening on :: port 22.</span><br><span class="line">8月 31 15:13:37 jenkins systemd[1]: Started OpenSSH server daemon.</span><br><span class="line">8月 31 15:14:48 jenkins sshd[3227]: Accepted password for root from 192.168.191.1 port 53268 ssh2</span><br><span class="line">8月 31 15:33:28 jenkins sshd[27315]: Connection closed by 192.168.191.128 port 35046 [preauth]</span><br><span class="line">8月 31 15:33:28 jenkins sshd[27382]: Connection closed by 192.168.191.128 port 35048 [preauth]</span><br></pre></td></tr></table></figure><p>由以上信息得知，这台服务器以及安装了对应ssh server 。 </p><p>如果没有安装请点击 这个连接<br><a href="https://www.cnblogs.com/liuhouhou/p/8975812.html" target="_blank" rel="noopener">安装ssh-server传送门</a></p><h3 id="②-开始配置root用户ssh免密登录"><a href="#②-开始配置root用户ssh免密登录" class="headerlink" title="② 开始配置root用户ssh免密登录"></a>② 开始配置root用户ssh免密登录</h3><p>执行 ssh-keygen -t rsa 命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@jenkins ~]# ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:mrzfLe+SUFFjuDmXsasdwX173L+j2fgqhI8jJagQ root@jenkins</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|           o+    |</span><br><span class="line">|          o. .   |</span><br><span class="line">|           + .   |</span><br><span class="line">|  E       * o    |</span><br><span class="line">|   .  .  S. *. . |</span><br><span class="line">|    .+ =. +...o =|</span><br><span class="line">|   .  O ..o+.B .*|</span><br><span class="line">|    .. . o+oo.* =|</span><br><span class="line">|   .. ... .B=o+=o|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></p><p>接着继续执行 ssh-copy-id -i ~/.ssh/id_rsa.pub <a href="mailto:root@192.168.191.128" target="_blank" rel="noopener">root@192.168.191.128</a> 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@jenkins ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.191.128</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/root/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@192.168.191.128&apos;s password: //输入对应的root密码</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &apos;root@192.168.191.128&apos;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure></p><p>看到以上提示信息，就成功了。可以使用 ssh <a href="mailto:&#39;root@192.168.191.128" target="_blank" rel="noopener">&#39;root@192.168.191.128</a>‘ 免密登录对应服务器了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@jenkins ~]# ssh &apos;root@192.168.191.128&apos;</span><br><span class="line">Last login: Tue Aug 31 15:34:01 2021 from 192.168.191.1</span><br><span class="line">[root@gitlab ~]#</span><br></pre></td></tr></table></figure><p>对应的原理再另外一台服务器也这么操作即可。</p><p>这样就实现了这2台服务器互相免密可ssh 登录了！</p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;如何让多台虚拟机之间免密互相可登录，接下来我们实战演示一下。&lt;/p&gt;
&lt;p&gt;实现准备2台服务器，各自的IP分别为 192.168.191.1
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ssh免密登陆" scheme="http://www.devcheng.net/tags/ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"/>
    
  </entry>
  
  <entry>
    <title>如何批量添加单引号(逗号)</title>
    <link href="http://www.devcheng.net/post/79b571d7.html"/>
    <id>http://www.devcheng.net/post/79b571d7.html</id>
    <published>2021-08-17T12:56:24.000Z</published>
    <updated>2021-08-17T13:01:22.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中可能会遇到这样的需求，客户（领导、同事）给你很多数据，你需要添加对应的单引号(or逗号)。数据量少的情况可以采用笨方法一个一个的处理，<br>但是数据量大的时候那怎么办呢？</p><p>借助一个神器，它就是 “Visual Studio Code”！</p><p><img src="/images/devcheng_net_vscode10001.png" alt="“伊成博客”"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><img src="/images/devcheng_net_vscode10002.png" alt="“伊成博客”"></p><p>假如客户（领导、同事）给你的是这样的一个txt文件，这个文件里面有很多数据。</p><h2 id="解决方法-vsCode方案"><a href="#解决方法-vsCode方案" class="headerlink" title="解决方法(vsCode方案)"></a>解决方法(vsCode方案)</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>这里我们借助 vsCode ,先打开 vsCode 。</p><p>接着双击编辑区，看下图：</p><p><img src="/images/devcheng_net_vscode10003.png" alt="“伊成博客”"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>把准备工作中的txt文件里面的数据复制进去。</p><p><img src="/images/devcheng_net_vscode10004.png" alt="“伊成博客”"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>鼠标放在文件最开始的地方，然后 ‘Alt + Shift’ 按住鼠标左键往下滑。然后你就可以输入你想要的符号了，例如我这里第一行我输入单引号，然后再最后一行我也输入一个单引号<br>并且加了一个逗号。</p><p>如下图：</p><p><img src="/images/devcheng_net_vscode10005.gif" alt="“伊成博客”"></p><h2 id="解决方法-notepad-方案"><a href="#解决方法-notepad-方案" class="headerlink" title="解决方法(notepad++方案)"></a>解决方法(notepad++方案)</h2><p>步骤和上述 vsCode 操作很类似，不一样的地方就是快捷键不一样了，在 notepad++ 里面 ‘Ctrl + Alt + Shift’ 按住鼠标左键往下滑。</p><p><img src="/images/devcheng_net_pad10006.gif" alt="“伊成博客”"></p><p>以上两种解决方案，任君选择。</p><p>好风凭借力，扶摇上青云。</p><p>收藏小技巧，包你事倍功半!</p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中可能会遇到这样的需求，客户（领导、同事）给你很多数据，你需要添加对应的单引号(or逗号)。数据量少的情况可以采用笨方法一个一个的处理
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="批量添加单引号" scheme="http://www.devcheng.net/tags/%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7/"/>
    
      <category term="vscode" scheme="http://www.devcheng.net/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>Springboot2.x整合p6spy</title>
    <link href="http://www.devcheng.net/post/b5cbfcc0.html"/>
    <id>http://www.devcheng.net/post/b5cbfcc0.html</id>
    <published>2021-08-06T05:27:03.000Z</published>
    <updated>2021-08-17T12:57:04.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍p6spy"><a href="#介绍p6spy" class="headerlink" title="介绍p6spy"></a>介绍p6spy</h2><p>P6Spy 是针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。</p><p>P6Spy 分发包包括P6Log，它是一个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。</p><p><code>P6Spy是一个开源项目，项目首页 www.p6spy.com [项目首页网站不可访问了！]</code></p><h2 id="为何选择p6spy"><a href="#为何选择p6spy" class="headerlink" title="为何选择p6spy"></a>为何选择p6spy</h2><p>在很多项目中我们都会用mybatis打印必要的sql语句，但是对应的参数都是用 ？ 展示。而开发过程中如果我需要看完整的一条sql语句和具体参数值这就需要p6spy了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Preparing: select order_id, order_code, org_remark, add_payment, activity_id, evaluate_score FROM tc_order WHERE 1=1 and category =? and order_status = ? and start_date &lt;=? and third_order_id = ? </span><br><span class="line">2017-06-07 14:30:02,679 [executor-1] DEBUG com.xx.xx.dop2c.order.ext.TcOrderExtDao.queryForQueue - 47 - ==&gt; Parameters: 253(Long), 30(Integer), 2017-06-07 14:30:02(String), 0(String)</span><br></pre></td></tr></table></figure><p>使用p6spy打印的sql如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-08-05 10:05:53.217 INFO 1064 --- [ main] p6spy : 2021-08-05 10:05:53|0|statement|connection 0|url </span><br><span class="line">jdbc:p6spy:h2:./data/test|insert into goods (name, price, create_time, update_time) values (&apos;bottole&apos;, 2500, now(), now())|insert into goods (name, price, create_time, update_time) values (&apos;bottole&apos;, 2500, now(), now())</span><br></pre></td></tr></table></figure><h2 id="Springboot2整合p6spy"><a href="#Springboot2整合p6spy" class="headerlink" title="Springboot2整合p6spy"></a>Springboot2整合p6spy</h2><p>spring boot 版本：2.4.3</p><p>1.添加对应依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;p6spy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;p6spy&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>2.修改数据库连接URL中加入p6spy</p><p><img src="/images/springboot_p6spy_0806001.png" alt="“伊成博客”"></p><p>3.配置spy.properties<br>将spy.properties复制到项目的resources文件夹中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#3.2.1以上使用</span><br><span class="line">modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line">#modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory</span><br><span class="line">#3.2.1以下使用或者不配置</span><br><span class="line">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="line">#日志输出到控制台</span><br><span class="line">appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="line"># 使用日志系统记录 sql</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line"># 设置 p6spy driver 代理</span><br><span class="line">deregisterdrivers=true</span><br><span class="line"># 取消JDBC URL前缀</span><br><span class="line">useprefix=true</span><br><span class="line"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="line">excludecategories=info,debug,result,commit,resultset</span><br><span class="line"># 日期格式</span><br><span class="line">dateformat=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 实际驱动可多个</span><br><span class="line">#driverlist=org.h2.Driver</span><br><span class="line"># 是否开启慢SQL记录</span><br><span class="line">outagedetection=true</span><br><span class="line"># 慢SQL记录标准 2 秒</span><br><span class="line">outagedetectioninterval=2</span><br></pre></td></tr></table></figure><p>这样就大功告成了，我们在运行项目的时候就可以在控制台中看到具体的sql语句了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consume Time：0 ms 2021-08-05 11:16:24</span><br><span class="line">Execute SQL：SELECT * FROM tb_data_info WHERE datasource_id = 74</span><br></pre></td></tr></table></figure><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍p6spy&quot;&gt;&lt;a href=&quot;#介绍p6spy&quot; class=&quot;headerlink&quot; title=&quot;介绍p6spy&quot;&gt;&lt;/a&gt;介绍p6spy&lt;/h2&gt;&lt;p&gt;P6Spy 是针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="springboot2" scheme="http://www.devcheng.net/tags/springboot2/"/>
    
      <category term="p6spy" scheme="http://www.devcheng.net/tags/p6spy/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序使用async提示regeneratorRuntime is not defined异常</title>
    <link href="http://www.devcheng.net/post/12b3c63e.html"/>
    <id>http://www.devcheng.net/post/12b3c63e.html</id>
    <published>2021-07-07T14:31:14.000Z</published>
    <updated>2021-07-07T14:34:49.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>微信小程序使用async提示regeneratorRuntime is not defined异常。</p><p><img src="/images/wxmini1.png" alt="“伊成博客”"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>新版本的小程序支持async / await。勾选下面选项后重新编译程序即可</p><p>点击 ‘详情’ – ‘本地设置’ – 勾选 ‘ES6转ES5’ 和 ‘增强编译’，然后重新编译即可。</p><p><img src="/images/wxmini2.png" alt="“伊成博客”"></p><p>完美解决问题！</p><p>更新时间：2021-7-7</p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;微信小程序使用async提示regeneratorRuntime is not defined异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="微信小程序" scheme="http://www.devcheng.net/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="regeneratorRuntime is not defined" scheme="http://www.devcheng.net/tags/regeneratorRuntime-is-not-defined/"/>
    
  </entry>
  
  <entry>
    <title>springBoot启动提示If you want an embedded database (H2, HSQL or Derby), please put</title>
    <link href="http://www.devcheng.net/post/7dd074b3.html"/>
    <id>http://www.devcheng.net/post/7dd074b3.html</id>
    <published>2021-05-26T11:47:56.000Z</published>
    <updated>2021-05-26T12:01:44.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), please put it on the classpath</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>对于这个异常的解决方案，网上绝大部分都是说：在启动的类中的@SpringBootApplication 改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)//排除自动配置</span><br><span class="line">public class ErukaServerMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ErukaServerMain.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样改没有解决实际的问题。</p><p>产生这个错误的原因是Spring Boot的自动配置，如果你没有配置DataSource就会导致下图这个错误。</p><p>那如果你很确定，比如你就是要Spring Boot + Mybatis + MySQL 整合的代码，此时就应该去检查你的配置文件中是否正确配置了数据库连接。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>下面我们举个栗子复现这个问题，这里我使用Spring Boot + JPA + MySQL整合一个demo。</p><p>在数据库链接配置文件中，我们故意写错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.mysql.jdbc-url=jdbc:mysql://127.0.0.1:3306/beauty_atlas_server?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true</span><br><span class="line">spring.datasource.mysql.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.mysql.username=root</span><br><span class="line">spring.datasource.mysql.password=root</span><br></pre></td></tr></table></figure></p><p>tips: Spring Boot + JPA 配置连接数据库 可不是用 spring.datasource.mysql.jdbc-url 这个哦，以上的这块配置都是错的，这个时候你启动就会提示</p><p><img src="/images/devcheng_net_zhengheyichang.png" alt="“论坛内容管理系统”"></p><p>那正确的解决方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 数据库配置 spring boot + jpa 数据库配置前缀是下面这样的</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/beauty_atlas_server?characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure><p>由上可见，Spirng Boot 和不同的持久层整合这些配置都是有所区别的，在整合的过程中一定要慎重。<br>Spring Boot + JPA + MySQL 整合中还得配置DataSource，把它注入到Spring中接口，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix=&quot;spring.datasource&quot;)</span><br><span class="line">public class DbConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource getDataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUrl() &#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUrl(String url) &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新启动，项目无问题了。</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;p&gt;Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), 
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="异常" scheme="http://www.devcheng.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="SpringBoot" scheme="http://www.devcheng.net/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL关键字大全</title>
    <link href="http://www.devcheng.net/post/7024f457.html"/>
    <id>http://www.devcheng.net/post/7024f457.html</id>
    <published>2021-05-25T12:29:23.000Z</published>
    <updated>2021-05-25T12:45:48.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在创建表的时候一定使用到MYSQL的关键字，前几天我同事在对接别人的接口中就遇到了这个问题，别人的接口中返回了一个 ‘desc’,他毫不犹豫地创建表的时候也用了’desc’。</p><p>结果死活保存不了这条数据。后面排查代码才发现使用了MYSQL的关键子了。</p><p>以下都是整理出来所有的MySQL关键字，为了避免踩坑，建议收藏！！！</p><h2 id="MySQL关键字"><a href="#MySQL关键字" class="headerlink" title="MySQL关键字"></a>MySQL关键字</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>ADD</td><td>ALL</td><td>ALTER</td></tr><tr><td>ANALYZE</td><td>AND</td><td>AS</td></tr><tr><td>ASC</td><td>ASENSITIVE</td><td>BEFORE</td></tr><tr><td>BETWEEN</td><td>BIGINT</td><td>BINARY</td></tr><tr><td>BLOB</td><td>BOTH</td><td>BY</td></tr><tr><td>CALL</td><td>CASCADE</td><td>CASE</td></tr><tr><td>CHANGE</td><td>CHAR</td><td>CHARACTER</td></tr><tr><td>CHECK</td><td>COLLATE</td><td>COLUMN</td></tr><tr><td>CONDITION</td><td>CONNECTION</td><td>CONSTRAINT</td></tr><tr><td>CONTINUE</td><td>CONVERT</td><td>CREATE</td></tr><tr><td>CROSS</td><td>CURRENT_DATE</td><td>CURRENT_TIME</td></tr><tr><td>CURRENT_TIMESTAMP</td><td>CURRENT_USER</td><td>CURSOR</td></tr><tr><td>DATABASE</td><td>DATABASES</td><td>DAY_HOUR</td></tr><tr><td>DAY_MICROSECOND</td><td>DAY_MINUTE</td><td>DAY_SECOND</td></tr><tr><td>DEC</td><td>DECIMAL</td><td>DECLARE</td></tr><tr><td>DEFAULT</td><td>DELAYED</td><td>DELETE</td></tr><tr><td>DESC</td><td>DESCRIBE</td><td>DETERMINISTIC</td></tr><tr><td>DISTINCT</td><td>DISTINCTROW</td><td>DIV</td></tr><tr><td>DOUBLE</td><td>DROP</td><td>DUAL</td></tr><tr><td>EACH</td><td>ELSE</td><td>ELSEIF</td></tr><tr><td>ENCLOSED</td><td>ESCAPED</td><td>EXISTS</td></tr><tr><td>EXIT</td><td>EXPLAIN</td><td>FALSE</td></tr><tr><td>FETCH</td><td>FLOAT</td><td>FLOAT4</td></tr><tr><td>FLOAT8</td><td>FOR</td><td>FORCE</td></tr><tr><td>FOREIGN</td><td>FROM</td><td>FULLTEXT</td></tr><tr><td>GOTO</td><td>GRANT</td><td>GROUP</td></tr><tr><td>HAVING</td><td>HIGH_PRIORITY</td><td>HOUR_MICROSECOND</td></tr><tr><td>HOUR_MINUTE</td><td>HOUR_SECOND</td><td>IF</td></tr><tr><td>IGNORE</td><td>IN</td><td>INDEX</td></tr><tr><td>INFILE</td><td>INNER</td><td>INOUT</td></tr><tr><td>INSENSITIVE</td><td>INSERT</td><td>INT</td></tr><tr><td>INT1</td><td>INT2</td><td>INT3</td></tr><tr><td>INT4</td><td>INT8</td><td>INTEGER</td></tr><tr><td>INTERVAL</td><td>INTO</td><td>IS</td></tr><tr><td>ITERATE</td><td>JOIN</td><td>KEY</td></tr><tr><td>KEYS</td><td>KILL</td><td>LABEL</td></tr><tr><td>LEADING</td><td>LEAVE</td><td>LEFT</td></tr><tr><td>LIKE</td><td>LIMIT</td><td>LINEAR</td></tr><tr><td>LINES</td><td>LOAD</td><td>LOCALTIME</td></tr><tr><td>LOCALTIMESTAMP</td><td>LOCK</td><td>LONG</td></tr><tr><td>LONGBLOB</td><td>LONGTEXT</td><td>LOOP</td></tr><tr><td>LOW_PRIORITY</td><td>MATCH</td><td>MEDIUMBLOB</td></tr><tr><td>MEDIUMINT</td><td>MEDIUMTEXT</td><td>MIDDLEINT</td></tr><tr><td>MINUTE_MICROSECOND</td><td>MINUTE_SECOND</td><td>MOD</td></tr><tr><td>MODIFIES</td><td>NATURAL</td><td>NOT</td></tr><tr><td>NO_WRITE_TO_BINLOG</td><td>NULL</td><td>NUMERIC</td></tr><tr><td>ON</td><td>OPTIMIZE</td><td>OPTION</td></tr><tr><td>OPTIONALLY</td><td>OR</td><td>ORDER</td></tr><tr><td>OUT</td><td>OUTER</td><td>OUTFILE</td></tr><tr><td>PRECISION</td><td>PRIMARY</td><td>PROCEDURE</td></tr><tr><td>PURGE</td><td>RAID0</td><td>RANGE</td></tr><tr><td>READ</td><td>READS</td><td>REAL</td></tr><tr><td>REFERENCES</td><td>REGEXP</td><td>RELEASE</td></tr><tr><td>RENAME</td><td>REPEAT</td><td>REPLACE</td></tr><tr><td>REQUIRE</td><td>RESTRICT</td><td>RETURN</td></tr><tr><td>REVOKE</td><td>RIGHT</td><td>RLIKE</td></tr><tr><td>SCHEMA</td><td>SCHEMAS</td><td>SECOND_MICROSECOND</td></tr><tr><td>SELECT</td><td>SENSITIVE</td><td>SEPARATOR</td></tr><tr><td>SET</td><td>SHOW</td><td>SMALLINT</td></tr><tr><td>SPATIAL</td><td>SPECIFIC</td><td>SQL</td></tr><tr><td>SQLEXCEPTION</td><td>SQLSTATE</td><td>SQLWARNING</td></tr><tr><td>SQL_BIG_RESULT</td><td>SQL_CALC_FOUND_ROWS</td><td>SQL_SMALL_RESULT</td></tr><tr><td>SSL</td><td>STARTING</td><td>STRAIGHT_JOIN</td></tr><tr><td>TABLE</td><td>TERMINATED</td><td>THEN</td></tr><tr><td>TINYBLOB</td><td>TINYINT</td><td>TINYTEXT</td></tr><tr><td>TO</td><td>TRAILING</td><td>TRIGGER</td></tr><tr><td>TRUE</td><td>UNDO</td><td>UNION</td></tr><tr><td>UNIQUE</td><td>UNLOCK</td><td>UNSIGNED</td></tr><tr><td>UPDATE</td><td>USAGE</td><td>USE</td></tr><tr><td>USING</td><td>UTC_DATE</td><td>UTC_TIME</td></tr><tr><td>UTC_TIMESTAMP</td><td>VALUES</td><td>VARBINARY</td></tr><tr><td>VARCHAR</td><td>VARCHARACTER</td><td>VARYING</td></tr><tr><td>WHEN</td><td>WHERE</td><td>WHILE</td></tr><tr><td>WITH</td><td>WRITE</td><td>X509</td></tr><tr><td>XOR</td><td>YEAR_MONTH</td><td>ZEROFILL</td></tr></tbody></table><hr><p>记录一下备忘~</p><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在创建表的时候一定使用到MYSQL的关键字，前几天我同事在对接别人的接口中就遇到了这个问题，别人的接口中返回了一个 ‘des
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="mysql关键字" scheme="http://www.devcheng.net/tags/mysql%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="mysql" scheme="http://www.devcheng.net/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>启动nginx提示Job for nginx.service failed because the control process exited with error code</title>
    <link href="http://www.devcheng.net/post/ceba3d83.html"/>
    <id>http://www.devcheng.net/post/ceba3d83.html</id>
    <published>2021-04-20T12:51:40.000Z</published>
    <updated>2021-04-20T13:03:55.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>启动nginx的时候，提示异常信息如下：</p><p>Job for nginx.service failed because the control process exited with error code.</p><p><img src="/images/devcheng_net_nginx0001.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_nginx0002.png" alt="“伊成博客”"></p><p>查看状态信息,提示配置文件出错: </p><p>“server” directive is not allowed here in /etc/nginx/nginx.conf:39</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>发现端口被占用，centos中查看端口被占用命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp | grep 端口号</span><br></pre></td></tr></table></figure><p>杀掉进程： <strong>ps -9 进程号</strong></p><p>杀掉所有80端口的进程：<strong>lsof -i :80|grep -v “PID”|awk ‘{print “kill -9”,$2}’|sh</strong></p><hr><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;启动nginx的时候，提示异常信息如下：&lt;/p&gt;
&lt;p&gt;Job for nginx.service failed becau
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="nginx" scheme="http://www.devcheng.net/tags/nginx/"/>
    
      <category term="nginx.service failed" scheme="http://www.devcheng.net/tags/nginx-service-failed/"/>
    
  </entry>
  
  <entry>
    <title>离职的时候不能说的十句话</title>
    <link href="http://www.devcheng.net/post/462294b4.html"/>
    <id>http://www.devcheng.net/post/462294b4.html</id>
    <published>2021-04-12T13:36:46.000Z</published>
    <updated>2021-04-12T13:44:49.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>又是一年一季的跳槽季，也不知道此刻的你是不是正打算离职了，如果打算离职那你应该好好看看这篇文章。</p><h2 id="10点不能说的"><a href="#10点不能说的" class="headerlink" title="10点不能说的"></a>10点不能说的</h2><h3 id="1：老板很挫"><a href="#1：老板很挫" class="headerlink" title="1：老板很挫"></a>1：老板很挫</h3><p>任何将你的离职与老板的性格或性情联系起来的评论都是无济于事的。<br>他们可能是个食人魔，但如果传回你这么说的消息，他们在与未来的雇主交谈时，更有可能贬低你的态度或表现。</p><h3 id="2：上级领导很挫"><a href="#2：上级领导很挫" class="headerlink" title="2：上级领导很挫"></a>2：上级领导很挫</h3><p>不要说你要离开是因为你的老板不称职，即使这是真的。你的经理会更容易将任何失败归咎于你，并对你的工作做出负面评价。</p><h3 id="3：你在的团队成员有问题"><a href="#3：你在的团队成员有问题" class="headerlink" title="3：你在的团队成员有问题"></a>3：你在的团队成员有问题</h3><p>不要把团队成员的表现或不良态度作为你离职的理由。雇主在调查你的背景时，往往会征求员工以及主管的意见。如果以前的下属或同事因为你的离职言论而受到侮辱，那么他们会更容易提到你作为经理或队友的缺点。</p><h3 id="4：你的能力应该拿更多的收入"><a href="#4：你的能力应该拿更多的收入" class="headerlink" title="4：你的能力应该拿更多的收入"></a>4：你的能力应该拿更多的收入</h3><p>没有必要鼓励管理层将你视为不满的员工，因为这种定性可能会传递给其他询问你在组织的任期的人。</p><h3 id="5：公司的状况很糟糕"><a href="#5：公司的状况很糟糕" class="headerlink" title="5：公司的状况很糟糕"></a>5：公司的状况很糟糕</h3><p>如果你认为公司在某些方面陷入困境或成绩不佳，不要说出来。你的雇主会知道他们组织内部的任何问题。你向管理层传达他们被困在一个糟糕的组织中，而你却在向更好的事情发展，这对你没有任何好处。</p><h3 id="6：公司的产品很糟糕"><a href="#6：公司的产品很糟糕" class="headerlink" title="6：公司的产品很糟糕"></a>6：公司的产品很糟糕</h3><p>不忠诚的员工通常是不受欢迎的。前主管更可能会断言，你成功的任何限制都是由于你的不足，而不是他们产品或服务的缺陷。未来的雇主会怀疑，当你继续前进时，你是否会说他们的坏话。</p><h3 id="7：你没有被给到足够的通知"><a href="#7：你没有被给到足够的通知" class="headerlink" title="7：你没有被给到足够的通知"></a>7：你没有被给到足够的通知</h3><p>突然离职可以用来证明你不是一个敬业或专业的员工的指控。在某些情况下，可以不经通知就辞职，但在大多数情况下，通常是提前两周通知。</p><h3 id="8：你不愿意顺利的交接工作"><a href="#8：你不愿意顺利的交接工作" class="headerlink" title="8：你不愿意顺利的交接工作"></a>8：你不愿意顺利的交接工作</h3><p>这是一个很好的主意，证明你是一个有责任感的员工，直到你的工作结束。为老板缓解过渡期的合作会被记住，并经常得到积极的推荐奖励。</p><h3 id="9：新的工作机会实在是太6了"><a href="#9：新的工作机会实在是太6了" class="headerlink" title="9：新的工作机会实在是太6了"></a>9：新的工作机会实在是太6了</h3><p>不要向其他员工吹嘘你的新工作，因为这可能会引起他们的不满，特别是如果你暗示你比他们更好。感谢他人的支持，并提及你将如何想念与他们一起工作。</p><h3 id="10：你对前公司有意见，而且还要写在邮件里"><a href="#10：你对前公司有意见，而且还要写在邮件里" class="headerlink" title="10：你对前公司有意见，而且还要写在邮件里"></a>10：你对前公司有意见，而且还要写在邮件里</h3><p>不要把任何负面的东西写进去。保持你的辞职信是积极的，这样所有相关人员都会记住你是一个积极的人。学习如何写一封礼貌地说明你要离开的辞职信。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>保持积极的态度。<br>现在不是贬低你的老板，队友，或者即将到来的前雇主的时候。</p><p>以正确的方式辞职。<br>提供至少两周的书面通知 并感谢公司提供的机会。</p><p>从长计议。<br>记住，大多数行业都比他们看起来要小。当你离开时要专业一点，以后你就可以要求推荐人推荐你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;又是一年一季的跳槽季，也不知道此刻的你是不是正打算离职了，如果打算离职那你应该好好看看这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1
      
    
    </summary>
    
      <category term="codelife" scheme="http://www.devcheng.net/categories/codelife/"/>
    
    
      <category term="职场" scheme="http://www.devcheng.net/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="离职" scheme="http://www.devcheng.net/tags/%E7%A6%BB%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？</title>
    <link href="http://www.devcheng.net/post/d7b63f4f.html"/>
    <id>http://www.devcheng.net/post/d7b63f4f.html</id>
    <published>2021-04-10T01:43:25.000Z</published>
    <updated>2021-04-10T01:52:41.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你在工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>后台有个老铁就跟我说了这么一件事。</p><p>他是产品经理，上周刚加班搞定一个老板很重视的需求，熬了几个夜终于上线了。</p><p>这周陆续收到用户反馈，说其中一个功能的历史数据没有了，各种投诉就直接过来了。</p><p>在后台一查，原来是新版本完全覆盖了老版本的数据，没有做数据上新老版本兼容，导致更新了新版本的用户看不到之前的老数据。且后台上线后，老版本的用户也看不到之前的数据了。</p><p>这个问题最先被反馈到产品经理这，产品去问测试，测试说已经都测过没问题才发包的。产品去问研发，研发说新版代码里已经做了数据兼容的调整。</p><p>没办法，让研发老大带着下面的人去检查线上代码，发现提交上去的代码中果然没有完成数据兼容。可去发布前的测试代码中一看，这部分代码却存在。</p><p>原来，最后提交代码的程序员没有把这部分代码合并到主分支里面去。</p><p>因为表现层的功能测试都没问题了，且数据代码也写好了，所有人都以为万事俱备，没想到被一个代码提交给搞砸了。</p><p>幸亏数据有备份，经过恢复处理后这才回归了正常。</p><p>原本大家等着靠这个项目拿个季度奖，没想到被队友给坑了，而且是一个本该完全避免的失误。</p><p>所以，产品测试完没问题真不是最后一步。在有条件的团队，一定要做灰度上线，把出问题的概率控制在最低。</p><p>据我了解，微信团队每次更新产品都是逐步灰度放量，一旦遇到问题就立马回滚，非常灵活。</p><p>这些都属于产品技术的基本功，在快速跑需求的同时，也得时刻降低技术负债，多给自己留一些后路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;如果你在工作中碰上那些给你挖坑或者带你踩坑的猪队友，你会怎么办？&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot;
      
    
    </summary>
    
      <category term="codelife" scheme="http://www.devcheng.net/categories/codelife/"/>
    
    
      <category term="职场" scheme="http://www.devcheng.net/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="猪队友" scheme="http://www.devcheng.net/tags/%E7%8C%AA%E9%98%9F%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列 03</title>
    <link href="http://www.devcheng.net/post/bb6a7fde.html"/>
    <id>http://www.devcheng.net/post/bb6a7fde.html</id>
    <published>2021-03-15T13:33:32.000Z</published>
    <updated>2021-03-16T12:52:46.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>结合前面两篇博文，这篇博文进行一次实战案例，用于介绍如何使用Ckettle做数据集成。</p><p><strong>实战需求</strong>：<br>某公司新人试用期为3个月，现在需要对职称为P3的为转正的员工实施转正考核，需要从现有的一张员工信息表格中提取并筛选未转正的员工数据，然后转存到考核系统的数据库中，每个月的1号执行一次。</p><p><strong>技术需求</strong></p><ul><li>源数据：Excel   目标数据：MySql</li></ul><p><img src="/images/ETL_20210315093800.png" alt="“伊成博客”"></p><p><strong>业务分析</strong></p><ul><li>试用期：3个月    职称：P3    转正状态:未转正</li></ul><p><strong>技术概要分析</strong></p><p>识别源和目标数据库，数据存储表</p><p><strong>操作概要分析</strong></p><ul><li>数据处理类型：定时调用</li><li>调度频率：每个一次</li></ul><p><img src="/images/ETL_20210315101321.png" alt="“伊成博客”"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><strong>操作步骤</strong></h2><h3 id="数据抽取"><a href="#数据抽取" class="headerlink" title="数据抽取"></a><strong>数据抽取</strong></h3><p>1.找到CKettle安装完成目录中的 ‘Spoon.bat’ 双击打开即可。</p><p>2.点击 ‘新建’，选择 ‘转换’ 选项。</p><p><img src="/images/ETL_20210315101939.png" alt="“伊成博客”"></p><p>3.点击 ‘输入’插件中，拖拽 ‘Excel输入’ 插件到右边。</p><p><img src="/images/ETL_20210315102217.png" alt="“伊成博客”"></p><p>4.选择存于你本地的excel文件，点击 ‘添加’按钮。</p><p><img src="/images/ETL_20210315102608.png" alt="“伊成博客”"></p><p>5.切换到 ‘工作表’选项，点击 ‘获选工作表名称’选择数据对应的sheet，完成后点击确定按钮。</p><p><img src="/images/ETL_20210315103026.png" alt="“伊成博客”"></p><p>6.继续切换到 ‘字段’选项，点击 ‘选择来自头部数据的字段’，如无需修改各个字段的类型点击确定按钮。</p><p><img src="/images/ETL_20210315103130.png" alt="“伊成博客”"></p><p>tips:到此第一步的数据抽取的工作就完成了。</p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a><strong>数据转换</strong></h3><p>1.接着需要筛选出职称为P3的员工，需要’过滤记录’插件。</p><p><img src="/images/ETL_20210315103509.png" alt="“伊成博客”"></p><p>2.按住shift键把两个插件用数据线连接在一块，然后进行数据过来的配置。</p><p><img src="/images/ETL_20210315103725.png" alt="“伊成博客”"></p><p>3.接着筛选出未转正的数据，在步骤2中同理操作一次即可。</p><p><img src="/images/ETL_20210315104250.png" alt="“伊成博客”"></p><p>tips：做好以上的步骤，我们可以试着点击’运行’按钮，查看一下流程是否有问题，如果配置都没问题的情况下我们可以查看到数据过滤后的结果。</p><p><img src="/images/ETL_20210315111418.png" alt="“伊成博客”"></p><p>4.添加一个常量用于比较出是否已经满了入职三个月的需求，这里需要一个 ‘增加常量’插件。</p><p><img src="/images/ETL_20210315204407.png" alt="“伊成博客”"></p><p>5.添加一个’计算器’ 插件，把入职时间加上刚刚设置的常量得到一个应该转正日期。</p><p><img src="/images/ETL_20210315204920.png" alt="“伊成博客”"></p><p>6.添加一个 ‘获取系统信息’ 插件，选择系统时间固定值。</p><p><img src="/images/ETL_20210315205318.png" alt="“伊成博客”"></p><p>7.由以上步骤，可以用当前时间和应该转正日期做比较从而筛选出符合条件的数据。</p><p><img src="/images/ETL_20210315205627.png" alt="“伊成博客”"></p><p>做到这一步，点击运行查看一下被筛选后的数据。</p><p><img src="/images/ETL_20210315205917.png" alt="“伊成博客”"></p><p>8.由上一步得知有重复数据，需要借助 ‘去除重复记录’ 插件。</p><p><img src="/images/ETL_20210315210420.png" alt="“伊成博客”"></p><h3 id="数据转载"><a href="#数据转载" class="headerlink" title="数据转载"></a><strong>数据转载</strong></h3><p>1.添加 ‘插入/更新’ 插件，配置数据库连接信息。</p><p><img src="/images/ETL_20210315210849.png" alt="“伊成博客”"></p><p>设置好用来查询的关键字字段，这一步是用来当成数据查询的条件。<br>更新字段这一项是获取数据之后需要更新哪一些字段。</p><p><img src="/images/ETL_20210315211529.png" alt="“伊成博客”"></p><p>配置完成之后可以点击运行按钮，接着查看数据库对应的表是否存放了符合条件的数据。</p><p><img src="/images/ETL_20210315211802.png" alt="“伊成博客”"></p><p>数据成功存入到对应数据库表中，到此数据抽取，转换，装载都完成了。<br>但每个月1号需要执行一次这个涉及到定时调度，我们后续再出对应博文讲解！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a><strong>其它说明</strong></h2><p><a href="http://www.devcheng.net/post/53978f67.html">《ETL入门系列01》</a></p><p><a href="http://www.devcheng.net/post/cc6d4f48.html">《ETL入门系列02》</a></p><p><a href="http://www.devcheng.net/post/bb6a7fde.html">《ETL入门系列03》</a></p><p>ETL入门系列到此结束！</p><p>本案例中涉及的execl文档和ktr文件有需要的可以加QQ群：816175200<br>备注: ckettle</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;结合前面两篇博文，这篇博文进行一次实战案例，用于介绍如何使用Ckettle做数据集成。&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
      <category term="实战案例" scheme="http://www.devcheng.net/tags/%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列 02</title>
    <link href="http://www.devcheng.net/post/cc6d4f48.html"/>
    <id>http://www.devcheng.net/post/cc6d4f48.html</id>
    <published>2021-02-24T13:44:07.000Z</published>
    <updated>2021-02-24T13:48:31.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>上一篇我们提到了有几款开源的ETL工具，接下来将学习CKettle。CKettle源于Kettle，在CKettle官网自我介绍中是这样描述自己的 “源于开源，强于开源”。主要提供专职、专业的技术支持和帮助，快速响应国内用户，他们致力于打造专业的ETL技术交流社区。</p><h2 id="下载CKettle"><a href="#下载CKettle" class="headerlink" title="下载CKettle"></a><strong>下载CKettle</strong></h2><p>下载地址： <a href="https://ckettle.ccsaii.com.cn/" target="_blank" rel="noopener">https://ckettle.ccsaii.com.cn/</a></p><p><img src="/images/ETL_202102241.png" alt="“伊成博客”"></p><p>下载稳定版即可！</p><p><strong>必要准备</strong><br>CKettle是基于Java开发的，所以确保你本地电脑配置了Java环境变量。</p><p>下载得到一个zip压缩包，解压缩出来之后，结构目录如下：</p><p><img src="/images/ETL_202102242.png" alt="“伊成博客”"></p><p>windows下双击 Spoon.bat 启动。</p><p><img src="/images/ETL_202102243.png" alt="“伊成博客”"></p><p>在结构目录中我们经常使用到的有： Spoon.bat , Kitchen.bat , Pan.bat , Carte.bat</p><p>下面分别介绍</p><h3 id="Spoon-设计器"><a href="#Spoon-设计器" class="headerlink" title="Spoon(设计器)"></a><strong>Spoon(设计器)</strong></h3><p>提供了一个图形用户界面，用户创建(编辑)作业或转换；也可以用户执行(调试)作业或转换，它还提供了性能监控的功能。</p><h3 id="Kitchen"><a href="#Kitchen" class="headerlink" title="Kitchen"></a><strong>Kitchen</strong></h3><p>用于作业的命令行运行，可以通过Shell脚本来调用，常用于Linux环境中。</p><h3 id="Pan"><a href="#Pan" class="headerlink" title="Pan"></a><strong>Pan</strong></h3><p>用户转换的命令行运行，和Kitchen一样可以通过Shell脚本来调用。</p><h3 id="Carte"><a href="#Carte" class="headerlink" title="Carte"></a><strong>Carte</strong></h3><p>是一个轻量级的HTTP服务器，后台运行，监听HTTP请求来运行一个作业或转换,也可以用于分布式执行作业或转换，也就是CKettle的集群。</p><p>关于以上几个命令如何使用，后续我们结合例子再做详细说明。</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;上一篇我们提到了有几款开源的ETL工具，接下来将学习CKettle。CKettle源于Kettle，在CK
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="ELT" scheme="http://www.devcheng.net/tags/ELT/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>ETL入门系列01</title>
    <link href="http://www.devcheng.net/post/53978f67.html"/>
    <id>http://www.devcheng.net/post/53978f67.html</id>
    <published>2021-02-21T07:12:47.000Z</published>
    <updated>2021-02-21T07:31:31.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>DT时代，把数据转换为信息、知识，已成为企业提高核心竞争力的关键。目前，大多数企业和政府采用传统的数据库脚本方式来处理数据，但是脚本方式可读性差，过分依赖人，无论是程序的迁移还是系统维护，都极为不便，而ETL则成为主要的一个技术手段。</p><h3 id="什么是ETL"><a href="#什么是ETL" class="headerlink" title="什么是ETL"></a><strong>什么是ETL</strong></h3><p>字面含义：ETL（Extact-Transform-Load，数据的抽取、转换、加载）是抽取、转换、加载的缩写。</p><p>简单定义：把数据从OLTP系统中转移到数据仓库中的一系列操作的集合。</p><h4 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a><strong>抽取</strong></h4><p> 一般抽取过程需要连接到不同的数据源，以便为随后的步骤提供数据。这一部分看上去简单而琐碎，实际上它是ETL解决方案成功实施的一个主要障碍。</p><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a><strong>转换</strong></h4><p> 在抽取和加载之间，任何对数据的处理过程都是转换。这些处理过程通常包括（但不限于）下面一些操作。</p><ul><li>移动数据</li><li>根据规则验证数据</li><li>数据内容和数据结构的修改</li><li>集成多个数据源的数据</li><li>根据处理后的数据计算派生值和聚集值</li></ul><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><p> 将数据加载到目标系统的所有操作。</p><h3 id="ETL解决方案演化过程"><a href="#ETL解决方案演化过程" class="headerlink" title="ETL解决方案演化过程"></a><strong>ETL解决方案演化过程</strong></h3><p>第一代，使用手工编程、脚本的方式来完成。</p><p>第二代，依据设计好的ETL工作流来自动生成所需代码。</p><p>第三代，采用基于引擎的架构，可以执行所有的数据处理进程，还可以将所有的数据库连接和转换规则作为元数据存储起来。</p><p>第四代，基于MDA智能化ETL。</p><h3 id="ETL工具"><a href="#ETL工具" class="headerlink" title="ETL工具"></a><strong>ETL工具</strong></h3><p><img src="/images/ETL_202101.png" alt="“伊成博客”"></p><p><img src="/images/ETL_202102.png" alt="“伊成博客”"></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><p>一，数据迁移。</p><p>二，数据同步。</p><h3 id="数据集成的几种方式"><a href="#数据集成的几种方式" class="headerlink" title="数据集成的几种方式"></a><strong>数据集成的几种方式</strong></h3><p><img src="/images/ETL_202103.png" alt="“伊成博客”"></p><h4 id="ELT"><a href="#ELT" class="headerlink" title="ELT"></a><strong>ELT</strong></h4><p>抽取、加载和转换的简称，同ETL在数据整合的方法上略微不同。在ELT的情况下，数据首先从源数据进行抽取、加载到目标数据库中，再转换为所需要的格式。所有大数据量处理全部放在目标数据库中进行。这种做法的好处在于，一般情况下，数据库系统更适合处理负荷在百万级以上的数据储存民。数据库系统也通常会对I/O(吞吐量)进行优化，用来提高数据处理速度。</p><h4 id="EII"><a href="#EII" class="headerlink" title="EII"></a><strong>EII</strong></h4><p>除了物理数据集成方式，还有虚拟数据集成方式也可以满足用户访问数据的要求。这种虚拟数据集成试就是企业信息集成，也就是EII。如数据联邦和数据虚拟化，也都是描述同样的事情。</p><p>这种方法的主要优点就是数据永远都是最新的，不需要额外的存储层，没有冗余数据。缺点就是使用虚拟方法来管理大量的、清洗后的、时效性强的数据是一个非常具有挑战性的工作。</p><h3 id="虚拟数据集成和物理数据集成的比较"><a href="#虚拟数据集成和物理数据集成的比较" class="headerlink" title="虚拟数据集成和物理数据集成的比较"></a><strong>虚拟数据集成和物理数据集成的比较</strong></h3><p><img src="/images/ETL_202104.png" alt="“伊成博客”"></p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;DT时代，把数据转换为信息、知识，已成为企业提高核心竞争力的关键。目前，大多数企业和政府采用传统的数据库脚
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ETL" scheme="http://www.devcheng.net/tags/ETL/"/>
    
      <category term="ELT" scheme="http://www.devcheng.net/tags/ELT/"/>
    
      <category term="数据集成" scheme="http://www.devcheng.net/tags/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>基于SpringBoot开发的招聘网站源码分享</title>
    <link href="http://www.devcheng.net/post/2093beaf.html"/>
    <id>http://www.devcheng.net/post/2093beaf.html</id>
    <published>2021-01-19T02:16:31.000Z</published>
    <updated>2021-01-19T03:36:51.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于SpringBoot开发招聘网站，可以当作毕业设计、期末课程作业等，也使用刚刚入门SpringBoot的同学们！</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a><strong>功能描述</strong></h2><p>项目分为应聘方和招聘方两种角色，招聘方可以发布职位，应聘方创建简历通过投递简历应聘。</p><p>在项目中主要拥有的功能有：登录（密码登录，验证码登录），注册，创建简历，投递，查看职位详情，申请职位等。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><ul><li>系统环境：Windows 10</li><li>开发工具：IntelliJ IDEA</li><li>Java版本：JDK 1.8</li></ul><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven 3.X</li><li>Bootstarp</li><li>Druid</li><li>Mysql</li><li>Jsp</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8081/" target="_blank" rel="noopener">http://localhost:8081/</a></p><p>账户和密码(密码登陆)： 18612345678 / 1234567</p><h2 id="系统展示图"><a href="#系统展示图" class="headerlink" title="系统展示图"></a><strong>系统展示图</strong></h2><p><img src="/images/devcheng_net_zhaopin3.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin2.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin1.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin4.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_zhaopin5.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索：792435323联系我！ 备注：招聘网站源码</p><h2 id="项目演示视频"><a href="#项目演示视频" class="headerlink" title="项目演示视频"></a><strong>项目演示视频</strong></h2><p>链接: <a href="https://pan.baidu.com/s/1pIwQ3s8casozF02VzRVtxQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1pIwQ3s8casozF02VzRVtxQ</a> </p><p>提取码: dxnr </p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p><h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><p>白嫖怪请绕道！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于SpringBoot开发招聘网站，可以当作毕业设计、期末课程作业等，也使用刚刚入门Spring
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="SpringBoot" scheme="http://www.devcheng.net/tags/SpringBoot/"/>
    
      <category term="招聘网站" scheme="http://www.devcheng.net/tags/%E6%8B%9B%E8%81%98%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>分享几个实用的Git技巧</title>
    <link href="http://www.devcheng.net/post/ddae8940.html"/>
    <id>http://www.devcheng.net/post/ddae8940.html</id>
    <published>2021-01-12T13:59:13.000Z</published>
    <updated>2021-01-12T14:08:38.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>可以这么说,Git在一定程度上拯救了很多开发者的饭碗。只要你经常使用Git保存自己的工作，你就一直有机会可以将代码退回到之前的状态，因此就可以挽回那些你深夜里迷迷糊糊犯下的错误。</p><p>但是Git的命令行界面可是出了名的难掌握。接下来，就给大家介绍7个比较实用的小技巧，最大限度发挥Git的作用。</p><p>通常，大部分时间我们都只会用到add、commit、branch和push/pull这些命令。大部分人熟悉这套只往一个方向运转的工作流。你们有没有想过，如果自己往仓库中添加了错误的文件，或是将代码提交到了错误的分支，而且提交信息还写错了的话，自己怎样才能取消之前的操作？如果你也是按照上面漫画中所描绘的一样操作的，那么你就有必要了解下面这些Git使用技巧了。</p><h2 id="Git技巧"><a href="#Git技巧" class="headerlink" title="Git技巧"></a>Git技巧</h2><h3 id="1-修改错误的提交信息（commit-message）"><a href="#1-修改错误的提交信息（commit-message）" class="headerlink" title="1.修改错误的提交信息（commit message）"></a>1.修改错误的提交信息（commit message）</h3><p>提交的信息在很长时间内会一直保留在你的代码库（code base）中，所以你肯定希望通过这个信息正确地了解代码修改情况。 下面这个命令可以让你编辑最近一次的提交信息，但是你必须确保没有对当前的代码库（working copy）做修改，否则这些修改也会随之一起提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m ”YOUR-NEW-COMMIT-MESSAGE”</span><br></pre></td></tr></table></figure><p>假如你已经将代码提交（git commit）推送（git push）到了远程分支，那么你需要通过下面的命令强制推送这次的代码提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote&gt; &lt;branch&gt; --force</span><br></pre></td></tr></table></figure><h3 id="2-提交之前撤销-git-add"><a href="#2-提交之前撤销-git-add" class="headerlink" title="2.提交之前撤销 git add"></a>2.提交之前撤销 git add</h3><p>如果你往暂存区（staging area）中加入了一些错误的文件，但是还没有提交代码。你可以使用一条简单的命令就可以撤销。如果只需要移除一个文件，那么请输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>或者如果你想从暂存区移除所有没有提交的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset</span><br></pre></td></tr></table></figure><h3 id="3-撤销最近一次代码提交"><a href="#3-撤销最近一次代码提交" class="headerlink" title="3.撤销最近一次代码提交"></a>3.撤销最近一次代码提交</h3><p>有时候你可能会不小心提交了错误的文件或一开始就遗漏了某些东西。<br>下面这三步操作可以帮助你解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~1</span><br></pre></td></tr></table></figure><p><strong>对工作文件进行必要的更改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add -A .</span><br><span class="line">$ git commit -c ORIG_HEAD</span><br></pre></td></tr></table></figure><p>你执行第一个命令时，Git会将HEAD指针后移到此前的一次提交，之后你才能移动文件或作必要的修改。</p><p>然后你就可以添加所有的修改，而且当你执行最后的命令时，Git会打开你的默认文本编辑器，其中会包含上一次提交时的信息。<br>如果愿意的话，你可以修改提交信息，或者你也可以在最后的命令中使用-C而不是-c，来跳过这一步。</p><h3 id="4-Git仓库撤销至前一次提交时的状态"><a href="#4-Git仓库撤销至前一次提交时的状态" class="headerlink" title="4.Git仓库撤销至前一次提交时的状态"></a>4.Git仓库撤销至前一次提交时的状态</h3><p>“撤销”（revert）在许多情况下是非常有必要的——尤其是你把代码搞的一团糟的情况下。最常见的情况是，你想回到之前代码版本，检查下那个时候的代码库，然后再回到现在状态。这可以通过下面的命令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;SHA&gt;</span><br></pre></td></tr></table></figure><p>“”是你想查看的提交拥有的哈希值（Hash Code）中前8至10个字符。 这个命令会使<head><meta name="generator" content="Hexo 3.8.0">指针脱离（detach），可以让你在不检出（check out）任何分支的情况下查看代码——脱离HEAD并不像听上去那么可怕。如果你想在这种情况下提交修改，你可以通过创建新的分支来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;SHA&gt;</span><br></pre></td></tr></table></figure></head></p><p>要想回到当前的工作进度，只需要检出（check out）你之前所在的分支即可。</p><h3 id="5-撤销合并（Merge）"><a href="#5-撤销合并（Merge）" class="headerlink" title="5.撤销合并（Merge）"></a>5.撤销合并（Merge）</h3><p>要想撤销合并，你可能必须要使用恢复命令（HARD RESET）回到上一次提交的状态。“合并”所做的工作基本上就是重置索引，更新working tree（工作树）中的不同文件，即当前提交（）代码中与HEAD游标所指向代码之间的不同文件；但是合并会保留索引与working tree之间的差异部分（例如那些没有被追踪的修改）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;SHA&gt;</span><br></pre></td></tr></table></figure></p><p>当然，Git中总是有其他的实现办法，你可以查看看这篇文章继续了解。</p><h3 id="6-从当前Git分支移除未追踪的本地文件"><a href="#6-从当前Git分支移除未追踪的本地文件" class="headerlink" title="6.从当前Git分支移除未追踪的本地文件"></a>6.从当前Git分支移除未追踪的本地文件</h3><p>假设你凑巧有一些未被追踪的文件（因为不再需要它们），不想每次使用git status命令时让它们显示出来。下面是解决这个问题的一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f -n         # 1</span><br><span class="line">$ git clean -f            # 2</span><br><span class="line">$ git clean -fd           # 3</span><br><span class="line">$ git clean -fX           # 4</span><br><span class="line">$ git clean -fx           # 5</span><br></pre></td></tr></table></figure></p><p>(1): 选项-n将显示执行（2）时将会移除哪些文件。<br>(2): 该命令会移除所有命令（1）中显示的文件。<br>(3): 如果你还想移除文件件，请使用选项-d。<br>(4): 如果你只想移除已被忽略的文件，请使用选项-X。<br>(5): 如果你想移除已被忽略和未被忽略的文件，请使用选项-x。<br>请注意最后两个命令中X的区别。</p><h3 id="7-删除本地和远程Git分支"><a href="#7-删除本地和远程Git分支" class="headerlink" title="7.删除本地和远程Git分支"></a>7.删除本地和远程Git分支</h3><p>删除本地分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --delete --force &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p><p>或者使用选项-D作为简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D</span><br></pre></td></tr></table></figure></p><p>删除远程分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete &lt;branchName&gt;</span><br></pre></td></tr></table></figure></p><p>建议：要想更好地掌握Git的用法，还得仔细阅读Git官方文档！</p><hr><p>The end.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;可以这么说,Git在一定程度上拯救了很多开发者的饭碗。只要你经常使用Git保存自己的工作，你就一直有机会可以将代码退回到之前
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Git" scheme="http://www.devcheng.net/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化干货总结</title>
    <link href="http://www.devcheng.net/post/991a821e.html"/>
    <id>http://www.devcheng.net/post/991a821e.html</id>
    <published>2021-01-03T06:45:54.000Z</published>
    <updated>2021-01-03T07:12:02.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？”。<br>SQL优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，如果是你，在这个问题上能吊打面试官还是会被吊打呢？</p><h2 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h2><h3 id="SELECT语句-语法顺序"><a href="#SELECT语句-语法顺序" class="headerlink" title="SELECT语句 - 语法顺序"></a>SELECT语句 - 语法顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. SELECT </span><br><span class="line">2. DISTINCT &lt;select_list&gt;</span><br><span class="line">3. FROM &lt;left_table&gt;</span><br><span class="line">4. &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">5. ON &lt;join_condition&gt;</span><br><span class="line">6. WHERE &lt;where_condition&gt;</span><br><span class="line">7. GROUP BY &lt;group_by_list&gt;</span><br><span class="line">8. HAVING &lt;having_condition&gt;</span><br><span class="line">9. ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">10.LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>Tips:以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准。</p><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h2><h3 id="避免不走索引的场景"><a href="#避免不走索引的场景" class="headerlink" title="避免不走索引的场景"></a>避免不走索引的场景</h3><ol><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;%陈%&apos;</span><br></pre></td></tr></table></figure><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE name LIKE &apos;陈%&apos;</span><br></pre></td></tr></table></figure><ol start="2"><li>尽量避免使用in 和not in，会导致引擎走全表扫描</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id IN (2,3)</span><br></pre></td></tr></table></figure><p>优化方式：如果是连续数值，可以用between代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id BETWEEN 2 AND 3</span><br></pre></td></tr></table></figure><p>如果是子查询，可以用exists代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 不走索引</span><br><span class="line">select * from A where A.id in (select id from B);</span><br><span class="line">-- 走索引</span><br><span class="line">select * from A where exists (select * from B where B.id = A.id);</span><br></pre></td></tr></table></figure><ol start="3"><li>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1 OR id = 3</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：可以用union代替or。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id = 1</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM student WHERE id = 3</span><br></pre></td></tr></table></figure><p>4.尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score IS NUL</span><br></pre></td></tr></table></figure></p><p>优化方式：可以给字段添加默认值0，对0值进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE score = 0</span><br></pre></td></tr></table></figure><p>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。<br>可以将表达式、函数操作移动到等号右侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 全表扫描</span><br><span class="line">SELECT * FROM T WHERE score/10 = 9</span><br><span class="line">-- 走索引</span><br><span class="line">SELECT * FROM T WHERE score = 10*9</span><br></pre></td></tr></table></figure></p><ol start="6"><li>当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT username, age, sex FROM T WHERE 1=1</span><br></pre></td></tr></table></figure></li></ol><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。</p><ol start="7"><li>查询条件不能用 &lt;&gt; 或者 != 使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</li></ol><ol start="8"><li><p>where条件仅包含复合索引非前置列<br>复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where key_part2=1 and key_part3=2</span><br></pre></td></tr></table></figure></li><li><p>隐式类型转换造成不使用索引<br>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1 from table where col_varchar=123;</span><br></pre></td></tr></table></figure></li><li><p>order by 条件要与where中条件一致，否则order by不会利用索引进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 不走age索引</span><br><span class="line">SELECT * FROM student order by age;</span><br><span class="line"> </span><br><span class="line">-- 走age索引</span><br><span class="line">SELECT * FROM student where age &gt; 0 order by age;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SELECT语句其他优化"><a href="#SELECT语句其他优化" class="headerlink" title="SELECT语句其他优化"></a>SELECT语句其他优化</h2><ol><li>避免出现select *</li><li>避免出现不确定结果的函数</li><li>多表关联查询时，小表在前，大表在后。</li><li>使用表的别名</li><li>用where字句替换HAVING字句</li><li>调整Where字句中的连接顺序</li></ol><h2 id="查询条件优化"><a href="#查询条件优化" class="headerlink" title="查询条件优化"></a>查询条件优化</h2><ol><li>对于复杂的查询，可以使用中间临时表 暂存数据</li></ol><ol start="2"><li><p>优化group by语句<br>默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。<br>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：<br>SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;</p></li><li><p>优化join语句<br>MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。<br>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：<br>SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )<br>如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM customerinfo </span><br><span class="line">   LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID </span><br><span class="line">      WHERE salesinfo.CustomerID IS NULL</span><br></pre></td></tr></table></figure><p>连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><ol start="4"><li>优化union查询<br>MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。<br>高效：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION ALL </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>低效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 </span><br><span class="line"> </span><br><span class="line">UNION </span><br><span class="line"> </span><br><span class="line">SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &apos;DEVCHENG&apos;;</span><br></pre></td></tr></table></figure></p><p>5.拆分复杂SQL为多个小SQL，避免大事务<br>简单的SQL容易使用到MySQL的QUERY CACHE；<br>减少锁表时间特别是使用MyISAM存储引擎的表；可以使用多核CPU。</p><p>6.使用truncate代替delete<br>当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。<br>使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。</p><h2 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h2><p>1.在表中建立索引，优先考虑where、order by使用到的字段。</p><ol start="2"><li>尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</li></ol><p>3.查询数据量大的表 会造成查询缓慢。</p><p>4.用varchar/nvarchar 代替 char/nchar<br>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h3 id="The-end"><a href="#The-end" class="headerlink" title="The end ."></a>The end .</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在面试中无论大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL优化" scheme="http://www.devcheng.net/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker踩坑学习笔记</title>
    <link href="http://www.devcheng.net/post/53539811.html"/>
    <id>http://www.devcheng.net/post/53539811.html</id>
    <published>2020-12-25T15:13:25.000Z</published>
    <updated>2020-12-25T15:24:19.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>安装完成功docker后，如何在容器中安装JDK、TOMCAT。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search jdk </span><br><span class="line"></span><br><span class="line">docker install jdk_open...</span><br></pre></td></tr></table></figure><h2 id="docker中如何挂载文件"><a href="#docker中如何挂载文件" class="headerlink" title="docker中如何挂载文件"></a>docker中如何挂载文件</h2><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>上传压缩文件到服务器，这种方式需要将服务器上的文件挂载到docker 容器中。<br>docker可以支持把一个宿主机上的目录挂载在docker容器中（镜像）。</p><p>tips:要把宿主机文件挂载在容器中，此时，身份是 宿主机中<br>找到要被挂载文件的目录</p><p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径</p><p>执行</p><p><img src="/images/devcheng_net_docker_1clipboard.png" alt="image-20200629094621998"></p><p>挂载成功</p><p><img src="/images/devcheng_net_docker_2clipboard.png" alt="image-20200629094621998"></p><p>解压jdk </p><p>此时会遇到权限不够的问题</p><p>操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.退出容器</span><br><span class="line">2. 执行 su -c &quot;setenforce 0&quot;</span><br><span class="line">3.dorcker run -i -t centos /bin/bash</span><br></pre></td></tr></table></figure></p><p>重新解压即可！<br>相关解决链接：<a href="http://www.cnblogs.com/adamas21/p/6280297.html" target="_blank" rel="noopener">http://www.cnblogs.com/adamas21/p/6280297.html</a></p><p>启动docker web服务时,虚拟机端口转发外部无法访问?可参考以下链接：<br><a href="http://blog.csdn.net/u014062332/article/details/52911405" target="_blank" rel="noopener">http://blog.csdn.net/u014062332/article/details/52911405</a></p><h3 id="jdk的配置"><a href="#jdk的配置" class="headerlink" title="jdk的配置"></a>jdk的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下配置</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_121</span><br><span class="line">export JRE_HOME=/usr/java/jdk1.8.0_121/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br></pre></td></tr></table></figure><h2 id="The-end"><a href="#The-end" class="headerlink" title="The end."></a>The end.</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;安装完成功docker后，如何在容器中安装JDK、TOMCAT。&lt;/p&gt;
&lt;h3 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="docker" scheme="http://www.devcheng.net/tags/docker/"/>
    
  </entry>
  
</feed>
