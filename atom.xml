<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>伊成个人站-热衷于技术分享，源码分享的个人博客网站</title>
  
  <subtitle>伊成个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.devcheng.net/"/>
  <updated>2020-07-13T13:38:52.159Z</updated>
  <id>http://www.devcheng.net/</id>
  
  <author>
    <name>伊成</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重装系统如何继续恢复Hexo博客</title>
    <link href="http://www.devcheng.net/post/7fee676.html"/>
    <id>http://www.devcheng.net/post/7fee676.html</id>
    <published>2020-07-12T09:42:58.000Z</published>
    <updated>2020-07-13T13:38:52.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾的缘故，但是清理系统垃圾之后还是有卡顿的现象，干脆从新装一个系统得了。</p><p>在重装系统之前，事先把原来Hexo的文件夹都备份一下。同时，我还备份了对应的id_rsa和id_rsa.pub文件。</p><p><strong>如果要重装系统，务必要备份对应的文件！</strong></p><p>备份好对应的文件之后，开始重装系统！</p><h3 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a><strong>安装Node.js和Git</strong></h3><p>1.安装Node.js</p><p>2.安装Git</p><p>具体细节就不展开细说了，可自行为度娘！安装成功node.js和git之后，查看一下确保无问题。</p><p><img src="/images/devcheng_net_hexo_recover_001.png" alt="“伊成博客”"></p><h3 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a><strong>配置SSH key</strong></h3><p>在最上面，已经提及到了 SSH key 对应的2个文件，<br>找到路径 C:\Users\用户名.ssh 有无.ssh文件夹，没有则创建。</p><p>执行命令，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure></p><p>因为重装系统之前已经备份id_rsa和id_rsa.pub文件,所以把这2个文件复制到.ssh文件夹内即可。</p><p>使用命令，测试是否成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@e.coding.net</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_hexo_revover_002.png" alt="“伊成博客”"></p><h3 id="配置Git用户名和邮箱"><a href="#配置Git用户名和邮箱" class="headerlink" title="配置Git用户名和邮箱"></a><strong>配置Git用户名和邮箱</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;devcheng&quot;    // 你的coding或github用户名，并非昵称</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;// 你的coding或github的注册邮箱</span><br></pre></td></tr></table></figure><h3 id="复制备份的文件夹"><a href="#复制备份的文件夹" class="headerlink" title="复制备份的文件夹"></a><strong>复制备份的文件夹</strong></h3><p>文件夹删除node_modules public .git .deploy_git</p><p><img src="/images/devcheng_net_hexo_recover_003.png" alt="“伊成博客”"></p><h3 id="和远程项目关联"><a href="#和远程项目关联" class="headerlink" title="和远程项目关联"></a><strong>和远程项目关联</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 你的hexo博客git地址</span><br></pre></td></tr></table></figure><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a><strong>安装hexo</strong></h3><p>开始执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>并没有成功的安装好hexo,于是从新换一个命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>依然还是提示有对应的依赖没有找到，于是我把最开始备份的整个文件夹，全部都复制到了现在这个目录。</p><p><img src="/images/devcheng_net_hexo_recover_004.png" alt="“伊成博客”"></p><h3 id="强势启动"><a href="#强势启动" class="headerlink" title="强势启动"></a><strong>强势启动</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>突然发现，居然可以启动起来。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>以上步骤，仅供参考，步骤不是惟一定死的，各位务必根据自己的操作情况而定。这篇博客就是从重装系统之后写的第一篇博文！<br>如有不妥之处，请留言！</p><p>The end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于电脑系统使用的时间久了之后，渐渐的感觉在使用电脑的时候有卡顿以及响应时间逐渐变长。开始还以为是系统垃圾
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="恢复Hexo" scheme="http://www.devcheng.net/tags/%E6%81%A2%E5%A4%8DHexo/"/>
    
      <category term="重装系统" scheme="http://www.devcheng.net/tags/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中按字段查询重复数据</title>
    <link href="http://www.devcheng.net/post/4dfd5416.html"/>
    <id>http://www.devcheng.net/post/4dfd5416.html</id>
    <published>2020-07-09T13:37:57.000Z</published>
    <updated>2020-07-09T13:48:17.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug(没有对数据做重复数据校验)等。</p><p>既然是难免的情况，那如何处理呢？</p><h2 id="根据一个字段查询重复数据"><a href="#根据一个字段查询重复数据" class="headerlink" title="根据一个字段查询重复数据"></a>根据一个字段查询重复数据</h2><p>举个栗子，有个用户表测试小姐姐拼命的创建同一条数据插入到用户表。<br>那么在用户表中就会存在相同用户名的多条数据，根据 用户名 查询重复数据的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> userName <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果查询出来重复数据只需要保留一条，那就得把多余的数据删除即可，对应SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName);</span><br></pre></td></tr></table></figure><p>这里是根据 用户名分组保留用户ID最大的那条数据，其它的都删掉！<br>具体保留哪条数据，各位小伙伴可自行决定~</p><h2 id="根据多个字段查询重复数据"><a href="#根据多个字段查询重复数据" class="headerlink" title="根据多个字段查询重复数据"></a>根据多个字段查询重复数据</h2><p>在举个栗子，在这个用户表中 用户名和用户类型 都重复的需要查询出来，对应的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType <span class="keyword">HAVING</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根据多个字段查询，保留一条数据，删除多余数据SQL如下：</p><p>方法一：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">MAX</span>( userId ) <span class="keyword">AS</span> maxid <span class="keyword">FROM</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> userName,userType);</span><br></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nameAndType <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user) tt <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType <span class="keyword">HAVING</span> <span class="keyword">count</span>(nameAndType) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>方法三：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> userId <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> maxid <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(userId) <span class="keyword">as</span> maxid, <span class="keyword">CONCAT</span>(userName,userType) <span class="keyword">as</span> nameAndType <span class="keyword">from</span> tb_user <span class="keyword">GROUP</span> <span class="keyword">BY</span> nameAndType) t);</span><br></pre></td></tr></table></figure></p><p>方法一中删除多余重复数据和上面文章中的思路是一致的，方法二和方法三的思路是利用CONCAT函数。</p><p>以上，如果你开发过程中遇到同样问题，可以使用上面的SQL尝试一下！</p><p>The end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在项目开发中，难免会遇到xx表有重复数据(脏数据)，导致的原因有很多，可能是测试人员一直在添加同一条数据，也可能是编写的功能本身就存在bug
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="MySQL" scheme="http://www.devcheng.net/tags/MySQL/"/>
    
      <category term="重复数据" scheme="http://www.devcheng.net/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java8中列表的排序(升序、降序)</title>
    <link href="http://www.devcheng.net/post/835182f7.html"/>
    <id>http://www.devcheng.net/post/835182f7.html</id>
    <published>2020-07-02T13:34:11.000Z</published>
    <updated>2020-07-02T13:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来。</p><p>时过境迁，现在的项目中采用了Spring Data JPa,当然也支持排序。但本文中的主角可不是它，在很多情况下我们查询出来的List数据没有排序好或是需要二次按照某字段排序，这个时候，我们就可以使用Java8对其排序。</p><p>首先，看个基础语法，如下：</p><h3 id="单个字段排序"><a href="#单个字段排序" class="headerlink" title="单个字段排序"></a>单个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;类&gt; list; 代表某集合</span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回 对象集合以类属性一升序排序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序排序 注意两种写法</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">//先以属性一升序,结果进行属性一降序</span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一).reversed());</span></span><br><span class="line"><span class="comment">//以属性一降序 </span></span><br><span class="line"><span class="comment">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()));</span></span><br></pre></td></tr></table></figure><h3 id="多个字段排序"><a href="#多个字段排序" class="headerlink" title="多个字段排序"></a>多个字段排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 对象集合以类属性一升序 属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序</span></span><br><span class="line"> list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二升序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一降序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"><span class="comment">//先以属性一降序,再进行属性二降序</span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一,Comparator.reverseOrder()).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 对象集合以类属性一升序 属性二降序 注意两种写法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,升序结果进行属性一降序,再进行属性二升序,结果进行属性一降序属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).reversed().thenComparing(类::属性二).reversed());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//先以属性一升序,再进行属性二降序 </span></span><br><span class="line">list.stream().sorted(Comparator.comparing(类::属性一).thenComparing(类::属性二,Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(Comparator.comparing(User::getId).reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据User对象的id字段降序排序</span></span><br><span class="line">userList.sort(User::getId,Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过以实例代码我们可以发现</p><p>写法一： Comparator.comparing(类::属性一).reversed();</p><p>写法二： Comparator.comparing(类::属性一,Comparator.reverseOrder());</p><p>两种排序是完全不一样的,一定要区分开来。</p><p>写法一是得到排序结果后再排序；</p><p>写法二是直接进行排序,很多人会混淆导致理解出错,但写法二更好理解,建议使用写法二。</p><h2 id="完整例子demo"><a href="#完整例子demo" class="headerlink" title="完整例子demo"></a>完整例子demo</h2><p>最后贴一个完整的例子，供大家参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">22</span>,<span class="string">"张X"</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">27</span>,<span class="string">"李X"</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">21</span>,<span class="string">"王X"</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">18</span>,<span class="string">"赵X"</span>);</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    list.add(user1);</span><br><span class="line">    list.add(user2);</span><br><span class="line">    list.add(user3);</span><br><span class="line">    list.add(user4);</span><br><span class="line">    <span class="keyword">for</span>(User u :list)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; newList = list.stream().sorted(Comparator.comparing(User::getAge))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">for</span>(User u :newList)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;还记得几年前，那时候查询数据基本都是在数据库中把查询的数据做好排序。举个栗子，在查询User表的时候按照创建时间升序查询出来
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
      <category term="排序" scheme="http://www.devcheng.net/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中三大构建工具的发展历程（Ant、Maven和Gradle）</title>
    <link href="http://www.devcheng.net/post/e200ec64.html"/>
    <id>http://www.devcheng.net/post/e200ec64.html</id>
    <published>2020-06-21T07:47:09.000Z</published>
    <updated>2020-06-21T07:49:21.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们要写一个Java程序，一般的步骤是编译，测试，打包。</p><p>这个构建的过程，如果文件比较少，我们可以手动使用java, javac,jar命令去做这些事情。但当工程越来越大，文件越来越多，这个事情就不是那么地令人开心了。</p><p>因为这些命令往往都是很机械的操作。所以我们可以把这些机械的操作交给机器去做。</p><p>而在linux中，有一个工具叫make。<br>我们可以通过编写Makefile来执行工程的构建，在windows上相应的工具是nmake。</p><p>那既然有现成的工具，为什么当时没有选择Makefile呢？说道这里那就不得不提一下Ant了。</p><h2 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h2><p>说起Ant，就不得不说另一个Apache开源项目Tomcat。Tomcat作为轻量级Web容器，早已声名鹊起。最开始的时候，Ant是Tomcat的一部分，Ant的唯一目的就是build Tomcat。</p><p>不久，很多Java开源项目意识到Ant的简洁适用，更重要的是弥补Makefiles的不足。自从Jakarta以及Apache项目开始采用Ant以来,作为构建工具的Ant很快发展在各种各样的项目中。</p><p>在2000年1月，Ant脱离了Tomcat，成为独立的Apache开源项目，由独立的CVS模块维护，正式更名为Apache Ant。</p><p>第一个Ant版本是Tomcat 3.1于2000年4月19日发行的版本。此版本后来称为Ant 0.3.1。</p><p>到目前Ant最新的版本是 <strong>2020年5月13日 版本号：1.10.8</strong></p><p>具体的版本发行历程可点击链接查看 <a href="http://ant.apache.org/faq.html" target="_blank" rel="noopener">http://ant.apache.org/faq.html</a></p><h3 id="Ant示例"><a href="#Ant示例" class="headerlink" title="Ant示例"></a>Ant示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"HelloWorld"</span> <span class="attr">default</span>=<span class="string">"run"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">value</span>=<span class="string">"src"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dest"</span> <span class="attr">value</span>=<span class="string">"classes"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jarfile"</span> <span class="attr">value</span>=<span class="string">"hello.jar"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">depends</span>=<span class="string">"compile"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;jarfile&#125;"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;dest&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">depends</span>=<span class="string">"build"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">java</span> <span class="attr">classname</span>=<span class="string">"test.ant.HelloWorld"</span> <span class="attr">classpath</span>=<span class="string">"$&#123;hello_jar&#125;"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dest&#125;"</span> /&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;hello_jar&#125;"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例，得知Ant定义了五个任务，init, compile, build, test,clean。</p><p>每个任务做什么都定义清楚了。在打包之前要先编译，所以通过depends来指定依赖的路径。</p><p>如果在命令行里执行ant build，那就会先执行compile，而compile又依赖于init，所以就会先执行init。</p><p>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ant test</span><br></pre></td></tr></table></figure></p><p>通过命令就可以执行编程，打包，测试。为开发者带来了很大的便利，提供了工作效率。</p><p>但是Ant有一个很致命的缺陷，那就是没办法管理依赖。</p><p>我们一个工程，要使用很多第三方工具，不同的工具，不同的版本。</p><p>每次打包都要自己手动去把正确的版本拷到lib下面去，不用说，这个工作既枯燥还特别容易出错。为了解决这个问题，Maven如约而至。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven之前我们经常使用Ant来进行Java项目的构建，然后Ant仅是一个构建工具，它并未对项目的中的工程依赖以及项目本身进行管理，并且Ant作为构建工具未能消除软件构建的重复性，因为不同的项目需要编写对应的Ant任务。</p><p>Maven作为后来者，继承了Ant的项目构建功能，并且提供了依赖关系，项目管理的功能，因此它是一个项目管理和综合工具， 其核心的依赖管理， 项目信息管理， 中央仓库，约定大于配置的核心功能使得Maven成为当前Java项目构建和管理工具的标准选择。</p><p>Maven 发展历程： Maven –&gt; Maven2 –&gt; Maven3</p><p>到目前Maven最新的版本是 <strong>2019-11-25 版本号：3.6.3</strong></p><h3 id="Maven示例"><a href="#Maven示例" class="headerlink" title="Maven示例"></a>Maven示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...xmlns...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.devcheng.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由示例得知，包的坐标是net.devcheng.demo:Example:0.1.0-SNAPSHOT，而工程中要依赖junit:junit:4.10。</p><p>那么Maven就会自动去帮我把junit打包进来。如果本地没有junit，maven还会帮自动去网上下载。我们还通过Maven安装目录下的settings.xml文件可以配置本地仓库的路径，以及采用的远程仓库的地址。</p><p>相对于上文中的Ant来说，Maven抛弃了Ant中通过target定义任务的做法，对于依赖引入了生命周期。</p><p>最后在说说 Gradle。</p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Gradle是一个基于Apache Ant和ApacheMaven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL，抛弃了基于XML的各种繁琐配置。</p><p>由以上定义得知，Gradle已经抛弃了Ant,Maven中Xml配置的形式。Gradle继承了Maven中仓库，坐标，依赖这些核心概念。文件的布局也和Maven相同。但同时，又继承了Ant中target的概念，我们又可以重新定义自己的任务(在Gradle中叫做task)。</p><h3 id="Gradle示例"><a href="#Gradle示例" class="headerlink" title="Gradle示例"></a>Gradle示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.slf4j:slf4j-api:1.7.21&apos;</span><br><span class="line">    your tests.</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由示例可看出内容很简单，引入了java插件，指定仓库，指定依赖。可以看到依赖的设定相比起xml的写法，变得大大简化了。</p><p>到目前Gradle最新的版本是 <strong>2020年6月2日 版本号：v6.5</strong></p><h3 id="Gradle-vs-Maven"><a href="#Gradle-vs-Maven" class="headerlink" title="Gradle vs Maven"></a>Gradle vs Maven</h3><p>关于Gradle和Maven的区别，简单比较如下：</p><ul><li><p>Maven和Gradle对依赖项的scope有所不同。<br>在Maven世界中，一个依赖项有6种scope，分别是complie(默认)、provided、runtime、test、system、import。<br>而grade将其简化为了4种，compile、runtime、testCompile、testRuntime。</p></li><li><p>Gradle支持动态的版本依赖。在版本号后面使用+号的方式可以实现动态的版本管理。</p></li><li>解决依赖冲突方面Gradle的实现机制更加明确。使用Maven和Gradle进行依赖管理时都采用的是传递性依赖；而如果多个依赖项指向同一个依赖项的不同版本时就会引起依赖冲突。而Maven处理这种依赖关系往往是噩梦一般的存在。而Gradle在解决依赖冲突方面相对来说比较明确。</li><li>Maven引用依赖方面采用的xml，而Gradle不是。</li></ul><hr><h6 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们要写一个Java程序，一般的步骤是编译，测试，打包。&lt;/p&gt;
&lt;p&gt;这个构建的过程，如果文件比较少，我们可以手动使用java, java
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Ant" scheme="http://www.devcheng.net/tags/Ant/"/>
    
      <category term="Maven" scheme="http://www.devcheng.net/tags/Maven/"/>
    
      <category term="Gradle" scheme="http://www.devcheng.net/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>java通过反射获取注解@Column中的信息</title>
    <link href="http://www.devcheng.net/post/74b831b2.html"/>
    <id>http://www.devcheng.net/post/74b831b2.html</id>
    <published>2020-06-20T02:44:08.000Z</published>
    <updated>2020-06-20T02:49:43.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devcheng.demo.restful.data.service.model.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonDeserialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonSerialize;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"DEV_CHENG_FILE_DEMO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscloseFileEntity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ID"</span>,columnDefinition = <span class="string">"ID"</span>)</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"APPLY_NO"</span>,columnDefinition = <span class="string">"申请号"</span>)</span><br><span class="line">    <span class="keyword">private</span> String applyNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_NAME"</span>,columnDefinition = <span class="string">"文件名称"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"FILE_SIZE"</span>,columnDefinition = <span class="string">"文件大小"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fileSize;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"TITLE"</span>,columnDefinition = <span class="string">"标题"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"IS_VALID"</span>,columnDefinition = <span class="string">"是否有效"</span>)</span><br><span class="line">    <span class="keyword">private</span> String isValid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"SAVE_DATE"</span>,columnDefinition = <span class="string">"保存日期"</span>)    </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime saveDate;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上得知，需要从 @Column 注解中获取 name和columnDefinition 中的信息，那如何可以获取到对应的信息？</p><p>在获取 @Column 注解中的信息之前，先看看 columnDefinition是啥意思?</p><h2 id="columnDefinition"><a href="#columnDefinition" class="headerlink" title="columnDefinition"></a>columnDefinition</h2><p>columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用。</p><p>值得注意的一点是：在编程语言中字符串一般都用String表示，但是数据库中varcahr数值类型有长度限制，一旦需要大文本，则需要text数值类型。但是String类型默认映射的数值类型是varchar，columnDefinition可以进行额外指定。</p><h2 id="获取注解-Column中的信息"><a href="#获取注解-Column中的信息" class="headerlink" title="获取注解@Column中的信息"></a>获取注解@Column中的信息</h2><p>实现思路：通过类路径利用反射获取到对应的注解信息，从而获取到对应@Column中的信息<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TableColumnsVO&gt; <span class="title">getFiledAndAnnotateInfo</span><span class="params">(String entityPath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;TableColumnsVO&gt; tableColumnsLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(entityPath);</span><br><span class="line">            Field[] fields = aClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">            Column presentColumn;</span><br><span class="line">            <span class="keyword">for</span> (Field field:fields)</span><br><span class="line">            &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(Column.class))</span><br><span class="line">                &#123;</span><br><span class="line">                    presentColumn = field.getDeclaredAnnotation(Column.class);</span><br><span class="line">                    TableColumnsVO tableData = <span class="keyword">new</span> TableColumnsVO();</span><br><span class="line">                    tableData.setColumnName(presentColumn.name());</span><br><span class="line">                    tableData.setColumnDefinationInfo(presentColumn.columnDefinition());</span><br><span class="line">                    tableColumnsLists.add(tableData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            log.info(String.format(<span class="string">"获取字段和注释异常：%s"</span>, entityPath));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableColumnsLists;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的 TableColumnsVO代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableColumnsVO</span></span>&#123;</span><br><span class="line">    <span class="comment">//列名</span></span><br><span class="line">    <span class="keyword">private</span> String columnName;</span><br><span class="line">    <span class="comment">//ColumnDefinationInfo信息</span></span><br><span class="line">    <span class="keyword">private</span> String columnDefinationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中需要从实体类的@Column注解中获取对应的信息，先一个实体类的上代码，如下：&lt;br&gt;&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="java反射" scheme="http://www.devcheng.net/tags/java%E5%8F%8D%E5%B0%84/"/>
    
      <category term="Column注解" scheme="http://www.devcheng.net/tags/Column%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>墙裂推荐一款redis客户端可视化工具之RedisPlus</title>
    <link href="http://www.devcheng.net/post/64102a3b.html"/>
    <id>http://www.devcheng.net/post/64102a3b.html</id>
    <published>2020-06-07T07:15:43.000Z</published>
    <updated>2020-06-07T07:23:36.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具。<br>比如：Redis Desktop Manager，RedisView ，RedisClient 等工具。</p><p>今天墙裂推荐一款redis客户端可视化工具：RedisPlus</p><h2 id="RedisPlus"><a href="#RedisPlus" class="headerlink" title="RedisPlus"></a><strong>RedisPlus</strong></h2><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h3><p>RedisPlus是为Redis可视化管理开发的一款开源免费的桌面客户端软件，支持Windows 、Linux、Mac三大系统平台，RedisPlus提供更加高效、方便、快捷的使用体验，有着更加现代化的用户界面风格。该软件支持单机、集群模式连接，同时还支持SSH（单机、<strong>集群</strong>）通道连接。</p><p>项目地址： <a href="https://gitee.com/MaxBill/RedisPlus" target="_blank" rel="noopener">https://gitee.com/MaxBill/RedisPlus</a></p><p>运行截图：<br><img src="/images/devcheng_net_redis_001.jpg" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis_002.jpg" alt="“伊成博客”"></p><p>RedisPlus目前最新版本为：3.2.0。<br>项目介绍中得知，RedisPlus将不再更新迭代，包括V4.0的electron和jfx11版本都将停止开发和更新。</p><p>下载地址<br>百度下载：链接: <a href="https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1GjNFwbmksA1JhguHgcAcSQ</a> 提取码: 3pcm</p><p><img src="/images/devcheng_net_redis_003.png" alt="“伊成博客”"></p><h2 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a><strong>最后说一句</strong></h2><p>在网上不乏有很多redis客户端工具，但是真正能支持集群的没几个工具，同时也找到了一款国外的工具，名字叫FastoRedis。<br>下载地址：<a href="https://fastoredis.com/anonim_users_downloads" target="_blank" rel="noopener">https://fastoredis.com/anonim_users_downloads</a></p><p>FastoRedis 的官方介绍<br>Download FastoRedis - cross-platform client for Redis, supported main Redis database features like: modules, cluster, sentinel, ssh tunneling.</p><p>但是这款工具是收费的，土豪请无视这句话！</p><p>最后有需要RedisPlus的又觉得从百度网盘下载麻烦的，可以加一下我的QQ群：816175200 免费获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在实际工作中，项目中使用redis的项目肯定很多，因此大家或多或少都会接触过一些redis客户端可视化工具
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="RedisPlus" scheme="http://www.devcheng.net/tags/RedisPlus/"/>
    
      <category term="redis客户端" scheme="http://www.devcheng.net/tags/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本新特性小结</title>
    <link href="http://www.devcheng.net/post/5ae138f6.html"/>
    <id>http://www.devcheng.net/post/5ae138f6.html</id>
    <published>2020-05-30T07:07:22.000Z</published>
    <updated>2020-05-30T07:08:50.691Z</updated>
    
    <content type="html"><![CDATA[<p>截止到今天(2020-5-30)JDK已经发布到了 JDK14。</p><p>在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。</p><p>JDK 14已经于2020年3月17日如期发布。下面介绍各个版本的新特性，后续随着JDK新版本的更新迭代，本文会持续更新。</p><p>JDK从1.5版本开始，在官方的正式文档与宣传资料中已经不再使用类似JDK1.5的名称，只有程序员内部</p><p>使用的开发版本号(DeveloperVersion，例如java-version的输出)才继续沿用1.5、1.6、1.7和1.8的版本号，</p><p>而公开版本号(Product Version)则改为JDK5、JDK6、JDK7和JDK8的命名方式。</p><h2 id="JDK-5-新特性"><a href="#JDK-5-新特性" class="headerlink" title="JDK 5 新特性"></a>JDK 5 新特性</h2><p>1.自动装箱、拆箱</p><p>2.静态导入(static import)</p><p>3.增强for循环（for-each）</p><p>4.可变参数</p><p>5.枚举（enmu）</p><p>6.泛型</p><p>7.元数据</p><p>8.线程并发库（JUC）</p><hr><h2 id="JDK-6-新特性"><a href="#JDK-6-新特性" class="headerlink" title="JDK 6 新特性"></a>JDK 6 新特性</h2><p>1.AWT中新增的两个类Desktop和SystemTray</p><p>2.使用JAXB2来实现对象与XML之间的映射</p><ol start="3"><li><p>新增处理DOM和SAX之外又一种处理XML文档的API：STAX</p></li><li><p>使用Compiler API动态编译java源文件</p></li><li><p>轻量级Http Server API</p></li><li><p>插入式注解处理API（用于处理Annotations）</p></li><li><p>用Console开发控制台程序</p></li><li><p>对ruby、groovy、javascript等脚本语言的支持</p></li><li><p>Common Annotations</p></li></ol><hr><h2 id="JDK-7-新特性"><a href="#JDK-7-新特性" class="headerlink" title="JDK 7 新特性"></a>JDK 7 新特性</h2><ol><li><p>对Java集合（Collections）的增强支持</p></li><li><p>在switch中可用String</p></li><li><p>数值可加下划线（eg:int one_million=123_1）</p></li><li><p>支持二进制文字（int binary=0b1001_1001）</p></li><li><p>简化可变参数方法的调用</p></li><li><p>自动资源管理</p></li><li><p>类型推断</p></li><li><p>catch 多个类型异常</p></li></ol><hr><h2 id="JDK-8-新特性"><a href="#JDK-8-新特性" class="headerlink" title="JDK 8 新特性"></a>JDK 8 新特性</h2><ol><li><p>Stream函数式操作流元素集合</p></li><li><p>Lambda表达式</p></li><li><p>新的日期时间 API(Java Date/time API)</p></li><li><p>新增接口：默认方法与静态方法</p></li><li><p>Nashorm(Rhino的接替者，轻量级高性能的javascript运行环境)</p></li><li><p>Accumlators多线程lock</p></li><li><p>方法引用，与Lambda表达式联合使用</p></li><li><p>引入重复注解和类型注解</p></li><li><p>类型注解</p></li><li><p>新增base64加解密API</p></li><li><p>数组并行（parallel）操作</p></li><li><p>JVM的permGen空间移除，被Metaspace元空间取代</p></li></ol><hr><h2 id="JDK-9-新特性"><a href="#JDK-9-新特性" class="headerlink" title="JDK 9 新特性"></a>JDK 9 新特性</h2><ol><li><p>目录结构</p></li><li><p>模块化系统</p></li><li><p>jshell</p></li><li><p>多版本兼容JAR</p></li><li><p>接口的私有方法</p></li><li><p>改进try-with-resourcs</p></li><li><p>改进砖石操作符</p></li><li><p>限制使用单独下划线标识符</p></li><li><p>String存储结构变更</p></li><li><p>快速创建只读结合</p></li><li><p>增强Stream API</p></li><li><p>改进Optional 类</p></li><li><p>多分辨率图像 API</p></li><li><p>全新 HTTP客服端API</p></li><li><p>智能JAVA 编译工具</p></li><li><p>统一JVM 日志系统</p></li><li><p>javadoc 的 HTML5 支持</p></li><li><p>java 动态编译</p></li></ol><hr><h2 id="JDK-10-新特性"><a href="#JDK-10-新特性" class="headerlink" title="JDK 10 新特性"></a>JDK 10 新特性</h2><ol><li><p>局部变量类型推断</p></li><li><p>将JDK多存储库合并为单储存库</p></li><li><p>垃圾回收接口</p></li><li><p>并行Full GC 的G1</p></li><li><p>应用数据共享</p></li><li><p>线程局部管控</p></li><li><p>移除Native-Header Generation Tool （javah）</p></li><li><p>Unicode 标签扩展</p></li><li><p>备用内存设备上分配堆内存</p></li><li><p>基于实验JAVA 的JIT 编译器</p></li><li><p>Root 证书</p></li><li><p>基于时间的版本控制</p></li></ol><hr><h2 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h2><ol><li><p>字符串加强</p></li><li><p>HttClient Api</p></li><li><p>用于 Lambda 参数的局部变量语法</p></li><li><p>ZGC (并发回收的策略)</p></li></ol><hr><h2 id="JDK-12-新特性"><a href="#JDK-12-新特性" class="headerlink" title="JDK 12 新特性"></a>JDK 12 新特性</h2><ol><li><p>Switch Expressions</p></li><li><p>Shenandoah GC (GC 算法)</p></li></ol><hr><h2 id="JDK-13-新特性"><a href="#JDK-13-新特性" class="headerlink" title="JDK 13 新特性"></a>JDK 13 新特性</h2><ol><li><p>switch优化更新</p></li><li><p>文本块升级</p></li><li><p>重新实现旧版套接字API</p></li><li><p>核心库/java.util中：I18N</p></li><li><p>增加ZGC以将未使用的堆内存返回给操作系统</p></li></ol><hr><h2 id="JDK-14-新特性"><a href="#JDK-14-新特性" class="headerlink" title="JDK 14 新特性"></a>JDK 14 新特性</h2><ol><li><p>switch优化变更为最终版</p></li><li><p>垃圾回收相</p></li></ol><ul><li>删除cms垃圾收集器</li><li>弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合</li><li>将 zgc 垃圾回收器移植到 macOS 和 windows 平台 </li></ul><ol start="3"><li><p>instanceof的模式匹配（预览版）</p></li><li><p>删除了安全库java.security.acl API</p></li><li><p>货币格式（优化）</p></li><li><p>友好的空指针异常</p></li><li><p>外部存储器API（孵化）</p></li></ol><p>… </p><p><strong> 本文会持续更新… </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;截止到今天(2020-5-30)JDK已经发布到了 JDK14。&lt;/p&gt;
&lt;p&gt;在2017年8月，JCP执行委员会提出将Java的发布频率改为每六个月一次，新的发布周期严格遵循时间点，将在每年的3月份和9月份发布。&lt;/p&gt;
&lt;p&gt;JDK 14已经于2020年3月17日如期发
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="新特性" scheme="http://www.devcheng.net/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JDK" scheme="http://www.devcheng.net/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>15个超实用的IDEA快捷键</title>
    <link href="http://www.devcheng.net/post/ea3f1216.html"/>
    <id>http://www.devcheng.net/post/ea3f1216.html</id>
    <published>2020-05-23T04:28:19.000Z</published>
    <updated>2020-05-23T04:47:57.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a><strong>叨叨叨</strong></h3><p>相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ctrl+V)也是常用的快捷键之一。<br>掌握必要的一些快捷键，可以提高工作效率，但是IDEA中的快捷键可不是一个两个。为此博主特意整理里15个高频超级实用<br>的IDEA快捷键。</p><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h3><p><strong>Ctrl + Alt + O</strong>  : 移除未使用的包 </p><blockquote><p>tip:可能会和QQ 屏幕识图快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + M</strong> :重构函数:将选中代码提取为函数 </p><p><strong>Ctrl + Alt + L</strong> :代码格式化</p><blockquote><p>tip:可能会和QQ 中的快捷键冲突，解决方法可重新自定义QQ快捷键。</p></blockquote><p><strong>Ctrl + Alt + T</strong>:可以把代码包在一个块内，例如：try/catch</p><p><strong>Ctrl + Alt + B</strong>:定位至选中类或者方法的具体实现</p><p><strong>Ctrl + Shift + F</strong>:全局查找快捷键</p><p><strong>Ctrl + Shift + R</strong>:全局替换</p><p><strong>Ctrl + Shift + U</strong>:大小写切换</p><p><strong>Ctrl + Shift + /</strong>:使用 /**/ 注释</p><p><strong>Ctrl + /</strong>:使用 // 注释</p><p><strong>Ctrl + X（Ctrl + Y）</strong>:删除行</p><p><strong>Ctrl + D</strong>:复制行</p><p><strong>Ctrl+Shift+Alt+J</strong>:批量修改变量快捷键</p><p><strong>F2 或 Shift+F2</strong>:快速定位高亮错误或警告</p><p><strong>Shift+Click</strong>:可以关闭文件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;叨叨叨&quot;&gt;&lt;a href=&quot;#叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;叨叨叨&quot;&gt;&lt;/a&gt;&lt;strong&gt;叨叨叨&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;相信很多开发的小伙伴，或多或少都知道一些IDEA中的快捷键，我们常说的CV大法(Ctrl+C,Ct
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="IDEA快捷键" scheme="http://www.devcheng.net/tags/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发的毕业论文管理系统</title>
    <link href="http://www.devcheng.net/post/1129f657.html"/>
    <id>http://www.devcheng.net/post/1129f657.html</id>
    <published>2020-05-08T12:22:47.000Z</published>
    <updated>2020-05-08T13:24:49.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管理员。<br>不同角色拥有不同的菜单功能，管理员是系统中权限最大的一个角色，即可以管理系统的各个配置以及数据操作。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA 2019.3<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven</li><li>Thymeleaf</li><li>Echarts</li><li>文件服务器centos7</li><li>…</li></ul><h2 id="项目页面预览"><a href="#项目页面预览" class="headerlink" title="项目页面预览"></a><strong>项目页面预览</strong></h2><ul><li><p>系统登录页<br><img src="/images/bylw1.png" alt="“伊成博客”"></p></li><li><p>系统首页<br><img src="/images/bylw2.png" alt="“伊成博客”"></p></li><li><p>个人信息页<br><img src="/images/bylw3.png" alt="“伊成博客”"></p></li><li><p>数据分析页<br><img src="/images/bylw4.png" alt="“伊成博客”"></p></li><li><p>选题情况页<br><img src="/images/bylw5.png" alt="“伊成博客”"></p></li><li><p>菜单开关页<br><img src="/images/bylw6.png" alt="“伊成博客”"></p></li><li><p>学生管理页<br><img src="/images/bylw7.png" alt="“伊成博客”"></p></li><li><p>修改密码页<br><img src="/images/bylw8.png" alt="“伊成博客”"></p></li><li><p>下载任务书<br><img src="/images/bylw9.png" alt="“伊成博客”"></p></li><li><p>上传论文页<br><img src="/images/bylw10.png" alt="“伊成博客”"></p></li><li><p>选定学生页<br><img src="/images/bylw11.png" alt="“伊成博客”"></p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>使用IDEA(eclipse)前导入本项目前，请确保你本地环境是已经配置好了Java环境变量，本地安装好了虚拟机且是centos7。<br>文件服务器搭建可以参考 <a href="http://www.devcheng.net/post/c668f449.html">点击 文件服务器搭建 传送门</a></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要源码可以通过</p><p>QQ 搜索我们的群号：816175200</p><p>也可以直接在博客里找到我的QQ联系我！</p><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a><strong>温馨提示</strong></h2><p>本项目可以当做毕业设计，内含毕业论文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目是基于Spring Boot开发的毕业论文管理系统，系统用户角色分为三个类型，分别是：学生，教师，管
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="毕业论文管理系统" scheme="http://www.devcheng.net/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>centos7.x搭建ftp服务及创建用户</title>
    <link href="http://www.devcheng.net/post/c668f449.html"/>
    <id>http://www.devcheng.net/post/c668f449.html</id>
    <published>2020-04-18T13:23:05.000Z</published>
    <updated>2020-04-18T13:45:26.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FTP是什么东东？"><a href="#FTP是什么东东？" class="headerlink" title="FTP是什么东东？"></a>FTP是什么东东？</h2><p>FTP是 File Transfer Protocol 文件传输协议的英文名称,用于在Internet上控制文件的双向传输. 同时它也是一个应用程序.一般的Linux系统默认带有ftp软件或者是vsftpd。</p><h2 id="为何搭建？"><a href="#为何搭建？" class="headerlink" title="为何搭建？"></a>为何搭建？</h2><p>目的是从window系统中上传文件到linux系统的服务器里。</p><p>##安装步骤<br>提前使用终端工具连接上对应的服务器，这里我们以Xshell 为例</p><p><strong> 步骤一 </strong><br>登录到服务器后，先切换为 root 用户<br>切换到 home 文件夹下（可以换任意一个你喜欢的文件夹下，这里以home文件夹为例）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br></pre></td></tr></table></figure></p><p><strong> 步骤二 </strong><br>接着，输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤三 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure></p><p><strong> 步骤四 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vsftpd</span><br></pre></td></tr></table></figure></p><p>注意： 安装完成后，找到 /etc/vsftpd/vsftpd.conf 文件，是vsftp的配置文件。</p><p><strong> 步骤五 </strong><br>修改selinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsebool -a | grep ftp</span><br></pre></td></tr></table></figure></p><p> <img src="/images/devcheng_net_ftp2.png" alt="“伊成博客”"></p><p>执行上面命令，从返回的结果看到 ftpd_full_access 和 tftp_home_dir两行都是off，说明没有开启外网的访问。</p><p><strong> 步骤六 </strong><br>开启外网的访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># setsebool -P ftpd_full_access on</span></span><br><span class="line">[root@bogon ~]<span class="comment"># setsebool -P tftp_home_dir on</span></span><br></pre></td></tr></table></figure><p>  <img src="/images/devcheng_net_ftp3.png" alt="“伊成博客”"></p><p><strong> 步骤七 </strong><br>关闭匿名访问<br>修改 /etc/vsftpd/vsftpd.conf文件：<br>找到 anonymous_enable=NO  #将YES改为NO</p><p>到此基本配置都完成了，使用以下命令重启 ftp 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure></p><p>另外设置一下 开机启动 ftp 服务<br>使用以下命令即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> vsftpd.service</span><br></pre></td></tr></table></figure></p><p>通过以上的几个步骤，ftp 服务就已经搭建完毕，接着我们还需要创建用户并指定对应的目录</p><h2 id="创建目录以及用户"><a href="#创建目录以及用户" class="headerlink" title="创建目录以及用户"></a>创建目录以及用户</h2><p>在/var 目录下创建一个 www 文件夹,www文件夹中创建一个site文件夹一个da文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">mkdir www</span><br><span class="line"><span class="built_in">cd</span> www</span><br><span class="line">mkdir site</span><br><span class="line">mkdir da</span><br></pre></td></tr></table></figure></p><h3 id="创建用户da并指定用户目录为-var-www-da"><a href="#创建用户da并指定用户目录为-var-www-da" class="headerlink" title="创建用户da并指定用户目录为/var/www/da"></a>创建用户da并指定用户目录为/var/www/da</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /var/www/da da</span><br><span class="line">passwd da</span><br></pre></td></tr></table></figure><p>修改xiao用户的用户目录为/var/www/site<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -d /var/www/site xiao</span><br></pre></td></tr></table></figure></p><h3 id="查看新创建的用户的信息"><a href="#查看新创建的用户的信息" class="headerlink" title="查看新创建的用户的信息"></a>查看新创建的用户的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail /etc/passwd</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp4.png" alt="“伊成博客”"></p><h3 id="修改-etc-vsftpd-vsftpd-conf文件"><a href="#修改-etc-vsftpd-vsftpd-conf文件" class="headerlink" title="修改/etc/vsftpd/vsftpd.conf文件"></a>修改/etc/vsftpd/vsftpd.conf文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi vsftpd.conf</span><br></pre></td></tr></table></figure><p>找到 userlist_enable=YES 在这句后面换行追加以下内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userlist_deny=NO       </span><br><span class="line">userlist_file=/etc/vsftpd/user_list</span><br></pre></td></tr></table></figure></p><p>完成 vsftpd.conf 文件修改之后保存退出。</p><h3 id="编辑-user-list-文件"><a href="#编辑-user-list-文件" class="headerlink" title="编辑 user_list 文件"></a>编辑 user_list 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi user_list</span><br></pre></td></tr></table></figure><p>把上面的两个用户 一行一个用户名,输入 da 和xiao<br>按下esc键退出输入模式进入命令模式<br>输入:wq 保存并退出</p><h3 id="配置文件夹权限"><a href="#配置文件夹权限" class="headerlink" title="配置文件夹权限"></a>配置文件夹权限</h3><p>切换到 /var/www 目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www</span><br></pre></td></tr></table></figure></p><h3 id="更改www里面两个文件夹的权限"><a href="#更改www里面两个文件夹的权限" class="headerlink" title="更改www里面两个文件夹的权限"></a>更改www里面两个文件夹的权限</h3><p>输入以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown da:da da</span><br><span class="line">chown xiao:xiao site</span><br></pre></td></tr></table></figure></p><h3 id="修改da用户的所属用户组-并修改site文件夹的权限"><a href="#修改da用户的所属用户组-并修改site文件夹的权限" class="headerlink" title="修改da用户的所属用户组,并修改site文件夹的权限"></a>修改da用户的所属用户组,并修改site文件夹的权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g xiao da</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_ftp5.png" alt="“伊成博客”"></p><p>修改site文件夹的权限,允许同一个用户组的用户拥有rwx权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 site</span><br></pre></td></tr></table></figure></p><p>到此搭建ftp和创建目录和创建对应用户都全部完成！<br>接下来在代码中验证一下</p><p>使用springboot的配置文件application.yml 配置对应信息，如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ftp:</span><br><span class="line">  host: 192.168.43.41 #你服务器的ip</span><br><span class="line">  port: 21            #端口</span><br><span class="line">  userName: da        #以上创建的ftp用户名</span><br><span class="line">  password: da        #以上创建的ftp密码</span><br><span class="line">  basePath: /var/www/da #文件存放目录</span><br></pre></td></tr></table></figure></p><p><strong>上传文件 代码段 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(String host, <span class="keyword">int</span> port, String username, String password, String basePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String filePath, String filename, InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    FTPClient ftp = <span class="keyword">new</span> FTPClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> reply;</span><br><span class="line">        ftp.connect(host, port);<span class="comment">// 连接FTP服务器</span></span><br><span class="line">        <span class="comment">// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器</span></span><br><span class="line">        ftp.login(username, password);<span class="comment">// 登录</span></span><br><span class="line">        reply = ftp.getReplyCode();</span><br><span class="line">        <span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</span><br><span class="line">            ftp.disconnect();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切换到上传目录</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.changeWorkingDirectory(basePath + filePath)) &#123;</span><br><span class="line">            <span class="comment">//如果目录不存在创建目录</span></span><br><span class="line">            String[] dirs = filePath.split(<span class="string">"/"</span>);</span><br><span class="line">            String tempPath = basePath;</span><br><span class="line">            <span class="keyword">for</span> (String dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == dir || <span class="string">""</span>.equals(dir)) <span class="keyword">continue</span>;</span><br><span class="line">                tempPath += <span class="string">"/"</span> + dir;</span><br><span class="line">                <span class="keyword">if</span> (!ftp.changeWorkingDirectory(tempPath)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ftp.makeDirectory(tempPath)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ftp.changeWorkingDirectory(tempPath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置上传文件的类型为二进制类型</span></span><br><span class="line">        ftp.setFileType(FTP.BINARY_FILE_TYPE);</span><br><span class="line">        <span class="comment">//上传文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ftp.storeFile(filename, input)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">        ftp.logout();</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftp.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ftp.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/devcheng_net_ftp6.png" alt="“伊成博客”"></p><p>看到这里说明以上的配置都没问题，到此本文告一段落了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FTP是什么东东？&quot;&gt;&lt;a href=&quot;#FTP是什么东东？&quot; class=&quot;headerlink&quot; title=&quot;FTP是什么东东？&quot;&gt;&lt;/a&gt;FTP是什么东东？&lt;/h2&gt;&lt;p&gt;FTP是 File Transfer Protocol 文件传输协议的英文名称,用于
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="centos7" scheme="http://www.devcheng.net/tags/centos7/"/>
    
      <category term="搭建ftp服务" scheme="http://www.devcheng.net/tags/%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>win10怎么把两张图片合并为一张</title>
    <link href="http://www.devcheng.net/post/87dbd908.html"/>
    <id>http://www.devcheng.net/post/87dbd908.html</id>
    <published>2020-04-07T05:37:28.000Z</published>
    <updated>2020-04-08T01:56:18.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。</p><p>不管你的操作系统是win7还是win10都自带了一个 画图 软件，利用自带的画图软件就可以轻易合成图片了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备两种图片待合成的图片，例如我这里<br><img src="/images/devcheng_net_pic1.png" alt="“伊成博客”"></p><h2 id="图片合成步骤"><a href="#图片合成步骤" class="headerlink" title="图片合成步骤"></a>图片合成步骤</h2><p><strong> 第一步：</strong><br>点击任意一张图片，选择打开方式 – 选择 画图。<br><img src="/images/devcheng_net_pic2.png" alt="“伊成博客”"></p><p><strong> 第二步：</strong><br>将图片的长和宽做对应的变化，拉伸出更多空白地方用于展示其他图片。<br><img src="/images/devcheng_net_pic3.png" alt="“伊成博客”"></p><p><strong> 第三步：</strong><br>点击 主页 – 点击粘贴 – 选择 粘贴来源<br><img src="/images/devcheng_net_pic4.png" alt="“伊成博客”"></p><p><strong> 第四步：</strong><br>选择需要合成的图片，点击打开。<br><img src="/images/devcheng_net_pic5.png" alt="“伊成博客”"></p><p><strong> 第五步：</strong><br>把两张图片做好对应的位置变化，保存即可。<br><img src="/images/devcheng_net_pic6.png" alt="“伊成博客”"></p><p>这样两张图片就轻易合成为一张图片了，如果是多张图需要合并为一张图，重复操作步骤三即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工作中往往有这样的情况，同事发了多张图片给你，如果利用系统的图片查看软件需要一张一张的打开。来回的切换查看图片，很是不方便。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="win10" scheme="http://www.devcheng.net/tags/win10/"/>
    
      <category term="图片合成" scheme="http://www.devcheng.net/tags/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Redis常问面试题整理</title>
    <link href="http://www.devcheng.net/post/3ffff771.html"/>
    <id>http://www.devcheng.net/post/3ffff771.html</id>
    <published>2020-03-29T05:40:39.000Z</published>
    <updated>2020-03-29T06:16:33.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库。<br>传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin" target="_blank" rel="noopener">CAP 定理</a></p><h2 id="1-Redis支持哪几种数据类型？"><a href="#1-Redis支持哪几种数据类型？" class="headerlink" title="1.Redis支持哪几种数据类型？"></a>1.Redis支持哪几种数据类型？</h2><p>1.string：最基本的数据类型，二进制安全的字符串，最大512M。<br>2.list：按照添加顺序保持顺序的字符串列表。<br>3.set：无序的字符串集合，不存在重复的元素。<br>4.sorted set：已排序的字符串集合。<br>5.hash：key-value对的一种集合。<br><img src="/images/devcheng_net_redis1.png" alt="“伊成博客”"></p><p>另外还有四种特殊的 数据类型<br>1.BloomFilter<br>2.HyperLogLog<br>3.BitMap<br>4.Geo</p><p>这几种数据类型的具体介绍。立即了解redis其他的数据类型 : <a href="https://developer.51cto.com/art/201911/605731.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201911/605731.htm</a></p><p><strong> 注意 关于数据类型多说两句：</strong></p><p>redis里存的都是二进制数据，其实就是字节数组（byte[]），这些字节数据是没有数据类型的，只有把它们按照合理的格式解码后，可以变成一个字符串，整数或对象，此时才具有数据类型。</p><p>这一点必须要记住。<strong> 所以任何东西只要能转化成字节数组（byte[]）的，都可以存到redis里</strong>。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成byte数组。</p><ul><li>关键字（Keys）是用于标识一段数据的一个字符串</li><li>值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么</li></ul><p><strong> 关于key </strong></p><ul><li>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率</li><li>key也不要太短，太短的话，key的可读性会降低</li><li>在一个项目中，key最好使用统一的命名模式，例如 user:10000:passwd</li></ul><h2 id="2-Redis是单进程单线程的吗？"><a href="#2-Redis是单进程单线程的吗？" class="headerlink" title="2.Redis是单进程单线程的吗？"></a>2.Redis是单进程单线程的吗？</h2><p>Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p><h2 id="3-Redis为什么是单线程的？"><a href="#3-Redis为什么是单线程的？" class="headerlink" title="3.Redis为什么是单线程的？"></a>3.Redis为什么是单线程的？</h2><p>多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。<br>因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。<br>单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。</p><p>补充额外知识点 ：其它开源软件采用的模型<br>Nginx：多进程单线程模型<br>Memcached：单进程多线程模型</p><h2 id="4-Memcache与Redis的区别都有哪些？"><a href="#4-Memcache与Redis的区别都有哪些？" class="headerlink" title="4.Memcache与Redis的区别都有哪些？"></a>4.Memcache与Redis的区别都有哪些？</h2><p><strong> Memcache （MC）</strong></p><p>看看 MC 的特点：<br>MC 处理请求时使用多线程异步 IO 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；<br>MC 功能简单，使用内存存储数据；<br>MC 的内存结构以及钙化问题我就不细说了，大家可以查看官网了解下；<br>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；<br>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；<br>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：<br>key 不能超过 250 个字节；<br>value 不能超过 1M 字节；<br>key 的最大失效时间是 30 天；<br>只支持 K-V 结构，不提供持久化和主从同步功能。</p><p><strong> Redis </strong></p><p>先简单说一下 Redis 的特点，方便和 MC 比较。</p><ul><li>与 MC 不同的是，Redis 采用单线程模式处理请求。<br>这样做的原因有 2 个：<br>一个是因为采用了非阻塞的异步事件处理机制；<br>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。</li><li>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</li><li>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。</li><li>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。</li></ul><h2 id="5-什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"><a href="#5-什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？" class="headerlink" title="5.什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"></a>5.什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？</h2><p>1.redis持久化就是把内存的数据写到磁盘中去，防止服务器宕机了内存数据丢失。<br>2.数据持久化的方式有2种：    RDB(默认)  和 AOF 。</p><p><strong> RDB （redis database）</strong><br>    核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数<br><img src="/images/devcheng_net_redis2.png" alt="“伊成博客”"></p><p><strong> AOF （append-only file）</strong><br>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作<br>AOF 写入保存。</p><p>存储的内容是 redis通讯协议格式命令的命令文本存储。点击立即了解  —&gt;  <a href="https://www.cnblogs.com/nele/p/8908298.html" target="_blank" rel="noopener">https://www.cnblogs.com/nele/p/8908298.html</a></p><p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件<br>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。<br><img src="/images/devcheng_net_redis3.png" alt="“伊成博客”"></p><p>区别：<br>1、AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。<br>2、AOF 比 RDB 更安全也更大<br>3、RDB 性能比 AOF 好<br>4、如果两个都配了优先加载AOF</p><h2 id="6-说说-Redis-的淘汰策略？"><a href="#6-说说-Redis-的淘汰策略？" class="headerlink" title="6.说说 Redis 的淘汰策略？"></a>6.说说 Redis 的淘汰策略？</h2><p>Redis提供了6中淘汰策略。</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><p><strong> 使用策略规则：</strong><br>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru<br>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p><h2 id="7-什么是缓存穿透，缓存击穿，缓存雪崩？"><a href="#7-什么是缓存穿透，缓存击穿，缓存雪崩？" class="headerlink" title="7. 什么是缓存穿透，缓存击穿，缓存雪崩？"></a>7. 什么是缓存穿透，缓存击穿，缓存雪崩？</h2><p><strong> 缓存穿透</strong><br>描述： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>解决方案：</p><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p><p><strong> 缓存击穿 </strong></p><p>描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p><p>解决方案：</p><p>设置热点数据永远不过期。<br>加互斥锁，互斥锁参考代码如下：<br><img src="/images/devcheng_net_redis4.png" alt="“伊成博客”"></p><p>说明：</p><p>1）缓存中有数据，直接走上述代码13行后就返回结果了</p><p>2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。</p><p>3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。</p><p><strong> 缓存雪崩</strong> </p><p>描述： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案：</p><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。<br>设置热点数据永远不过期。</p><h2 id="8-Redis-架构模式有哪些？讲讲各自的特点？"><a href="#8-Redis-架构模式有哪些？讲讲各自的特点？" class="headerlink" title="8. Redis 架构模式有哪些？讲讲各自的特点？"></a>8. Redis 架构模式有哪些？讲讲各自的特点？</h2><p><img src="/images/devcheng_net_redis5.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis6.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis7.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis8.png" alt="“伊成博客”"></p><p><img src="/images/devcheng_net_redis9.png" alt="“伊成博客”"></p><h2 id="9-redis-集群方案都有哪些？"><a href="#9-redis-集群方案都有哪些？" class="headerlink" title="9. redis 集群方案都有哪些？"></a>9. redis 集群方案都有哪些？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p><p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><h2 id="10-在Redis中如何保证只存20W的热点数据？"><a href="#10-在Redis中如何保证只存20W的热点数据？" class="headerlink" title="10. 在Redis中如何保证只存20W的热点数据？"></a>10. 在Redis中如何保证只存20W的热点数据？</h2><p>先计算出20W数据需要占用数据的空间，然后设置数据淘汰策略为 allkey-lru 回收最少使用策略。</p><h2 id="11-Redis支持的Java客户端都有哪些？官方推荐使用哪个？"><a href="#11-Redis支持的Java客户端都有哪些？官方推荐使用哪个？" class="headerlink" title="11.Redis支持的Java客户端都有哪些？官方推荐使用哪个？"></a>11.Redis支持的Java客户端都有哪些？官方推荐使用哪个？</h2><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="12-Redis和Redisson有什么关系？"><a href="#12-Redis和Redisson有什么关系？" class="headerlink" title="12.Redis和Redisson有什么关系？"></a>12.Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象<br> (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><h2 id="13-Jedis与Redisson对比有什么优缺点？"><a href="#13-Jedis与Redisson对比有什么优缺点？" class="headerlink" title="13.Jedis与Redisson对比有什么优缺点？"></a>13.Jedis与Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。<br>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h2 id="14-Redis支持事务吗？"><a href="#14-Redis支持事务吗？" class="headerlink" title="14.Redis支持事务吗？"></a>14.Redis支持事务吗？</h2><p>支持 , 表现为多条命令，要么都执行，要么都不执行。</p><p>redis的事务可以分为两步，定义事务和执行事务。<br>使用multi命令开启一个事务，然后把要执行的所有命令都依次排上去。<br>这就定义好了一个事务。此时使用exec命令来执行这个事务，或使用discard命令来放弃这个事务。<br>你可能希望在你的事务开始前，你关心的key不想被别人操作，那么可以使用watch命令来监视这些key，<br>如果开始执行前这些key被其它命令操作了则会取消事务的。也可以使用unwatch命令来取消对这些key的监视。</p><p>redis事务具有以下特点：<br>1、如果开始执行事务前出错，则所有命令都不执行<br>2、一旦开始，则保证所有命令一次性按顺序执行完而不被打断<br>3、如果执行过程中遇到错误，会继续执行下去，不会停止的<br>4、对于执行过程中遇到错误，是不会进行回滚的</p><p>很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。保证不了原子性是因为redis不支持回滚，不过它也给出了不支持的理由。</p><p>不支持回滚的理由：<br>1、redis认为，失败都是由命令使用不当造成<br>2、redis这样做，是为了保持内部实现简单快速<br>3、redis还认为，回滚并不能解决所有问题<br>因此 , 使用redis事务的不太多</p><h2 id="15-Redis分布式锁如何续期？"><a href="#15-Redis分布式锁如何续期？" class="headerlink" title="15. Redis分布式锁如何续期？"></a>15. Redis分布式锁如何续期？</h2><p><a href="https://zhuanlan.zhihu.com/p/71185118" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71185118</a></p><p>16.Redis分布式锁如何防止死锁<br> 方法1 ， 编写2个方法一个加锁，一个解锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li><li>已有锁存在，不做任何操作。</li></ol><p><strong> 解锁代码</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 释放分布式锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">       String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">       Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">       <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，没想到这次居然用上了。<br>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。<br>eval()方法是将Lua代码交给Redis服务端执行</p><p><strong> Redis常用命令及介绍 </strong><br><strong> 字符串：</strong><br>setnx(key,value)  只在键 key 不存在的情况下， 将键 key 的值设置为 value 。key存在,不做任何操作。<br>setex(key,seconds,value)   将key设置及生存时间seconds秒,原值存在覆盖。<br>psetex(key,milliseconds,value) 与setex同样,只是单位是毫秒。<br>getset(key,value)   设置新值并返回旧值,不存在返回nil<br>setrange(key,offset,value) 从偏移量开始offset开始<br>mset 同时给多个key复制</p><p><strong> 哈希表(map)：</strong><br>hset(hash field value)  将哈希表 hash 中域 field 的值设置为 value<br>hmset key field value [field value …] 同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>hget hash field  返回哈希表中给定域的值。<br>hgetall key      返回哈希表 key 中，所有的域和值。</p><p><strong> 队列(queue):</strong><br>lpush key value [value …] 将一个或多个值 value 插入到列表 key 的表头<br>lpop key   移除并返回列表 key 的头元素,不存在返回nil<br>lset key index value  将列表 key 下标为 index 的元素的值设置为 value 。<br>brpop key [key …]  timeout 在超时时间内移除列表尾元素，阻塞的。</p><p><strong> 集合：</strong><br>sadd key member [member …]  将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略<br>sismember key member  如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。<br>spop key  移除集合key的随机元素<br>smembers key  返回集合 key 中的所有成员。<br>sdiff key [key …]  返回给定多个集合之间的差集。</p><p><strong> 有序集合：</strong><br>zadd key score member [[score member] [score member] …]   将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>zscore key member 返回有序集 key 中，成员 member 的 score 值。<br>zcount key min max   score 值在 min 和 max 之间的成员的数量。<br>zrange key start stop [withscores]  返回有序集 key 中，指定区间内的成员(从小到大)。<br>zrank key member  返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br>zrem key member [member …]   移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>时效性：<br>expire(key,seconds) 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<br>expireat( key,timestamp) 设置过期时间戳,expireatcache1355292000# 这个 key 将在 2012.12.12 过期<br>ttl(key) 返回剩余时间<br>persist key 移除key有效期，转换成永久的</p><p>数据指令：<br>keys pattern   符合给定模式的 key 列表。阻塞的<br>scan  异步的  有重复 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="redis" scheme="http://www.devcheng.net/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发的动漫商城系统源码分享</title>
    <link href="http://www.devcheng.net/post/536e3846.html"/>
    <id>http://www.devcheng.net/post/536e3846.html</id>
    <published>2020-03-15T09:24:25.000Z</published>
    <updated>2020-03-15T09:55:48.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>动漫商城项目包括商城前台系统和商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。<br>前台商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、支付流程、订单流程(微信支付/支付宝沙箱支付)、个人订单管理、会员中心、帮助中心、公告管理等模块。<br>后台管理系统包含数据面板、轮播图管理、商品管理、订单管理、会员管理、分类管理、系统设置等模块。</p><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot</li><li>Mybatis</li><li>Maven 3.X</li><li>Thymeleaf</li></ul><h2 id="前台页面预览"><a href="#前台页面预览" class="headerlink" title="前台页面预览"></a><strong>前台页面预览</strong></h2><ul><li><p>动漫商城首页<br><img src="/images/动漫商城-首页.png" alt="“伊成博客”"></p></li><li><p>商品详情页面<br><img src="/images/动漫商城-商品详情.png" alt="“伊成博客”"></p></li><li><p>购物车页面<br><img src="/images/动漫商城-购物车.png" alt="“伊成博客”"></p></li><li><p>登录页面<br><img src="/images/动漫商城-登录.png" alt="“伊成博客”"></p></li></ul><h2 id="后台管理页面预览"><a href="#后台管理页面预览" class="headerlink" title="后台管理页面预览"></a><strong>后台管理页面预览</strong></h2><ul><li><p>轮播图配置<br><img src="/images/微信截图_1.png" alt="“伊成博客”"></p></li><li><p>商品管理<br><img src="/images/微信截图_2.png" alt="“伊成博客”"></p></li><li><p>会员管理<br><img src="/images/微信截图_3.png" alt="“伊成博客”"></p></li><li><p>订单管理<br><img src="/images/微信截图_4.png" alt="“伊成博客”"></p></li><li><p>公告管理<br><img src="/images/微信截图_5.png" alt="“伊成博客”"></p></li></ul><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要欢迎进群私聊我哦！<br>QQ 搜索我们的群号：816175200<br>也可以直接在博客里找到我的QQ联系我！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;动漫商城项目包括商城前台系统和商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。&lt;
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="源代码" scheme="http://www.devcheng.net/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
      <category term="动漫商城系统" scheme="http://www.devcheng.net/tags/%E5%8A%A8%E6%BC%AB%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot + MyBatis + Maven论坛内容管理系统源码</title>
    <link href="http://www.devcheng.net/post/be40dded.html"/>
    <id>http://www.devcheng.net/post/be40dded.html</id>
    <published>2020-03-02T15:24:39.000Z</published>
    <updated>2020-03-14T12:01:32.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="毕设描述"><a href="#毕设描述" class="headerlink" title="毕设描述"></a><strong>毕设描述</strong></h2><p>xxxForum是一个基于Spring Boot + MyBatis + Maven开发的一个论坛内容管理系统，主要实现了的功能有：</p><ul><li>前台页面展示数据、广告展示</li><li>内容模块：发帖、评论、帖子分类、分页、回帖统计、访问统计、表单验证</li><li>用户模块：权限、资料、头像、邮箱验证</li><li>管理：后台管理、统计图表、帖子/分类管理</li></ul><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>windows 7 , jdk 1.8</p><h2 id="项目采用技术"><a href="#项目采用技术" class="headerlink" title="项目采用技术"></a><strong>项目采用技术</strong></h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a><strong>后端</strong></h3><ul><li>Spring Boot 1.5.5</li><li>Spring Security 4</li><li>Mybatis(mybatis-spring-boot-starter 1.3.1)</li><li>Maven 3.X</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a><strong>前端</strong></h3><ul><li>Thymeleaf</li><li>Bootstrap</li><li>jQuery</li><li>Chart.js</li><li>bootstrap-select</li><li>daterangepicker</li></ul><h2 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a><strong>数据库文件</strong></h2><p>在项目文件里面</p><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a><strong>项目截图</strong></h2><p><img src="/images/shouye1.png" alt="“论坛内容管理系统”"></p><p><img src="/images/tiezidetail2.png" alt="“论坛内容管理系统”"></p><p><img src="/images/login3.png" alt="“论坛内容管理系统”"></p><p><img src="/images/zhuce4.png" alt="“论坛内容管理系统”"></p><p><img src="/images/table5.png" alt="“论坛内容管理系统”"></p><p><img src="/images/user6.png" alt="“论坛内容管理系统”"></p><p><img src="/images/fenlei9.png" alt="“论坛内容管理系统”"></p><p><img src="/images/run1.png" alt="“论坛内容管理系统”"></p><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>登录用户名和密码</p><p>admin / admin </p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>QQ 搜索我们的群号：816175200</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol><li>头像如何配置？<br>在电脑选一个盘，新建一个文件夹 例如：在C盘新建一个avatar文件夹，里面存放你的头像图片。<br>找到 application.properties 配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ==============================</span><br><span class="line"># avator location</span><br><span class="line"># ==============================</span><br><span class="line">resource.staticResourceLocation=C:/avatar/</span><br></pre></td></tr></table></figure></li></ol><p>写好配置，找到 StaticResourceConfig 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">   //这里也要和之前的对应起来</span><br><span class="line">   registry.addResourceHandler(&quot;/avatar/**&quot;).addResourceLocations(&quot;file:C:/avatar/&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数据库里面和这对应就可以了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;毕设描述&quot;&gt;&lt;a href=&quot;#毕设描述&quot; class=&quot;headerlink&quot; title=&quot;毕设描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;毕设描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;xxxForum是一个基于Spring Boot + MyBatis + Maven开发的
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="Spring Boot" scheme="http://www.devcheng.net/tags/Spring-Boot/"/>
    
      <category term="论坛内容管理系统" scheme="http://www.devcheng.net/tags/%E8%AE%BA%E5%9D%9B%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java8日期和时间段的计算</title>
    <link href="http://www.devcheng.net/post/55e45d5a.html"/>
    <id>http://www.devcheng.net/post/55e45d5a.html</id>
    <published>2020-02-25T05:53:57.000Z</published>
    <updated>2020-03-29T05:42:08.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java8之前，计算日期相差多少天一般的做法都是借助SimpleDateFormat对两个日期格式化之后在进行比较。在编写代码的过程中，计算一个方法具体耗时多少分钟，执行了多少秒等需求，一般也是借助System.currentTimeMillis()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"此处消耗了："</span>+(end-start));</span><br></pre></td></tr></table></figure><p>下面看看在Java8中如何计算日期差以及时间差。</p><h2 id="Java8中计算日期差"><a href="#Java8中计算日期差" class="headerlink" title="Java8中计算日期差"></a>Java8中计算日期差</h2><p>比如日期A是1992-08-01 到 今天（2020-02-25）一共相差多少天：</p><p>代码1 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate startDate = LocalDate.of(<span class="number">1992</span>, Month.AUGUST, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"日期A : "</span> + startDate);</span><br><span class="line"></span><br><span class="line">        LocalDate endDate = LocalDate.of(<span class="number">2020</span>, Month.FEBRUARY, <span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">"日期B : "</span> + endDate);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> daysDiff = ChronoUnit.DAYS.between(startDate, endDate);</span><br><span class="line">        System.out.println(<span class="string">"两个日期之间的差在天数   : "</span> + daysDiff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">日期A : 1992-08-01</span><br><span class="line">日期B : 2020-02-25</span><br><span class="line">两个日期之间的差在天数   : 10069</span><br></pre></td></tr></table></figure><p>代码2 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Period period = Period.between(LocalDate.of(<span class="number">1992</span>, <span class="number">8</span>, <span class="number">1</span>), LocalDate.of(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">25</span>));</span><br><span class="line">        System.out.println(<span class="string">"两个日期之间的差   : "</span> + period.getYears()+<span class="string">"年，"</span>+period.getMonths()+<span class="string">"月，"</span>+period.getDays()+<span class="string">"天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个日期之间的差   : 27年，6月，24天</span><br></pre></td></tr></table></figure><p> <strong>ChronoUnit 类可用于在单个时间单位内测量一段时间，例如天数或秒。</strong></p><p> <strong>Period类 主要用方法getYears()，getMonths()和getDays()来计算。</strong></p><h2 id="Java8中计算时间差"><a href="#Java8中计算时间差" class="headerlink" title="Java8中计算时间差"></a>Java8中计算时间差</h2><p>列如文中说的计算某个方法运行耗时了多长，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设是业务逻辑部分代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">100000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"---"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"此处消耗了（s）: "</span> + Duration.between(start, end).getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- ...</span><br><span class="line">---99994</span><br><span class="line">---99995</span><br><span class="line">---99996</span><br><span class="line">---99997</span><br><span class="line">---99998</span><br><span class="line">---99999</span><br><span class="line">此处消耗了（s）: 1</span><br></pre></td></tr></table></figure><p><strong>Duration 类提供了使用基于时间的值（如秒，纳秒）测量时间量的方法。</strong></p><p>关于三个类更多的说明，可自行参考官方API。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a> (官方API)</p><p><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">http://www.matools.com/api/java8</a> (中文版API)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java8之前，计算日期相差多少天一般的做法都是借助SimpleDateFormat对两个日期格式化之后在进行比较。在编写代码的过程中，计
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="Java8" scheme="http://www.devcheng.net/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>org.springframework.amqp.support.converter.MessageConversionExcep异常</title>
    <link href="http://www.devcheng.net/post/128dfa7.html"/>
    <id>http://www.devcheng.net/post/128dfa7.html</id>
    <published>2020-02-22T07:18:35.000Z</published>
    <updated>2020-02-22T07:20:32.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>最近，在用Spring Boot+rabbitMQ整合的过程中，测试生产者发送单条字符串消息到消费者消费这个过程没出现任何问题。</p><p>可是在实际应用中，往往在生产中不可能只生产字符串的，更多时候需要生产一个对象发送到队列，消费者从队列里面获取一个对象进行消费。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><p>先定义一个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从代码中，可以发现定义对象的时候已经做了序列化了。</p><p>生产者代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息方法调用: 构建自定义对象消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">//id + 时间戳 全局唯一 </span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">"0987654321"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"exchange-2"</span>, <span class="string">"springboot.def"</span>, order, correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试生产者发送代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSender2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Order order = <span class="keyword">new</span> Order(<span class="string">"001"</span>, <span class="string">"第一个订单"</span>);</span><br><span class="line">     rabbitSender.sendOrder(order);</span><br><span class="line">     <span class="comment">//防止资源提前关闭，ConfirmCallback异步回调失败</span></span><br><span class="line">     Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RabbitListener(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">            value = <span class="meta">@Queue</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.name&#125;"</span>, </span><br><span class="line">            durable=<span class="string">"$&#123;spring.rabbitmq.listener.order.queue.durable&#125;"</span>),</span><br><span class="line">            exchange = <span class="meta">@Exchange</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.name&#125;"</span>, </span><br><span class="line">            durable=<span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;"</span>, </span><br><span class="line">            type= <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.type&#125;"</span>, </span><br><span class="line">            ignoreDeclarationExceptions = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationExceptions&#125;"</span>),</span><br><span class="line">            key = <span class="string">"$&#123;spring.rabbitmq.listener.order.key&#125;"</span></span><br><span class="line">            )</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(@Payload Order order, </span></span></span><br><span class="line"><span class="function"><span class="params">            Channel channel, </span></span></span><br><span class="line"><span class="function"><span class="params">            @Headers Map&lt;String, Object&gt; headers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------------------------------"</span>);</span><br><span class="line">        System.err.println(<span class="string">"消费端order: "</span> + order.getId());</span><br><span class="line">        Long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">        <span class="comment">//手工ACK</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当生产者有数据发送到队列的时候，消费者这端代码报了一个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Listener method could not be invoked with the incoming message</span><br><span class="line">Endpoint handler details:</span><br><span class="line">Method [public void com.rabbit.producer.RabbitProducer.receiver.OrderRecevier.onOrderMessage(com.rabbit.producer.RabbitProducer.entity.Order,com.rabbitmq.client.Channel,java.util.Map&lt;java.lang.String, java.lang.Object&gt;) throws java.lang.Exception]</span><br><span class="line">Bean [com.rabbit.producer.RabbitProducer.receiver.OrderRecevier@600b7b3d]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:185) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.onMessage(MessagingMessageListenerAdapter.java:120) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:1414) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.actualInvokeListener(AbstractMessageListenerContainer.java:1337) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:1324) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:1303) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:817) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:801) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$700(SimpleMessageListenerContainer.java:77) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1042) [spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at java.lang.Thread.run(Thread.java:745) [na:1.8.0_71]</span><br><span class="line">Caused by: org.springframework.messaging.converter.MessageConversionException: Cannot convert from [com.rabbit.Springboot4RabbitMQ.entity.Order] to [com.rabbit.producer.RabbitProducer.entity.Order] for GenericMessage [payload=Order [id=RabbitMQTestId0002, name=HelloWorld, messageId=1538919928275$0836e0e7-4976-457e-92fb-44b937255855], headers=&#123;amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=order.ABC, amqp_receivedExchange=order-exchange, amqp_deliveryTag=1, amqp_consumerQueue=order-queue, amqp_redelivered=false, id=0ffe4dcd-048f-f274-bca9-5550f9ecebb1, amqp_consumerTag=amq.ctag-82Oo3kl1I138E2pvVRsczA, contentType=application/x-java-serialized-object, timestamp=1538919929083&#125;]</span><br><span class="line">at org.springframework.messaging.handler.annotation.support.PayloadArgumentResolver.resolveArgument(PayloadArgumentResolver.java:144) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:116) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:137) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:109) ~[spring-messaging-5.0.8.RELEASE.jar:5.0.8.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:51) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">at org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:182) ~[spring-rabbit-2.0.5.RELEASE.jar:2.0.5.RELEASE]</span><br><span class="line">... 10 common frames omitted</span><br></pre></td></tr></table></figure></p><p>从异常信息中可以看到是消费者对消息反序列化的时候失败了。虽然两个项目中的Order类是完全一样的，但在进行反序列化的时候还是失败了!</p><p>于是找了一番解决方案··</p><p><strong>第一种</strong>：<br>消费者引用生产者项目中的消息体即Order.java</p><p>在消费者项目上【右键】-&gt;【Bulid Path】-&gt;【Configure Build Path】-&gt;【Projects】-&gt;【Add】 选择生产者项目，然后消费者项目就可以引用生产者项目中类，这样完全保证了两个项目中JavaBean是一致的，所以能解决反序列失败的问题。</p><p><strong>第二种</strong>：<br>生产者在发送消息前将消息体转换为JSONObject，消费者以JSONObject接收消息，再转换为对应的实体类。</p><p>生产者的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息方法调用: 构建自定义对象消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">//id + 时间戳 全局唯一 </span></span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">"0987654321"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"exchange-2"</span>, <span class="string">"springboot.def"</span>, FastJsonConvertUtil.toJsonObject(order), correlationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.name&#125;"</span>, durable = <span class="string">"$&#123;spring.rabbitmq.listener.order.queue.durable&#125;"</span>), exchange = <span class="meta">@Exchange</span>(value = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.name&#125;"</span>, durable = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.durable&#125;"</span>, type = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.type&#125;"</span>, ignoreDeclarationExceptions = <span class="string">"$&#123;spring.rabbitmq.listener.order.exchange.ignoreDeclarationeExceptions&#125;"</span>), key = <span class="string">"$&#123;spring.rabbitmq.listener.order.key&#125;"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(@Payload JSONObject object, Channel channel, @Headers Map&lt;String, Object&gt; headers)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">        Order order = JsonConvertUtils.convertJSONToObject(object);</span><br><span class="line">        System.err.println(<span class="string">"消费端Order: "</span> + order.toString());</span><br><span class="line">        Long deliveryTag = (Long)headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近，在用Spring Boot+rabbitMQ整合的过程中，测试生产者发送单条字符串消息到消费者消费这
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="rabbitMQ" scheme="http://www.devcheng.net/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot后台管理系统</title>
    <link href="http://www.devcheng.net/post/fb5a8cfd.html"/>
    <id>http://www.devcheng.net/post/fb5a8cfd.html</id>
    <published>2020-02-15T10:43:04.000Z</published>
    <updated>2020-05-17T05:25:46.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/devcheng_share_m_1.jpg" alt="“Spring-Boot后台管理系统”"></p><h3 id="叨叨叨"><a href="#叨叨叨" class="headerlink" title="叨叨叨"></a><strong>叨叨叨</strong></h3><p>spring boot 后台管理系统，可以让你接触到的技术栈有以下：</p><ul><li>spring boot</li><li>shiro</li><li>druid</li><li>maven</li><li>…</li></ul><p>数据库用的是 mysql，前端使用的是 thymeleaf模板引擎。<br>开发工具：IntelliJ IDEA ，JDK 1.8</p><p>现在已经实现的功能点有：</p><ul><li>登录 / 退出</li><li>用户管理</li><li>角色管理</li><li>权限管理</li></ul><p>基本上学习用户角色权限，作为入门就足够了哦！如果有其他的想法，你可以下载这个代码根据自己的需求加上你自己的需求即可。</p><p>接着看一下项目截图：</p><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a><strong>登录页面</strong></h3><p><img src="/images/share_1.png" alt="“Spring Boot后台管理系统”"></p><h3 id="功能1"><a href="#功能1" class="headerlink" title="功能1"></a><strong>功能1</strong></h3><p><img src="/images/share_2.png" alt="“Spring Boot后台管理系统”"></p><h3 id="功能2"><a href="#功能2" class="headerlink" title="功能2"></a><strong>功能2</strong></h3><p><img src="/images/share_3.png" alt="“Spring Boot后台管理系统”"></p><h3 id="加入我们群"><a href="#加入我们群" class="headerlink" title="加入我们群"></a><strong>加入我们群</strong></h3><p>如果有需要，欢迎可以加入我们的QQ群！（QQ搜索 816175200，加入我们的QQ群吧！）<br>有任何问题，也可以加入我们的QQ群，欢迎交（che）流（dan）！</p><h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a><strong>如何获取</strong></h3><p>方式一：将本博客网址 <a href="http://www.devcheng.net">www.devcheng.net</a> 发送到任意2个技术群，截图发我即可获取源码。</p><p>方式二：通过本文打赏也可获取源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/devcheng_share_m_1.jpg&quot; alt=&quot;“Spring-Boot后台管理系统”&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;叨叨叨&quot;&gt;&lt;a href=&quot;#叨叨叨&quot; class=&quot;headerlink&quot; title=&quot;叨叨叨&quot;&gt;&lt;/a&gt;&lt;
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="spring boot" scheme="http://www.devcheng.net/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot开发学生成绩管理系统</title>
    <link href="http://www.devcheng.net/post/d01dd317.html"/>
    <id>http://www.devcheng.net/post/d01dd317.html</id>
    <published>2020-01-06T09:09:12.000Z</published>
    <updated>2020-03-14T12:06:03.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>本项目为学生成绩管理系统，可以当作毕业设计，也可以成为Spirng Boot初学者的学习代码！</p><h2 id="系统描述"><a href="#系统描述" class="headerlink" title="系统描述"></a><strong>系统描述</strong></h2><p>学生成绩管理系统提供了三种角色：学生，老师，网站管理员。主要实现的功能如下：</p><ul><li>登录 &amp; 安全退出</li><li>学生信息管理</li><li>班级信息管理</li><li>教师信息管理</li><li>课程信息管理</li><li>选课信息管理</li><li>考勤信息管理</li><li>请假信息管理</li><li>成绩信息管理</li><li>系统管理</li></ul><h2 id="开发环境（运行环境）"><a href="#开发环境（运行环境）" class="headerlink" title="开发环境（运行环境）"></a><strong>开发环境（运行环境）</strong></h2><p>-系统环境：Windows 10<br>-开发工具：IntelliJ IDEA<br>-Java版本：JDK 1.8</p><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a><strong>项目技术栈</strong></h2><ul><li>Spring Boot 2.0.2</li><li>Mybatis(mybatis-spring-boot-starter 1.1.1)</li><li>Maven 3.X</li><li>Apache poi</li><li>EasyUI</li><li>Thymeleaf</li></ul><h2 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a><strong>数据库文件</strong></h2><ul><li>db_studentmanager.sql</li></ul><h2 id="登录地址"><a href="#登录地址" class="headerlink" title="登录地址"></a><strong>登录地址</strong></h2><p><a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p><p>不同角色的账号详细参考数据库<br>学生，老师，管理员的密码均为：123456</p><h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a><strong>项目截图</strong></h2><p><img src="/images/xiangmuPhoto1.png" alt="“伊成博客”"></p><h2 id="项目运行截图"><a href="#项目运行截图" class="headerlink" title="项目运行截图"></a><strong>项目运行截图</strong></h2><p>以下截图仅仅展示部分功能，上文罗列的功能均已实现！</p><p><img src="/images/studenmanagerrun1.png" alt="“伊成博客”"></p><p><img src="/images/studenmanagerrun2.png" alt="“伊成博客”"></p><p><img src="/images/xiangmuPhoto3.png" alt="“伊成博客”"></p><p><img src="/images/studenmanagerrun4.png" alt="“伊成博客”"></p><h2 id="联系我们"><a href="#联系我们" class="headerlink" title="联系我们"></a><strong>联系我们</strong></h2><p>如有需要欢迎进群私聊我哦！<br>QQ 搜索我们的群号：816175200<br>也可以直接在博客里找到我的QQ联系我！</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><p>获取代码之后，使用IDEA导入本项目前，请确保你本地环境是已经含有代码所需要运行环境的条件了。</p><p>接着找到对应的sql文件，将其导入到你本地的数据库即可。</p><p>最后修改项目中配置文件中的数据库对应的信息，确认修改完毕，找到对应的xxxApplication直接运行吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;本项目为学生成绩管理系统，可以当作毕业设计，也可以成为Spirng Boot初学者的学习代码！&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="codeshare" scheme="http://www.devcheng.net/categories/codeshare/"/>
    
    
      <category term="SpringBoot" scheme="http://www.devcheng.net/tags/SpringBoot/"/>
    
      <category term="源代码" scheme="http://www.devcheng.net/tags/%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
      <category term="学生成绩管理系统" scheme="http://www.devcheng.net/tags/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>adb 无线连接小米手机(免ROOT)</title>
    <link href="http://www.devcheng.net/post/9e1d1814.html"/>
    <id>http://www.devcheng.net/post/9e1d1814.html</id>
    <published>2019-12-28T11:43:54.000Z</published>
    <updated>2020-01-04T03:56:11.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>adb本身提供了网络调试的功能，即使不用USB数据线连上Android手机的情况下，也可以使用WiFi连接add进行调试。详细的作法如下：</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><ul><li>开启USB调试</li></ul><p>1.打开手机设置，点击“我的设备”，选择“全部参数”</p><p>2.连续点击MIUI版本几次，返回到设置主界面，点击“更多设置”</p><p>3.点击“开发者选项”，打开“开启开发者选项”和“USB调试”</p><p>开启USB调试之后，确保电脑和手机都是使用的是同一个网络，接着查看手机的IP地址。<br>在手机屏幕上找到设置的图标，然后在打开的小米手机设置页面，点击WLAN菜单项,接着在打开的网络设置页面中，点击当前连接网络右侧的更多按钮,然后在打开的网络详情页面中，我们可以看到当前手机的IP地址了。</p><ul><li>adb无线连接手机<br>第一步：使用命令 adb  tcpip 5555 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb  tcpip 5555</span><br></pre></td></tr></table></figure><p>成功后,把数据线拔掉，然后重新连接USB数据线。</p><p>第二步： 使用命令 adb connect ip (这里的ip就是刚刚查看的手机IP地址)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb  connect 192.168.1.166</span><br></pre></td></tr></table></figure><p>配置完成！</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h2><p>其他手机可以借鉴这个方法，不同手机可能会有不同的解决方法，如果更好的解决方法，请留言告知！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;adb本身提供了网络调试的功能，即使不用USB数据线连上Android手机的情况下，也可以使用WiFi连接
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="adb" scheme="http://www.devcheng.net/tags/adb/"/>
    
      <category term="无线连接小米手机" scheme="http://www.devcheng.net/tags/%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java+adb命令实现自动刷视频脚本</title>
    <link href="http://www.devcheng.net/post/58251880.html"/>
    <id>http://www.devcheng.net/post/58251880.html</id>
    <published>2019-12-15T11:34:42.000Z</published>
    <updated>2020-01-04T04:00:33.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近，看身边的朋友很喜欢看某手视频，某音视频。边看还能赚点点零花钱，最开始的时候也遇到过很多类似的APP，比如有一些看新闻奖励金币，然后金币变成人民币到达多少金额之后可以提现，一般人都是喜欢自己去手把手的去刷，今天我们就用java加adb写一个程序出来实现自动刷视频。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><p>在电脑上下载安装adb，手机开启开发者模式，记得把 USB调试 也打开。</p><p><a href="https://blog.csdn.net/ainongmin1hao/article/details/82049757/" target="_blank" rel="noopener">点击 ADB的安装与使用 传送门</a></p><p>adb安装完成之后，打开cmd 窗口输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure><p><img src="/images/devcheng_net_java_adb1.png" alt="image"></p><p>接着，用数据线把手机连接上电脑即可。输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>如果一切正常这里会显示你的devices的设备号。</p><p><img src="/images/devcheng_net_java_adb2.png" alt="image"></p><p>如果你按照以上的步骤还没折腾出来你的devices的设备号，请参考以下链接 ⬇⬇⬇</p><p><a href="http://baijiahao.baidu.com/s?id=1582302895110472911&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">点击 adb devices找不到设备？设备VID缺失解决方案 传送门</a></p><p>接着在手机上安装一个APP，在这里我就下载了一个 某手极速版。</p><h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a><strong>编写程序</strong></h2><p>编写程序之前，我们到底要怎么去实现呢？<br>实现原理：利用adb截图上传到电脑，得到截图使用adb自带的命令模拟现实中观看视频的滑动。</p><p>截图代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">screenshot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">                    .exec(<span class="string">"adb shell /system/bin/screencap -p /sdcard/screenshot.png"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上传手机截图到电脑</span></span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">                    .exec(<span class="string">"adb pull /sdcard/screenshot.png C:/Users/Administrator/Downloads/screenshot.png"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"=============== Get screenshot success ==============="</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>模拟向上滑动代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wipeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">                    .exec(<span class="string">"adb shell input swipe 540 480 540 100 "</span>);</span><br><span class="line">            <span class="keyword">int</span> i = (<span class="keyword">int</span>)(<span class="number">15000</span>+Math.random()*(<span class="number">30000</span>-<span class="number">10000</span>));</span><br><span class="line">            Thread.sleep(i);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心代码都已经贴出来了，在模拟向上滑动代码中，需要注意一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = (int)(15000+Math.random()*(30000-10000));</span><br><span class="line">Thread.sleep(i);</span><br></pre></td></tr></table></figure><p>这里为什么要做成随机数的原因就是为了防止被检测。这个地方的睡眠时间大家可以根据不同的应用更改！</p><p>接着就写一个main方法就完成了！</p><p>以上的代码适用于各种刷视频得金币的APP，万变不离其宗！</p><h3 id="加入我们群"><a href="#加入我们群" class="headerlink" title="加入我们群"></a><strong>加入我们群</strong></h3><p>如果有需要，欢迎可以加入我们的QQ群！（QQ搜索 816175200，加入我们的QQ群吧！）<br>有任何问题，也可以加入我们的QQ群，欢迎交（che）流（dan）！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近，看身边的朋友很喜欢看某手视频，某音视频。边看还能赚点点零花钱，最开始的时候也遇到过很多类似的APP，
      
    
    </summary>
    
      <category term="blogshare" scheme="http://www.devcheng.net/categories/blogshare/"/>
    
    
      <category term="ADB" scheme="http://www.devcheng.net/tags/ADB/"/>
    
  </entry>
  
</feed>
